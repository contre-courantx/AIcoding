<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TNTåŒäººå¼¹é“å¤§æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #98FB98, #8B4513);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-container {
            position: relative;
            width: 1000px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #228B22 60%, #8B4513 100%);
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            background: transparent;
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            color: white;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }

        .player1 {
            color: #4CAF50;
        }

        .player2 {
            color: #FF6B6B;
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-hp {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 150px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .hp-fill.player2 {
            background: linear-gradient(90deg, #FF6B6B, #FF8A8A);
        }

        .game-info {
            text-align: center;
            flex: 1;
        }

        .current-turn {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .turn-timer {
            font-size: 18px;
            color: #FFD700;
            margin-top: 5px;
            font-weight: bold;
        }

        .turn-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 3px solid #FFD700;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .weapon-info {
            font-size: 14px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .power-meter {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            display: none;
            align-items: center;
            padding: 5px;
        }

        .power-fill {
            height: 20px;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .power-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .fly-meter {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 25px;
            background: rgba(0,0,0,0.8);
            border-radius: 12px;
            display: none;
            align-items: center;
            padding: 3px;
        }

        .fly-fill {
            height: 19px;
            background: linear-gradient(90deg, #87CEEB, #4169E1, #0000FF);
            border-radius: 9px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .fly-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .controls {
            width: 1000px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            margin-top: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
        }
        
        .controls-grid > div {
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            line-height: 1.4;
        }
        
        .controls-tip {
            text-align: center;
            color: #87CEEB;
            font-size: 13px;
            border-top: 1px solid #444;
            padding-top: 8px;
        }

        .weapon-selector {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }

        .weapon-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .weapon-item {
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .weapon-item:hover {
            border-color: #4CAF50;
            background: rgba(255,255,255,0.2);
        }

        .weapon-item.selected {
            border-color: #FFD700;
            background: rgba(255,215,0,0.2);
        }

        .weapon-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .weapon-name {
            font-size: 14px;
            font-weight: bold;
        }

        .weapon-desc {
            font-size: 10px;
            color: #ccc;
            margin-top: 5px;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        .winner-text {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .restart-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
        }

        .explosion {
            position: absolute;
            pointer-events: none;
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .game-mode-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 2000;
        }

        .mode-title {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .mode-subtitle {
            font-size: 18px;
            margin-bottom: 40px;
            color: #87CEEB;
            line-height: 1.5;
        }

        .mode-options {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .mode-option {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 30px 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            position: relative;
            overflow: hidden;
        }

        .mode-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
            border-color: #FFD700;
        }

        .mode-option.ai-mode {
            background: linear-gradient(45deg, #FF6B6B, #FF8A8A);
        }

        .mode-option.ai-mode:hover {
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        }

        .mode-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .mode-option:hover::before {
            left: 100%;
        }

        .mode-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
        }

        .mode-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .mode-desc {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            line-height: 1.4;
        }

        .mode-features {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-top: 8px;
            font-style: italic;
        }

        .difficulty-easy {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
        }

        .difficulty-easy:hover {
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
        }

        .difficulty-medium {
            background: linear-gradient(45deg, #FF9800, #FFB74D);
        }

        .difficulty-medium:hover {
            box-shadow: 0 10px 25px rgba(255, 152, 0, 0.4);
        }

        .difficulty-hard {
            background: linear-gradient(45deg, #F44336, #EF5350);
        }

        .difficulty-hard:hover {
            box-shadow: 0 10px 25px rgba(244, 67, 54, 0.4);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <!-- UIé¢æ¿ -->
        <div class="ui-panel">
            <div class="player-info player1">
                <div class="player-name" id="player1Name">ç©å®¶1 (WASD)</div>
                <div class="player-hp">HP: <span id="player1HP">100</span>/100</div>
                <div class="hp-bar">
                    <div class="hp-fill" id="player1HPBar" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="game-info">
                <div class="current-turn" id="currentTurn">ç©å®¶1å›åˆ</div>
                <div class="turn-timer" id="turnTimer">å‰©ä½™æ—¶é—´: 10ç§’</div>
                <div class="weapon-info">
                    <span>æ­¦å™¨: <span id="currentWeapon">æ™®é€šç‚¸å¼¹</span></span>
                    <span>æŒ‰Qåˆ‡æ¢æ­¦å™¨</span>
                </div>
            </div>
            
            <div class="player-info player2">
                <div class="player-name" id="player2Name">ç©å®¶2 (æ–¹å‘é”®)</div>
                <div class="player-hp">HP: <span id="player2HP">100</span>/100</div>
                <div class="hp-bar">
                    <div class="hp-fill player2" id="player2HPBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- åŠ›é‡æ¡ -->
        <div class="power-meter" id="powerMeter">
            <div class="power-fill" id="powerFill"></div>
            <div class="power-text">æŒ‰ä½ç©ºæ ¼é”®è“„åŠ›</div>
        </div>

        <!-- é£è¡ŒåŠ›é‡æ¡ -->
        <div class="fly-meter" id="flyMeter">
            <div class="fly-fill" id="flyFill"></div>
            <div class="fly-text">æŒ‰ä½ç©ºæ ¼é”®è“„åŠ›é£è¡Œ</div>
        </div>

        <!-- æ­¦å™¨é€‰æ‹©å™¨ -->
        <div class="weapon-selector" id="weaponSelector">
            <h3>é€‰æ‹©æ­¦å™¨</h3>
            <div class="weapon-grid" id="weaponGrid">
                <!-- æ­¦å™¨é€‰é¡¹å°†é€šè¿‡JSç”Ÿæˆ -->
            </div>
            <p>æŒ‰Qå…³é—­</p>
        </div>



        <!-- å›åˆæç¤º -->
        <div class="turn-notification" id="turnNotification">
            <div id="turnNotificationText">ç©å®¶1çš„å›åˆå¼€å§‹!</div>
        </div>

        <!-- æ¸¸æˆæ¨¡å¼é€‰æ‹©ç•Œé¢ -->
        <div class="game-mode-screen" id="gameModeScreen">
            <div class="mode-title">TNTåŒäººå¼¹é“å¤§æˆ˜</div>
            <div class="mode-subtitle">
                é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹ä½ çš„æˆ˜æ–—ä¹‹æ—…<br>
                ä½“éªŒä¸åŒçš„æ¸¸æˆä¹è¶£ï¼
            </div>
            
            <div class="mode-options">
                <div class="mode-option ai-mode" onclick="showDifficultySelect()">
                    <span class="mode-icon">ğŸ¤–</span>
                    <div class="mode-name">å•äººæ¸¸æˆ</div>
                    <div class="mode-desc">
                        ä¸æ™ºèƒ½AIå¯¹æˆ˜<br>
                        æŒ‘æˆ˜ä½ çš„æˆ˜æœ¯æŠ€å·§
                    </div>
                    <div class="mode-features">
                        AIè‡ªåŠ¨æ“ä½œ â€¢ ç­–ç•¥æŒ‘æˆ˜ â€¢ æŠ€èƒ½æå‡
                    </div>
                </div>
                
                <div class="mode-option" onclick="startGameMode('multiplayer')">
                    <span class="mode-icon">ğŸ‘¥</span>
                    <div class="mode-name">åŒäººå¯¹æˆ˜</div>
                    <div class="mode-desc">
                        ä¸æœ‹å‹é¢å¯¹é¢å¯¹æˆ˜<br>
                        äº«å—ç«æŠ€çš„ä¹è¶£
                    </div>
                    <div class="mode-features">
                        æœ¬åœ°å¯¹æˆ˜ â€¢ å³æ—¶ç«æŠ€ â€¢ å‹è°Šæ¯”æ‹¼
                    </div>
                </div>
            </div>
            
            <div style="color: #888; font-size: 14px; margin-top: 20px;">
                ğŸ’¡ æç¤ºï¼šä¸¤ç§æ¨¡å¼éƒ½æ”¯æŒé£è¡Œã€å¤šç§æ­¦å™¨å’Œåœ°å½¢ç ´å
            </div>
        </div>

        <!-- AIéš¾åº¦é€‰æ‹©ç•Œé¢ -->
        <div class="game-mode-screen" id="difficultyScreen" style="display: none;">
            <div class="mode-title">é€‰æ‹©AIéš¾åº¦</div>
            <div class="mode-subtitle">
                é€‰æ‹©é€‚åˆä½ çš„æŒ‘æˆ˜ç­‰çº§<br>
                ä¸åŒéš¾åº¦çš„AIæœ‰ä¸åŒçš„æˆ˜æ–—ç­–ç•¥
            </div>
            
            <div class="mode-options">
                <div class="mode-option difficulty-easy" onclick="startGameMode('single', 'easy')">
                    <span class="mode-icon">ğŸ˜Š</span>
                    <div class="mode-name">åˆçº§AI</div>
                    <div class="mode-desc">
                        é€‚åˆæ–°æ‰‹ç©å®¶<br>
                        AIååº”è¾ƒæ…¢ï¼Œç­–ç•¥ç®€å•
                    </div>
                    <div class="mode-features">
                        ç„å‡†è¯¯å·®å¤§ â€¢ æ€è€ƒæ—¶é—´é•¿ â€¢ ç­–ç•¥ä¿å®ˆ
                    </div>
                </div>
                
                <div class="mode-option difficulty-medium" onclick="startGameMode('single', 'medium')">
                    <span class="mode-icon">ğŸ¤”</span>
                    <div class="mode-name">ä¸­çº§AI</div>
                    <div class="mode-desc">
                        å¹³è¡¡çš„æŒ‘æˆ˜ä½“éªŒ<br>
                        AIæœ‰ä¸€å®šæˆ˜æœ¯æ„è¯†
                    </div>
                    <div class="mode-features">
                        ç„å‡†é€‚ä¸­ â€¢ ç­–ç•¥å¹³è¡¡ â€¢ ä¼šä½¿ç”¨ç‰¹æ®Šæ­¦å™¨
                    </div>
                </div>
                
                <div class="mode-option difficulty-hard" onclick="startGameMode('single', 'hard')">
                    <span class="mode-icon">ğŸ˜¤</span>
                    <div class="mode-name">é«˜çº§AI</div>
                    <div class="mode-desc">
                        ä¸“å®¶çº§æŒ‘æˆ˜<br>
                        AIååº”æ•æ·ï¼Œç­–ç•¥é«˜æ·±
                    </div>
                    <div class="mode-features">
                        ç„å‡†ç²¾å‡† â€¢ æ€è€ƒå¿«é€Ÿ â€¢ ç­–ç•¥æ¿€è¿›
                    </div>
                </div>
            </div>
            
            <div style="color: #888; font-size: 14px; margin-top: 20px;">
                <button onclick="backToModeSelect()" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">è¿”å›æ¨¡å¼é€‰æ‹©</button>
            </div>
        </div>

        <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
        <div class="game-over" id="gameOver">
            <div class="winner-text" id="winnerText">ç©å®¶1è·èƒœ!</div>
            <p>æ­å–œè·å¾—èƒœåˆ©!</p>
            <button class="restart-btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
            <button class="restart-btn" onclick="backToModeSelect()" style="margin-left: 15px; background: linear-gradient(45deg, #FF6B6B, #FF8A8A);">è¿”å›æ¨¡å¼é€‰æ‹©</button>
        </div>
    </div>

    <!-- æ§åˆ¶è¯´æ˜ -->
    <div class="controls">
        <div class="controls-grid">
            <div>
                <strong style="color: #4CAF50;">ç©å®¶1 (ç»¿è‰²):</strong><br>
                â€¢ ADé”®ç§»åŠ¨ï¼ŒWSé”®è°ƒè§’åº¦(0-180Â°)<br>
                â€¢ ç©ºæ ¼é”®è“„åŠ›å‘å°„/é£è¡Œ<br>
                â€¢ Qé”®é€‰æ‹©æ­¦å™¨ï¼ŒGé”®åˆ‡æ¢é£è¡Œæ¨¡å¼
            </div>
            <div>
                <strong style="color: #FF6B6B;">ç©å®¶2 (çº¢è‰²):</strong><br>
                â€¢ æ–¹å‘é”®ç§»åŠ¨ï¼Œä¸Šä¸‹é”®è°ƒè§’åº¦(0-180Â°)<br>
                â€¢ ç©ºæ ¼é”®è“„åŠ›å‘å°„/é£è¡Œ<br>
                â€¢ Qé”®é€‰æ‹©æ­¦å™¨ï¼Œ1é”®åˆ‡æ¢é£è¡Œæ¨¡å¼
            </div>
        </div>
        <div class="controls-tip">
            <strong>æ¸¸æˆæç¤º:</strong> é£è¡Œç€é™†åä¼šè‡ªåŠ¨åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼ï¼Œå¯é‡æ–°åˆ‡æ¢é£è¡Œæ¨¡å¼ | æ¯å›åˆé™æ—¶20ç§’ | å‡»ä¸­å¯¹æ‰‹æˆ–æ‰å…¥æ·±å‘/ç•Œå¤–å³å¯è·èƒœ
        </div>
    </div>

    <script>
        class TNTBattleGame {
            constructor() {
                console.log('TNTBattleGameæ„é€ å‡½æ•°å¼€å§‹æ‰§è¡Œ');
                this.canvas = document.getElementById('gameCanvas');
                console.log('Canvaså…ƒç´ :', this.canvas);
                if (!this.canvas) {
                    throw new Error('æ‰¾ä¸åˆ°gameCanvaså…ƒç´ ');
                }
                this.ctx = this.canvas.getContext('2d');
                console.log('Canvasä¸Šä¸‹æ–‡:', this.ctx);
                
                // æ¸¸æˆçŠ¶æ€
                this.currentPlayer = 1;
                this.gameState = 'modeSelect'; // modeSelect, playing, gameOver
                this.gameMode = null; // 'single' or 'multiplayer'
                this.aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
                this.isCharging = false;
                this.chargePower = 0;
                this.maxPower = 100;
                this.turnTimeLeft = 20;
                this.turnTimer = null;
                this.isTurnActive = true;
                
                // ç©å®¶æ•°æ®
                this.players = {
                    1: {
                        x: 100,
                        y: 500,
                        hp: 100,
                        maxHP: 100,
                        color: '#4CAF50',
                        selectedWeapon: 0,
                        angle: 45,
                        isFlying: false,
                        flyMode: false,
                        flyPower: 0,
                        flyVelocityX: 0,
                        flyVelocityY: 0,
                        onGround: true,
                        hasFlownThisTurn: false,
                        isChargingFly: false,
                        standingOnObstacle: false,
                        currentSupportingObstacle: null
                    },
                    2: {
                        x: 900,
                        y: 500,
                        hp: 100,
                        maxHP: 100,
                        color: '#FF6B6B',
                        selectedWeapon: 0,
                        angle: 135,
                        isFlying: false,
                        flyMode: false,
                        flyPower: 0,
                        flyVelocityX: 0,
                        flyVelocityY: 0,
                        onGround: true,
                        hasFlownThisTurn: false,
                        isChargingFly: false,
                        standingOnObstacle: false,
                        currentSupportingObstacle: null
                    }
                };
                
                // æ­¦å™¨ç±»å‹
                this.weapons = [
                    {
                        name: 'æ™®é€šç‚¸å¼¹',
                        icon: 'ğŸ’£',
                        damage: 25,
                        radius: 40,
                        color: '#FF6B35',
                        speed: 0.7, // é™ä½30%
                        description: 'åŸºç¡€ç‚¸å¼¹',
                        type: 'normal'
                    },
                    {
                        name: 'è¶…çº§ç‚¸å¼¹',
                        icon: 'ğŸ’¥',
                        damage: 40,
                        radius: 60,
                        color: '#FF0000',
                        speed: 0.56, // é™ä½30%
                        description: 'é«˜ä¼¤å®³å¤§èŒƒå›´',
                        type: 'normal'
                    },
                    {
                        name: 'ç©¿ç”²å¼¹',
                        icon: 'ğŸš€',
                        damage: 35,
                        radius: 25,
                        color: '#4169E1',
                        speed: 1.05, // é™ä½30%
                        description: 'é«˜é€Ÿä½èŒƒå›´',
                        type: 'normal'
                    },
                    {
                        name: 'é›†æŸç‚¸å¼¹',
                        icon: 'ğŸ†',
                        damage: 18,
                        radius: 28,
                        color: '#FFD700',
                        speed: 0.7, // é™ä½30%
                        description: 'åˆ†è£‚4æ¬¡å°å¼¹',
                        type: 'cluster',
                        splitCount: 4
                    },
                    {
                        name: 'è¿å°„ç‚¸å¼¹',
                        icon: 'ğŸ”«',
                        damage: 15,
                        radius: 25,
                        color: '#FF4500',
                        speed: 0.84, // é™ä½30%
                        description: 'è¿å°„6å‘å­å¼¹',
                        type: 'rapid',
                        bulletCount: 6
                    },
                    {
                        name: 'ç‡ƒçƒ§å¼¹',
                        icon: 'ğŸ”¥',
                        damage: 20,
                        radius: 35,
                        color: '#FF6347',
                        speed: 0.7, // é™ä½30%
                        description: 'æŒç»­ç‡ƒçƒ§ä¼¤å®³',
                        type: 'fire',
                        burnDuration: 5,
                        burnDamage: 5
                    },
                    {
                        name: 'æ•£å°„å¼¹',
                        icon: 'ğŸŒŸ',
                        damage: 18,
                        radius: 30,
                        color: '#9370DB',
                        speed: 0.7, // é™ä½30%
                        description: 'æ•£å°„3å‘Ã—3æ¬¡',
                        type: 'scatter',
                        scatterCount: 3,
                        burstCount: 3
                    },
                    {
                        name: 'æ ¸å¼¹',
                        icon: 'â˜¢ï¸',
                        damage: 60,
                        radius: 80,
                        color: '#FF1493',
                        speed: 0.42, // é™ä½30%
                        description: 'è¶…å¼ºå¨åŠ›',
                        type: 'normal'
                    }
                ];
                
                // å¼¹é“ç›¸å…³
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = []; // ç‡ƒçƒ§åŒºåŸŸ
                this.burnEffects = []; // ç‡ƒçƒ§æ•ˆæœ
                this.craters = []; // å¼¹å‘æ•°æ®
                this.obstacles = []; // ç©ºä¸­éšœç¢ç‰©
                
                // é”®ç›˜çŠ¶æ€
                this.keys = {};
                
                try {
                    console.log('å¼€å§‹ç»‘å®šäº‹ä»¶...');
                    this.bindEvents();
                    console.log('äº‹ä»¶ç»‘å®šå®Œæˆ');
                } catch (error) {
                    console.error('ç»‘å®šäº‹ä»¶æ—¶å‡ºé”™:', error);
                    throw error;
                }
                
                try {
                    console.log('åˆ›å»ºæ­¦å™¨é€‰æ‹©å™¨...');
                    this.createWeaponSelector();
                    console.log('æ­¦å™¨é€‰æ‹©å™¨åˆ›å»ºå®Œæˆ');
                } catch (error) {
                    console.error('åˆ›å»ºæ­¦å™¨é€‰æ‹©å™¨æ—¶å‡ºé”™:', error);
                    throw error;
                }
                
                try {
                    console.log('æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©å™¨...');
                    this.showModeSelector();
                    console.log('æ¨¡å¼é€‰æ‹©å™¨æ˜¾ç¤ºå®Œæˆ');
                } catch (error) {
                    console.error('æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©å™¨æ—¶å‡ºé”™:', error);
                    throw error;
                }
                
                // å°†æ¸¸æˆå¾ªç¯ç§»åˆ°æœ€åå¯åŠ¨
                console.log('å‡†å¤‡å¯åŠ¨æ¸¸æˆå¾ªç¯...');
                
                console.log('TNTBattleGameæ„é€ å‡½æ•°æ‰§è¡Œå®Œæˆ');
                
                // åœ¨æ„é€ å‡½æ•°å®Œæˆåå¯åŠ¨æ¸¸æˆå¾ªç¯
                setTimeout(() => {
                    try {
                        console.log('å¯åŠ¨æ¸¸æˆå¾ªç¯...');
                        this.gameLoop();
                        console.log('æ¸¸æˆå¾ªç¯å¯åŠ¨å®Œæˆ');
                    } catch (error) {
                        console.error('å¯åŠ¨æ¸¸æˆå¾ªç¯æ—¶å‡ºé”™:', error);
                    }
                }, 100);
            }
            
            showModeSelector() {
                document.getElementById('gameModeScreen').style.display = 'flex';
                document.getElementById('gameOver').style.display = 'none';
            }
            
            startGame(mode, difficulty = 'medium') {
                console.log('startGameå‡½æ•°è¢«è°ƒç”¨ï¼Œæ¨¡å¼:', mode, 'éš¾åº¦:', difficulty);
                this.gameMode = mode;
                this.aiDifficulty = difficulty;
                this.gameState = 'playing';
                console.log('éšè—æ¨¡å¼é€‰æ‹©ç•Œé¢');
                document.getElementById('gameModeScreen').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                
                // æ ¹æ®æ¸¸æˆæ¨¡å¼æ›´æ–°ç©å®¶åç§°æ˜¾ç¤º
                if (mode === 'single') {
                    document.getElementById('player1Name').textContent = 'ä½  (WASD)';
                    const difficultyNames = {
                        'easy': 'åˆçº§AI',
                        'medium': 'ä¸­çº§AI', 
                        'hard': 'é«˜çº§AI'
                    };
                    document.getElementById('player2Name').textContent = `${difficultyNames[difficulty]} (è‡ªåŠ¨)`;
                } else {
                    document.getElementById('player1Name').textContent = 'ç©å®¶1 (WASD)';
                    document.getElementById('player2Name').textContent = 'ç©å®¶2 (æ–¹å‘é”®)';
                }
                
                this.initializeGame();
            }
            
            getAIConfig() {
                // æ ¹æ®éš¾åº¦è¿”å›AIé…ç½®
                const configs = {
                    'easy': {
                        thinkTime: [2000, 4000], // æ€è€ƒæ—¶é—´2-4ç§’
                        aimError: 40, // ç„å‡†è¯¯å·®Â±40åº¦
                        powerVariation: 0.4, // åŠ›é‡å˜åŒ–Â±40%
                        aimTime: [1000, 2000], // ç„å‡†æ—¶é—´1-2ç§’
                        strategyWeights: {
                            attack: 0.6,
                            move: 0.3,
                            fly: 0.1
                        },
                        weaponPreference: [0, 1], // åå¥½ç®€å•æ­¦å™¨
                        weaponChangeChance: 0.1, // 10%æ¦‚ç‡æ¢æ­¦å™¨
                        flightAccuracy: 0.5, // é£è¡Œç²¾åº¦50%
                        craterAvoidance: 0.3 // å¼¹å‘å›é¿èƒ½åŠ›30%
                    },
                    'medium': {
                        thinkTime: [1000, 2500], // æ€è€ƒæ—¶é—´1-2.5ç§’
                        aimError: 20, // ç„å‡†è¯¯å·®Â±20åº¦
                        powerVariation: 0.2, // åŠ›é‡å˜åŒ–Â±20%
                        aimTime: [500, 1000], // ç„å‡†æ—¶é—´0.5-1ç§’
                        strategyWeights: {
                            attack: 0.7,
                            move: 0.2,
                            fly: 0.1
                        },
                        weaponPreference: [0, 1, 3, 4], // åå¥½å¸¸ç”¨æ­¦å™¨
                        weaponChangeChance: 0.3, // 30%æ¦‚ç‡æ¢æ­¦å™¨
                        flightAccuracy: 0.7, // é£è¡Œç²¾åº¦70%
                        craterAvoidance: 0.6 // å¼¹å‘å›é¿èƒ½åŠ›60%
                    },
                    'hard': {
                        thinkTime: [300, 800], // æ€è€ƒæ—¶é—´0.3-0.8ç§’ (æ›´å¿«)
                        aimError: 5, // ç„å‡†è¯¯å·®Â±5åº¦ (æ›´ç²¾å‡†)
                        powerVariation: 0.05, // åŠ›é‡å˜åŒ–Â±5% (æ›´ç²¾ç¡®)
                        aimTime: [100, 300], // ç„å‡†æ—¶é—´0.1-0.3ç§’ (æ›´å¿«)
                        strategyWeights: {
                            attack: 0.5,
                            move: 0.25,
                            fly: 0.25
                        },
                        weaponPreference: [0, 1, 2, 3, 4, 5, 6, 7], // ä½¿ç”¨æ‰€æœ‰æ­¦å™¨
                        weaponChangeChance: 0.8, // 80%æ¦‚ç‡æ¢æ­¦å™¨ (æ›´é¢‘ç¹)
                        flightAccuracy: 0.95, // é£è¡Œç²¾åº¦95% (æ›´é«˜)
                        craterAvoidance: 0.95, // å¼¹å‘å›é¿èƒ½åŠ›95% (æ›´é«˜)
                        // æ–°å¢é«˜çº§AIç‰¹æ€§
                        predictiveAiming: true, // é¢„æµ‹æ€§ç„å‡†
                        terrainAnalysis: true, // åœ°å½¢åˆ†æèƒ½åŠ›
                        weaponOptimization: true, // æ­¦å™¨ä¼˜åŒ–é€‰æ‹©
                        aggressiveStrategy: true, // æ¿€è¿›ç­–ç•¥
                        counterAttack: true, // åå‡»èƒ½åŠ›
                        positionOptimization: true // ä½ç½®ä¼˜åŒ–
                    }
                };
                
                return configs[this.aiDifficulty] || configs['medium'];
            }
            
            backToModeSelect() {
                this.gameState = 'modeSelect';
                this.gameMode = null;
                this.aiDifficulty = 'medium';
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                document.getElementById('gameModeScreen').style.display = 'flex';
                
                // æ¸…ç†æ¸¸æˆçŠ¶æ€
                this.cleanup();
            }
            
            initializeGame() {
                console.log('initializeGameå¼€å§‹æ‰§è¡Œ');
                console.log('å½“å‰æ¸¸æˆçŠ¶æ€:', this.gameState);
                console.log('å½“å‰æ¸¸æˆæ¨¡å¼:', this.gameMode);
                
                this.updateUI();
                console.log('UIæ›´æ–°å®Œæˆ');
                
                this.generateTerrain();
                console.log('åœ°å½¢ç”Ÿæˆå®Œæˆï¼Œåœ°å½¢ç‚¹æ•°é‡:', this.terrain?.length);
                
                this.startTurn();
                console.log('å›åˆå¼€å§‹ï¼ŒinitializeGameæ‰§è¡Œå®Œæˆ');
            }
            
            generateTerrain() {
                // ç”Ÿæˆéšæœºåœ°å½¢ï¼Œæ¯å±€éƒ½ä¸åŒ
                this.terrain = [];
                
                // éšæœºé€‰æ‹©åœ°å½¢ç±»å‹
                const terrainTypes = [
                    'hills',      // ä¸˜é™µåœ°å½¢
                    'mountains',  // å±±åœ°åœ°å½¢  
                    'valleys',    // å³¡è°·åœ°å½¢
                    'plateau',    // é«˜åŸåœ°å½¢
                    'waves'       // æ³¢æµªåœ°å½¢
                ];
                
                const terrainType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                console.log(`ç”Ÿæˆåœ°å½¢ç±»å‹: ${terrainType}`);
                
                // éšæœºåœ°å½¢å‚æ•°
                const seed = Math.random() * 1000; // éšæœºç§å­
                const frequency = 0.005 + Math.random() * 0.015; // 0.005 - 0.02
                const amplitude = 30 + Math.random() * 40; // 30 - 70
                const baseHeight = 420 + Math.random() * 60; // 420 - 480
                
                for (let x = 0; x < this.canvas.width; x += 10) {
                    let height;
                    
                    switch(terrainType) {
                        case 'hills':
                            // æŸ”å’Œçš„ä¸˜é™µ
                            height = baseHeight + 
                                    Math.sin((x + seed) * frequency) * amplitude +
                                    Math.sin((x + seed) * frequency * 2.3) * (amplitude * 0.3) +
                                    Math.sin((x + seed) * frequency * 0.7) * (amplitude * 0.5);
                            break;
                            
                        case 'mountains':
                            // å°–é”çš„å±±å³°
                            height = baseHeight + 
                                    Math.abs(Math.sin((x + seed) * frequency * 1.5)) * amplitude * 1.2 +
                                    Math.cos((x + seed) * frequency * 0.8) * amplitude * 0.6;
                            break;
                            
                        case 'valleys':
                            // æ·±è°·åœ°å½¢
                            height = baseHeight - 
                                    Math.abs(Math.sin((x + seed) * frequency * 0.8)) * amplitude * 0.8 +
                                    Math.sin((x + seed) * frequency * 3) * amplitude * 0.3;
                            break;
                            
                        case 'plateau':
                            // é«˜åŸå°åœ°
                            const plateauBase = Math.sin((x + seed) * frequency * 0.5) * amplitude * 0.8;
                            const plateauNoise = Math.sin((x + seed) * frequency * 8) * 5;
                            height = baseHeight + plateauBase + plateauNoise;
                            break;
                            
                        case 'waves':
                            // æ³¢æµªèµ·ä¼
                            height = baseHeight + 
                                    Math.sin((x + seed) * frequency * 2) * amplitude * 0.7 +
                                    Math.sin((x + seed) * frequency * 5) * amplitude * 0.2 +
                                    Math.cos((x + seed) * frequency * 1.2) * amplitude * 0.4;
                            break;
                            
                        default:
                            height = baseHeight + Math.sin((x + seed) * frequency) * amplitude;
                    }
                    
                    // æ·»åŠ éšæœºå™ªå£°
                    const noise = (Math.random() - 0.5) * 12;
                    height += noise;
                    
                    // ç¡®ä¿é«˜åº¦åœ¨åˆç†èŒƒå›´å†…
                    height = Math.max(350, Math.min(530, height));
                    
                    this.terrain.push({
                        x: x,
                        height: height,
                        originalHeight: height
                    });
                }
                
                // å¹³æ»‘åœ°å½¢ï¼Œé¿å…è¿‡äºå°–é”çš„å˜åŒ–
                this.smoothTerrain();
                
                // è°ƒæ•´ç©å®¶ä½ç½®åˆ°åœ°å½¢ä¸Š
                this.players[1].y = this.getTerrainHeight(this.players[1].x) - 20;
                this.players[2].y = this.getTerrainHeight(this.players[2].x) - 20;
                
                console.log('ç©å®¶1ä½ç½®:', this.players[1].x, this.players[1].y);
                console.log('ç©å®¶2ä½ç½®:', this.players[2].x, this.players[2].y);
                
                // ç”Ÿæˆç©ºä¸­éšœç¢ç‰©
                this.generateObstacles();
                
                // ç”ŸæˆéšæœºèƒŒæ™¯
                this.generateRandomBackground();
            }
            
            smoothTerrain() {
                // å¹³æ»‘åœ°å½¢ï¼Œå‡å°‘è¿‡äºå°–é”çš„å˜åŒ–
                for (let i = 1; i < this.terrain.length - 1; i++) {
                    const prev = this.terrain[i - 1].height;
                    const current = this.terrain[i].height;
                    const next = this.terrain[i + 1].height;
                    
                    // ä½¿ç”¨åŠ æƒå¹³å‡è¿›è¡Œå¹³æ»‘
                    const smoothed = (prev * 0.25 + current * 0.5 + next * 0.25);
                    this.terrain[i].height = smoothed;
                    this.terrain[i].originalHeight = smoothed;
                }
            }
            
            generateRandomBackground() {
                // ç”ŸæˆéšæœºèƒŒæ™¯ä¸»é¢˜
                const backgroundThemes = [
                    {
                        name: 'classic',
                        sky: ['#87CEEB', '#98FB98'], // ç»å…¸è“å¤©ç»¿åœ°
                        ground: '#8B4513'
                    },
                    {
                        name: 'sunset',
                        sky: ['#FF6B35', '#F7931E', '#FFD700'], // æ—¥è½
                        ground: '#8B4513'
                    },
                    {
                        name: 'dawn',
                        sky: ['#FF69B4', '#FF1493', '#87CEEB'], // é»æ˜
                        ground: '#654321'
                    },
                    {
                        name: 'night',
                        sky: ['#191970', '#483D8B', '#2F4F4F'], // å¤œæ™š
                        ground: '#2F2F2F'
                    },
                    {
                        name: 'desert',
                        sky: ['#FFD700', '#FFA500', '#FF8C00'], // æ²™æ¼ 
                        ground: '#DEB887'
                    },
                    {
                        name: 'arctic',
                        sky: ['#B0E0E6', '#87CEEB', '#E0FFFF'], // åŒ—æ
                        ground: '#F0F8FF'
                    },
                    {
                        name: 'alien',
                        sky: ['#9370DB', '#8A2BE2', '#4B0082'], // å¤–æ˜Ÿ
                        ground: '#800080'
                    },
                    {
                        name: 'forest',
                        sky: ['#228B22', '#32CD32', '#90EE90'], // æ£®æ—
                        ground: '#556B2F'
                    }
                ];
                
                this.currentTheme = backgroundThemes[Math.floor(Math.random() * backgroundThemes.length)];
                console.log(`ç”ŸæˆèƒŒæ™¯ä¸»é¢˜: ${this.currentTheme.name}`);
                
                // åº”ç”¨èƒŒæ™¯åˆ°æ¸¸æˆå®¹å™¨
                this.applyBackgroundTheme();
            }
            
            applyBackgroundTheme() {
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer && this.currentTheme) {
                    const skyColors = this.currentTheme.sky;
                    let gradient;
                    
                    if (skyColors.length === 2) {
                        gradient = `linear-gradient(to bottom, ${skyColors[0]} 0%, ${skyColors[1]} 60%, ${this.currentTheme.ground} 60%, ${this.currentTheme.ground} 100%)`;
                    } else if (skyColors.length === 3) {
                        gradient = `linear-gradient(to bottom, ${skyColors[0]} 0%, ${skyColors[1]} 30%, ${skyColors[2]} 60%, ${this.currentTheme.ground} 60%, ${this.currentTheme.ground} 100%)`;
                    }
                    
                    gameContainer.style.background = gradient;
                }
            }
            
            getTerrainHeight(x) {
                const index = Math.floor(x / 10);
                if (index >= 0 && index < this.terrain.length) {
                    return this.terrain[index].height;
                }
                return 500;
            }
            
            generateObstacles() {
                // ç”Ÿæˆéšæœºç©ºä¸­éšœç¢ç‰©
                this.obstacles = [];
                
                // æ ¹æ®åœ°å½¢ç±»å‹è°ƒæ•´éšœç¢ç‰©æ•°é‡å’Œç±»å‹
                const baseCount = 4 + Math.floor(Math.random() * 5); // 4-8ä¸ªéšœç¢ç‰©
                let obstacleTypes = ['platform', 'cloud'];
                
                // æ ¹æ®ä¸»é¢˜æ·»åŠ ç‰¹æ®Šéšœç¢ç‰©ç±»å‹
                if (this.currentTheme) {
                    switch(this.currentTheme.name) {
                        case 'arctic':
                            obstacleTypes.push('iceberg');
                            break;
                        case 'desert':
                            obstacleTypes.push('rock', 'cactus');
                            break;
                        case 'alien':
                            obstacleTypes.push('crystal', 'floating_rock');
                            break;
                        case 'forest':
                            obstacleTypes.push('tree_platform', 'mushroom');
                            break;
                        case 'night':
                            obstacleTypes.push('moon_rock');
                            break;
                    }
                }
                
                for (let i = 0; i < baseCount; i++) {
                    // éšæœºåˆ†å¸ƒï¼Œæœ‰äº›åŒºåŸŸå¯†é›†ï¼Œæœ‰äº›ç¨€ç–
                    const zoneType = Math.random();
                    let x, y;
                    
                    if (zoneType < 0.3) {
                        // å·¦ä¾§åŒºåŸŸ
                        x = 150 + Math.random() * 300;
                    } else if (zoneType < 0.6) {
                        // ä¸­é—´åŒºåŸŸ
                        x = 350 + Math.random() * 300;
                    } else {
                        // å³ä¾§åŒºåŸŸ
                        x = 550 + Math.random() * 300;
                    }
                    
                    // éšæœºé«˜åº¦åˆ†å¸ƒ
                    const heightZone = Math.random();
                    if (heightZone < 0.4) {
                        y = 150 + Math.random() * 120; // é«˜ç©º
                    } else if (heightZone < 0.8) {
                        y = 250 + Math.random() * 150; // ä¸­ç©º
                    } else {
                        y = 350 + Math.random() * 100; // ä½ç©º
                    }
                    
                    // éšæœºå°ºå¯¸
                    const sizeVariation = Math.random();
                    let width, height;
                    
                    if (sizeVariation < 0.2) {
                        // å°å‹éšœç¢ç‰©
                        width = 60 + Math.random() * 40;
                        height = 20 + Math.random() * 20;
                    } else if (sizeVariation < 0.7) {
                        // ä¸­å‹éšœç¢ç‰©
                        width = 80 + Math.random() * 60;
                        height = 25 + Math.random() * 30;
                    } else {
                        // å¤§å‹éšœç¢ç‰©
                        width = 120 + Math.random() * 80;
                        height = 35 + Math.random() * 40;
                    }
                    
                    // éšæœºé€‰æ‹©éšœç¢ç‰©ç±»å‹
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    
                    // ç¡®ä¿éšœç¢ç‰©ä¸é‡å 
                    let overlap = false;
                    for (let existing of this.obstacles) {
                        if (Math.abs(x - existing.x) < (width + existing.width) / 2 + 60 &&
                            Math.abs(y - existing.y) < (height + existing.height) / 2 + 50) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        this.obstacles.push({
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            type: type,
                            craters: [],
                            isSolid: true,
                            canLandOn: true,
                            isRigidBody: true,
                            mass: width * height * 0.01,
                            friction: 0.8,
                            theme: this.currentTheme ? this.currentTheme.name : 'classic'
                        });
                    }
                }
                
                console.log(`ç”Ÿæˆäº† ${this.obstacles.length} ä¸ªéšœç¢ç‰©`);
            }
            
            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.key.toLowerCase() === 'q') {
                        this.toggleWeaponSelector();
                    }
                    
                    if (e.key.toLowerCase() === 'g' && this.currentPlayer === 1) {
                        this.toggleFlyMode();
                    }
                    
                    if (e.key === '1' && this.currentPlayer === 2) {
                        this.toggleFlyMode();
                    }
                    
                    if (e.key === ' ') {
                        e.preventDefault();
                        const player = this.players[this.currentPlayer];
                        if (player.flyMode) {
                            this.startFlyCharging();
                        } else {
                            this.startCharging();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    
                    if (e.key === ' ') {
                        e.preventDefault();
                        const player = this.players[this.currentPlayer];
                        if (player.flyMode) {
                            this.fly();
                        } else {
                            this.fire();
                        }
                    }
                });
            }
            
            createWeaponSelector() {
                const weaponGrid = document.getElementById('weaponGrid');
                if (!weaponGrid) {
                    console.error('æ‰¾ä¸åˆ°weaponGridå…ƒç´ ');
                    return;
                }
                
                if (!this.weapons) {
                    console.error('weaponsæ•°ç»„æœªåˆå§‹åŒ–');
                    return;
                }
                
                if (!this.players || !this.players[this.currentPlayer]) {
                    console.error('playerså¯¹è±¡æœªæ­£ç¡®åˆå§‹åŒ–');
                    return;
                }
                
                weaponGrid.innerHTML = '';
                
                this.weapons.forEach((weapon, index) => {
                    const weaponItem = document.createElement('div');
                    weaponItem.className = 'weapon-item';
                    if (index === this.players[this.currentPlayer].selectedWeapon) {
                        weaponItem.classList.add('selected');
                    }
                    
                    weaponItem.innerHTML = `
                        <div class="weapon-icon">${weapon.icon}</div>
                        <div class="weapon-name">${weapon.name}</div>
                        <div class="weapon-desc">${weapon.description}</div>
                    `;
                    
                    weaponItem.addEventListener('click', () => {
                        this.selectWeapon(index);
                    });
                    
                    weaponGrid.appendChild(weaponItem);
                });
            }
            
            selectWeapon(index) {
                this.players[this.currentPlayer].selectedWeapon = index;
                this.updateUI();
                this.toggleWeaponSelector();
            }
            
            toggleWeaponSelector() {
                const selector = document.getElementById('weaponSelector');
                if (selector.style.display === 'flex') {
                    selector.style.display = 'none';
                } else {
                    selector.style.display = 'flex';
                    this.createWeaponSelector();
                }
            }
            
            startCharging() {
                if (this.gameState !== 'playing' || this.isCharging || !this.isTurnActive) return;
                
                this.isCharging = true;
                this.chargePower = 0;
                document.getElementById('powerMeter').style.display = 'flex';
                
                this.chargeInterval = setInterval(() => {
                    this.chargePower = Math.min(this.chargePower + 2, this.maxPower);
                    const powerFill = document.getElementById('powerFill');
                    powerFill.style.width = (this.chargePower / this.maxPower * 100) + '%';
                }, 50);
            }
            
            fire() {
                if (!this.isCharging || !this.isTurnActive) return;
                
                this.isCharging = false;
                this.isTurnActive = false; // ç»“æŸå½“å‰å›åˆ
                clearInterval(this.chargeInterval);
                clearInterval(this.turnTimer); // åœæ­¢å€’è®¡æ—¶
                document.getElementById('powerMeter').style.display = 'none';
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.selectedWeapon];
                const power = this.chargePower / this.maxPower;
                
                // æ ¹æ®æ­¦å™¨ç±»å‹å‘å°„ä¸åŒçš„å¼¹è¯
                this.fireWeapon(player, weapon, power);
                this.chargePower = 0;
                
                // ç­‰å¾…å¼¹é“ç»“æŸååˆ‡æ¢å›åˆ
                this.waitForProjectileEnd();
            }
            
            fireWeapon(player, weapon, power) {
                const radians = (player.angle * Math.PI) / 180;
                const speed = 10 + power * 15;
                
                switch(weapon.type) {
                    case 'rapid':
                        this.fireRapidShot(player, weapon, radians, speed);
                        break;
                    case 'scatter':
                        this.fireScatterShot(player, weapon, radians, speed);
                        break;
                    default:
                        this.fireSingleShot(player, weapon, radians, speed);
                        break;
                }
            }
            
            fireSingleShot(player, weapon, radians, speed) {
                const projectile = {
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(radians) * speed * weapon.speed,
                    vy: -Math.sin(radians) * speed * weapon.speed,
                    weapon: weapon,
                    player: this.currentPlayer,
                    trail: []
                };
                this.projectiles.push(projectile);
            }
            
            fireRapidShot(player, weapon, radians, speed) {
                for (let i = 0; i < weapon.bulletCount; i++) {
                    setTimeout(() => {
                        const angleVariation = (Math.random() - 0.5) * 0.2;
                        const speedVariation = 0.8 + Math.random() * 0.4;
                        
                        const projectile = {
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(radians + angleVariation) * speed * weapon.speed * speedVariation,
                            vy: -Math.sin(radians + angleVariation) * speed * weapon.speed * speedVariation,
                            weapon: weapon,
                            player: this.currentPlayer,
                            trail: []
                        };
                        this.projectiles.push(projectile);
                    }, i * 200);
                }
            }
            
            fireScatterShot(player, weapon, radians, speed) {
                for (let burst = 0; burst < weapon.burstCount; burst++) {
                    setTimeout(() => {
                        for (let i = 0; i < weapon.scatterCount; i++) {
                            const angleSpread = (i - Math.floor(weapon.scatterCount / 2)) * 0.3;
                            const projectile = {
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(radians + angleSpread) * speed * weapon.speed,
                                vy: -Math.sin(radians + angleSpread) * speed * weapon.speed,
                                weapon: weapon,
                                player: this.currentPlayer,
                                trail: []
                            };
                            this.projectiles.push(projectile);
                        }
                    }, burst * 300);
                }
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                this.handleInput();
                
                // æ›´æ–°æ‰€æœ‰ç©å®¶çš„ç‰©ç†çŠ¶æ€ï¼ˆä¸ä»…ä»…æ˜¯å½“å‰ç©å®¶ï¼‰
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    this.updatePlayerPhysics(player);
                });
                
                this.updateProjectiles();
                this.updateExplosions();
                this.updateParticles();
                this.updateFireZones();
                this.updateBurnEffects();
                this.checkPlayerBounds(); // æ£€æŸ¥ç©å®¶æ˜¯å¦æ‰å‡ºç•Œé¢
            }
            
            handleInput() {
                if (!this.isTurnActive) return; // åªæœ‰åœ¨æ´»è·ƒå›åˆæ‰èƒ½æ“ä½œ
                
                const player = this.players[this.currentPlayer];
                
                // å•äººæ¨¡å¼ä¸‹ï¼Œç©å®¶2ç”±AIæ§åˆ¶
                if (this.gameMode === 'single' && this.currentPlayer === 2) {
                    this.handleAI();
                    return;
                }
                const moveSpeed = 3;
                const angleSpeed = 2;
                
                // é£è¡Œä¸­ä¸å…è®¸ç§»åŠ¨æ§åˆ¶ï¼Œåªå…è®¸è‡ªç„¶çš„ç‰©ç†è¿åŠ¨
                if (player.isFlying) return;
                
                if (this.currentPlayer === 1) {
                    // WASDæ§åˆ¶
                    if (this.keys['a']) {
                        const newX = Math.max(20, player.x - moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // æ£€æŸ¥åˆšä½“ç¢°æ’
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // æ¢å¤ä½ç½®
                        }
                        // ç§»é™¤å¼ºåˆ¶åœ°å½¢é«˜åº¦æ›´æ–° - è®©ç‰©ç†ç³»ç»Ÿè‡ªç„¶å¤„ç†
                    }
                    if (this.keys['d']) {
                        const newX = Math.min(this.canvas.width - 20, player.x + moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // æ£€æŸ¥åˆšä½“ç¢°æ’
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // æ¢å¤ä½ç½®
                        }
                        // ç§»é™¤å¼ºåˆ¶åœ°å½¢é«˜åº¦æ›´æ–° - è®©ç‰©ç†ç³»ç»Ÿè‡ªç„¶å¤„ç†
                    }
                    if (this.keys['w']) {
                        player.angle = Math.min(180, player.angle + angleSpeed);
                    }
                    if (this.keys['s']) {
                        player.angle = Math.max(0, player.angle - angleSpeed);
                    }
                } else {
                    // æ–¹å‘é”®æ§åˆ¶
                    if (this.keys['arrowleft']) {
                        const newX = Math.max(20, player.x - moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // æ£€æŸ¥åˆšä½“ç¢°æ’
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // æ¢å¤ä½ç½®
                        }
                        // ç§»é™¤å¼ºåˆ¶åœ°å½¢é«˜åº¦æ›´æ–° - è®©ç‰©ç†ç³»ç»Ÿè‡ªç„¶å¤„ç†
                    }
                    if (this.keys['arrowright']) {
                        const newX = Math.min(this.canvas.width - 20, player.x + moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // æ£€æŸ¥åˆšä½“ç¢°æ’
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // æ¢å¤ä½ç½®
                        }
                        // ç§»é™¤å¼ºåˆ¶åœ°å½¢é«˜åº¦æ›´æ–° - è®©ç‰©ç†ç³»ç»Ÿè‡ªç„¶å¤„ç†
                    }
                    if (this.keys['arrowup']) {
                        player.angle = Math.min(180, player.angle + angleSpeed);
                    }
                    if (this.keys['arrowdown']) {
                        player.angle = Math.max(0, player.angle - angleSpeed);
                    }
                }
            }
            
            handleAI() {
                if (!this.isTurnActive || this.currentPlayer !== 2) return;
                
                const aiPlayer = this.players[2];
                const humanPlayer = this.players[1];
                
                // AIå·²ç»åœ¨æ‰§è¡ŒåŠ¨ä½œï¼Œé¿å…é‡å¤
                if (aiPlayer.aiActionInProgress) return;
                aiPlayer.aiActionInProgress = true;
                
                // æ ¹æ®éš¾åº¦è·å–AIé…ç½®
                const config = this.getAIConfig();
                
                // AIå†³ç­–å»¶è¿Ÿï¼Œæ ¹æ®éš¾åº¦è°ƒæ•´æ€è€ƒæ—¶é—´
                const thinkTime = config.thinkTime[0] + Math.random() * (config.thinkTime[1] - config.thinkTime[0]);
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    this.executeAIAction(aiPlayer, humanPlayer);
                }, thinkTime);
            }
            
            executeAIAction(aiPlayer, humanPlayer) {
                // è®¡ç®—åˆ°æ•Œäººçš„è·ç¦»å’Œè§’åº¦
                const dx = humanPlayer.x - aiPlayer.x;
                const dy = humanPlayer.y - aiPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                // AIç­–ç•¥å†³ç­–
                const strategy = this.chooseAIStrategy(aiPlayer, humanPlayer, distance);
                
                switch(strategy) {
                    case 'attack':
                        this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                        break;
                    case 'move':
                        this.aiMove(aiPlayer, humanPlayer);
                        break;
                    case 'fly':
                        this.aiFly(aiPlayer, humanPlayer);
                        break;
                    default:
                        this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                }
            }
            
            chooseAIStrategy(aiPlayer, humanPlayer, distance) {
                const config = this.getAIConfig();
                const weights = config.strategyWeights;
                
                // é«˜çº§AIçš„æ™ºèƒ½åˆ†æ
                if (this.aiDifficulty === 'hard') {
                    return this.chooseAdvancedAIStrategy(aiPlayer, humanPlayer, distance, config);
                }
                
                // æ£€æŸ¥å¼¹å‘å›é¿ï¼ˆæ ¹æ®éš¾åº¦ï¼‰
                const craterInfo = this.analyzePlayerCraterSituation(aiPlayer);
                const inCrater = craterInfo.inCrater;
                
                // å¦‚æœåœ¨å¼¹å‘ä¸­ä¸”AIæœ‰è¶³å¤Ÿçš„å›é¿èƒ½åŠ›ï¼Œä¼˜å…ˆé€ƒè„±
                if (inCrater && Math.random() < config.craterAvoidance) {
                    return !aiPlayer.hasFlownThisTurn && Math.random() < 0.7 ? 'fly' : 'move';
                }
                
                // å¦‚æœè·ç¦»å¾ˆè¿‘ä¸”åœ¨æœ‰åˆ©ä½ç½®ï¼Œå€¾å‘æ”»å‡»
                if (distance < 300 && aiPlayer.y <= humanPlayer.y) {
                    return Math.random() < (weights.attack + 0.2) ? 'attack' : 'move';
                }
                
                // å¦‚æœè¡€é‡è¾ƒä½ï¼Œæ ¹æ®éš¾åº¦è°ƒæ•´ç­–ç•¥
                if (aiPlayer.hp < 50 && !aiPlayer.hasFlownThisTurn) {
                    return Math.random() < weights.fly * 3 ? 'fly' : 'move';
                }
                
                // å¦‚æœåœ¨ä¸åˆ©ä½ç½®ï¼Œè€ƒè™‘ç§»åŠ¨æˆ–é£è¡Œ
                if (aiPlayer.y > humanPlayer.y + 100) {
                    if (!aiPlayer.hasFlownThisTurn && Math.random() < weights.fly * 2) {
                        return 'fly';
                    }
                    return 'move';
                }
                
                // æ ¹æ®æƒé‡éšæœºé€‰æ‹©ç­–ç•¥
                const rand = Math.random();
                if (rand < weights.attack) {
                    return 'attack';
                } else if (rand < weights.attack + weights.move) {
                    return 'move';
                } else {
                    return !aiPlayer.hasFlownThisTurn ? 'fly' : 'attack';
                }
            }
            
            chooseAdvancedAIStrategy(aiPlayer, humanPlayer, distance, config) {
                // é«˜çº§AIçš„æ·±åº¦ç­–ç•¥åˆ†æ
                const situation = this.analyzeGameSituation(aiPlayer, humanPlayer);
                
                // å±é™©è¯„ä¼°
                const dangerLevel = this.assessDanger(aiPlayer, humanPlayer);
                
                // æœºä¼šè¯„ä¼°
                const opportunityLevel = this.assessOpportunity(aiPlayer, humanPlayer);
                
                // åŸºäºåˆ†æç»“æœé€‰æ‹©ç­–ç•¥
                if (dangerLevel > 0.7 && !aiPlayer.hasFlownThisTurn) {
                    // é«˜å±é™©æƒ…å†µï¼Œä¼˜å…ˆé€ƒè„±
                    return Math.random() < 0.8 ? 'fly' : 'move';
                }
                
                if (opportunityLevel > 0.8) {
                    // é«˜æœºä¼šæƒ…å†µï¼Œç«‹å³æ”»å‡»
                    return 'attack';
                }
                
                if (situation.healthAdvantage > 30 && distance < 400) {
                    // è¡€é‡ä¼˜åŠ¿ä¸”è·ç¦»é€‚ä¸­ï¼Œæ¿€è¿›æ”»å‡»
                    return Math.random() < 0.9 ? 'attack' : 'move';
                }
                
                if (situation.positionAdvantage > 0.5 && !aiPlayer.hasFlownThisTurn) {
                    // ä½ç½®åŠ£åŠ¿ï¼Œå¯»æ‰¾æ›´å¥½ä½ç½®
                    return Math.random() < 0.7 ? 'fly' : 'move';
                }
                
                if (situation.terrainAdvantage < -0.3) {
                    // åœ°å½¢åŠ£åŠ¿ï¼Œé‡æ–°å®šä½
                    return !aiPlayer.hasFlownThisTurn && Math.random() < 0.6 ? 'fly' : 'move';
                }
                
                // é»˜è®¤ç­–ç•¥ï¼šå¹³è¡¡çš„é€‰æ‹©
                const rand = Math.random();
                if (rand < 0.6) return 'attack';
                else if (rand < 0.8) return 'move';
                else return !aiPlayer.hasFlownThisTurn ? 'fly' : 'attack';
            }
            
            analyzeGameSituation(aiPlayer, humanPlayer) {
                // åˆ†æå½“å‰æ¸¸æˆå±€åŠ¿
                const healthAdvantage = aiPlayer.hp - humanPlayer.hp;
                
                // ä½ç½®ä¼˜åŠ¿åˆ†æ
                const heightDiff = humanPlayer.y - aiPlayer.y;
                const positionAdvantage = heightDiff / 200; // å½’ä¸€åŒ–åˆ°-1åˆ°1
                
                // åœ°å½¢ä¼˜åŠ¿åˆ†æ
                const aiTerrain = this.getTerrainHeight(aiPlayer.x);
                const humanTerrain = this.getTerrainHeight(humanPlayer.x);
                const aiOriginal = this.getOriginalTerrainHeight(aiPlayer.x);
                const humanOriginal = this.getOriginalTerrainHeight(humanPlayer.x);
                
                const aiCraterDepth = aiTerrain - aiOriginal;
                const humanCraterDepth = humanTerrain - humanOriginal;
                const terrainAdvantage = (humanCraterDepth - aiCraterDepth) / 100;
                
                return {
                    healthAdvantage,
                    positionAdvantage,
                    terrainAdvantage
                };
            }
            
            assessDanger(aiPlayer, humanPlayer) {
                let danger = 0;
                
                // è¡€é‡å±é™©
                if (aiPlayer.hp < 30) danger += 0.5;
                else if (aiPlayer.hp < 50) danger += 0.2;
                
                // ä½ç½®å±é™©ï¼ˆæ¥è¿‘ç•Œé¢åº•éƒ¨ï¼‰
                const distanceToBottom = this.canvas.height - aiPlayer.y;
                
                if (distanceToBottom < 30) danger += 0.8; // éå¸¸æ¥è¿‘åº•éƒ¨ï¼Œæåº¦å±é™©
                else if (distanceToBottom < 80) danger += 0.5; // æ¥è¿‘åº•éƒ¨ï¼Œå±é™©
                else if (distanceToBottom < 150) danger += 0.3; // æ¯”è¾ƒæ¥è¿‘åº•éƒ¨ï¼Œä¸­ç­‰å±é™©
                
                // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœåœ¨æ·±å‘ä¸­ï¼Œå¢åŠ å±é™©å€¼
                const currentHeight = this.getTerrainHeight(aiPlayer.x);
                const originalHeight = this.getOriginalTerrainHeight(aiPlayer.x);
                const craterDepth = currentHeight - originalHeight;
                if (craterDepth > 80) danger += 0.3; // æ·±å‘é¢å¤–å±é™©
                
                // è·ç¦»å±é™©ï¼ˆå¤ªè¿‘å®¹æ˜“è¢«å‡»ä¸­ï¼‰
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                if (distance < 200) danger += 0.3;
                
                // é«˜åº¦åŠ£åŠ¿
                if (aiPlayer.y > humanPlayer.y + 50) danger += 0.2;
                
                return Math.min(danger, 1.0);
            }
            
            assessOpportunity(aiPlayer, humanPlayer) {
                let opportunity = 0;
                
                // è¡€é‡ä¼˜åŠ¿
                if (aiPlayer.hp > humanPlayer.hp + 20) opportunity += 0.3;
                
                // ä½ç½®ä¼˜åŠ¿ï¼ˆé«˜åœ°ï¼‰
                if (aiPlayer.y < humanPlayer.y - 30) opportunity += 0.4;
                
                // æ•Œäººåœ¨å¼¹å‘ä¸­æˆ–æ¥è¿‘åº•éƒ¨
                const humanDistanceToBottom = this.canvas.height - humanPlayer.y;
                
                if (humanDistanceToBottom < 80) opportunity += 0.6; // æ•Œäººæ¥è¿‘åº•éƒ¨ï¼Œå®¹æ˜“å‡»æ€
                
                // æ£€æŸ¥æ•Œäººæ˜¯å¦åœ¨æ·±å‘ä¸­
                const humanCurrentHeight = this.getTerrainHeight(humanPlayer.x);
                const humanOriginalHeight = this.getOriginalTerrainHeight(humanPlayer.x);
                const humanCraterDepth = humanCurrentHeight - humanOriginalHeight;
                if (humanCraterDepth > 80) opportunity += 0.4; // æ•Œäººåœ¨æ·±å‘ä¸­
                
                // è·ç¦»é€‚ä¸­ï¼ˆå®¹æ˜“å‡»ä¸­ï¼‰
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                if (distance > 200 && distance < 500) opportunity += 0.2;
                
                return Math.min(opportunity, 1.0);
            }
            
            aiAttack(aiPlayer, humanPlayer, targetAngle) {
                const config = this.getAIConfig();
                
                // é«˜çº§AIä½¿ç”¨å¢å¼ºæ”»å‡»ç³»ç»Ÿ
                if (this.aiDifficulty === 'hard') {
                    this.advancedAIAttack(aiPlayer, humanPlayer, targetAngle, config);
                    return;
                }
                
                // è°ƒæ•´è§’åº¦åˆ°ç›®æ ‡æ–¹å‘
                let finalAngle = targetAngle;
                if (finalAngle < 0) finalAngle += 360;
                if (finalAngle > 180) finalAngle = 180;
                if (finalAngle < 0) finalAngle = 0;
                
                // æ ¹æ®éš¾åº¦æ·»åŠ ç„å‡†è¯¯å·®
                finalAngle += (Math.random() - 0.5) * config.aimError;
                finalAngle = Math.max(0, Math.min(180, finalAngle));
                
                aiPlayer.angle = finalAngle;
                
                // æ ¹æ®éš¾åº¦é€‰æ‹©æ­¦å™¨
                if (Math.random() < config.weaponChangeChance) {
                    const availableWeapons = config.weaponPreference;
                    aiPlayer.selectedWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                }
                
                // æ ¹æ®éš¾åº¦è°ƒæ•´ç„å‡†æ—¶é—´
                const aimTime = config.aimTime[0] + Math.random() * (config.aimTime[1] - config.aimTime[0]);
                
                // æ¨¡æ‹Ÿè“„åŠ›å°„å‡»
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    // æ ¹æ®éš¾åº¦è°ƒæ•´åŠ›é‡ç²¾åº¦
                    const basePower = 0.7;
                    const powerVariation = config.powerVariation;
                    const power = Math.max(0.3, Math.min(1.0, basePower + (Math.random() - 0.5) * powerVariation));
                    
                    const weapon = this.weapons[aiPlayer.selectedWeapon];
                    
                    this.fireWeapon(aiPlayer, weapon, power);
                    this.isTurnActive = false;
                    this.waitForProjectileEnd();
                    aiPlayer.aiActionInProgress = false;
                }, aimTime);
            }
            
            advancedAIAttack(aiPlayer, humanPlayer, targetAngle, config) {
                // é«˜çº§AIçš„æ™ºèƒ½æ”»å‡»ç³»ç»Ÿ
                
                // 1. æ™ºèƒ½æ­¦å™¨é€‰æ‹©
                const optimalWeapon = this.selectOptimalWeapon(aiPlayer, humanPlayer);
                aiPlayer.selectedWeapon = optimalWeapon;
                
                // 2. é¢„æµ‹æ€§ç„å‡†
                const predictedAngle = this.calculatePredictiveAim(aiPlayer, humanPlayer);
                
                // 3. åœ°å½¢åˆ†æç„å‡†ä¿®æ­£
                const terrainCorrectedAngle = this.applyTerrainCorrection(predictedAngle, aiPlayer, humanPlayer);
                
                // 4. å¾®è°ƒç„å‡†è¯¯å·®ï¼ˆæå°ï¼‰
                const finalAngle = Math.max(0, Math.min(180, 
                    terrainCorrectedAngle + (Math.random() - 0.5) * config.aimError
                ));
                
                aiPlayer.angle = finalAngle;
                
                // 5. åŠ¨æ€åŠ›é‡è®¡ç®—
                const optimalPower = this.calculateOptimalPower(aiPlayer, humanPlayer, finalAngle);
                
                // 6. æçŸ­ç„å‡†æ—¶é—´
                const aimTime = config.aimTime[0] + Math.random() * (config.aimTime[1] - config.aimTime[0]);
                
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    const weapon = this.weapons[aiPlayer.selectedWeapon];
                    
                    this.fireWeapon(aiPlayer, weapon, optimalPower);
                    this.isTurnActive = false;
                    this.waitForProjectileEnd();
                    aiPlayer.aiActionInProgress = false;
                }, aimTime);
            }
            
            selectOptimalWeapon(aiPlayer, humanPlayer) {
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                const heightDiff = Math.abs(aiPlayer.y - humanPlayer.y);
                
                // æ£€æŸ¥æ•Œäººä½ç½®æƒ…å†µ
                const humanDistanceToBottom = this.canvas.height - humanPlayer.y;
                
                // æ£€æŸ¥æ•Œäººæ˜¯å¦åœ¨æ·±å‘ä¸­
                const humanCurrentHeight = this.getTerrainHeight(humanPlayer.x);
                const humanOriginalHeight = this.getOriginalTerrainHeight(humanPlayer.x);
                const humanCraterDepth = humanCurrentHeight - humanOriginalHeight;
                
                // æ ¹æ®æƒ…å†µé€‰æ‹©æœ€ä¼˜æ­¦å™¨
                if (humanDistanceToBottom < 80 && distance < 400) {
                    // æ•Œäººæ¥è¿‘åº•éƒ¨ï¼Œä½¿ç”¨å¤§å¨åŠ›æ­¦å™¨ç¡®ä¿å‡»æ€
                    return Math.random() < 0.9 ? 7 : 1; // æ ¸å¼¹æˆ–è¶…çº§ç‚¸å¼¹
                } else if (humanCraterDepth > 80 && distance < 400) {
                    // æ•Œäººåœ¨æ·±å‘ä¸­ï¼Œä½¿ç”¨å¤§å¨åŠ›æ­¦å™¨
                    return Math.random() < 0.8 ? 7 : 1; // æ ¸å¼¹æˆ–è¶…çº§ç‚¸å¼¹
                } else if (humanCraterDepth > 40 && distance < 350) {
                    // æ•Œäººåœ¨æµ…å‘ä¸­ï¼Œä½¿ç”¨ä¸­ç­‰å¨åŠ›æ­¦å™¨
                    return Math.random() < 0.6 ? 1 : 3; // è¶…çº§ç‚¸å¼¹æˆ–é›†æŸç‚¸å¼¹
                }
                
                if (distance < 250) {
                    // è¿‘è·ç¦»ï¼Œä½¿ç”¨å¿«é€Ÿæ­¦å™¨
                    return Math.random() < 0.6 ? 4 : 2; // è¿å°„ç‚¸å¼¹æˆ–ç©¿ç”²å¼¹
                }
                
                if (distance > 600) {
                    // è¿œè·ç¦»ï¼Œä½¿ç”¨é«˜é€Ÿæ­¦å™¨
                    return 2; // ç©¿ç”²å¼¹
                }
                
                if (heightDiff > 100) {
                    // é«˜åº¦å·®å¤§ï¼Œä½¿ç”¨æ•£å°„æ­¦å™¨
                    return Math.random() < 0.5 ? 6 : 3; // æ•£å°„å¼¹æˆ–é›†æŸç‚¸å¼¹
                }
                
                if (humanPlayer.hp < 40) {
                    // æ•Œäººè¡€é‡ä½ï¼Œä½¿ç”¨ç‡ƒçƒ§å¼¹æŒç»­ä¼¤å®³
                    return 5; // ç‡ƒçƒ§å¼¹
                }
                
                // é»˜è®¤ä½¿ç”¨è¶…çº§ç‚¸å¼¹
                return 1;
            }
            
            calculatePredictiveAim(aiPlayer, humanPlayer) {
                // é¢„æµ‹æ€§ç„å‡†ï¼šè€ƒè™‘ç©å®¶å¯èƒ½çš„ç§»åŠ¨
                const dx = humanPlayer.x - aiPlayer.x;
                const dy = humanPlayer.y - aiPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ä¼°ç®—å¼¹é“é£è¡Œæ—¶é—´
                const estimatedFlightTime = distance / 15; // å‡è®¾å¹³å‡é€Ÿåº¦
                
                // é¢„æµ‹ç©å®¶å¯èƒ½çš„ç§»åŠ¨ï¼ˆå‡è®¾ç©å®¶ä¼šå°è¯•èº²é¿ï¼‰
                const predictedMovement = estimatedFlightTime * 3; // å‡è®¾ç©å®¶ç§»åŠ¨é€Ÿåº¦
                
                // æ ¹æ®ç©å®¶ä½ç½®é¢„æµ‹ç§»åŠ¨æ–¹å‘
                let predictedX = humanPlayer.x;
                if (humanPlayer.x < this.canvas.width / 2) {
                    // ç©å®¶åœ¨å·¦ä¾§ï¼Œå¯èƒ½å‘å³ç§»åŠ¨
                    predictedX += predictedMovement;
                } else {
                    // ç©å®¶åœ¨å³ä¾§ï¼Œå¯èƒ½å‘å·¦ç§»åŠ¨
                    predictedX -= predictedMovement;
                }
                
                // é‡æ–°è®¡ç®—è§’åº¦
                const newDx = predictedX - aiPlayer.x;
                const newDy = humanPlayer.y - aiPlayer.y;
                let predictedAngle = Math.atan2(-newDy, newDx) * 180 / Math.PI;
                
                if (predictedAngle < 0) predictedAngle += 360;
                if (predictedAngle > 180) predictedAngle = 180;
                
                return predictedAngle;
            }
            
            applyTerrainCorrection(angle, aiPlayer, humanPlayer) {
                // åœ°å½¢åˆ†æä¿®æ­£ç„å‡†
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                
                // æ£€æŸ¥å¼¹é“è·¯å¾„ä¸Šçš„åœ°å½¢éšœç¢
                const steps = Math.floor(distance / 50);
                let maxTerrainHeight = 0;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = aiPlayer.x + (humanPlayer.x - aiPlayer.x) * (i / steps);
                    const terrainHeight = this.getTerrainHeight(checkX);
                    maxTerrainHeight = Math.max(maxTerrainHeight, terrainHeight);
                }
                
                // å¦‚æœè·¯å¾„ä¸Šæœ‰é«˜åœ°å½¢ï¼Œå¢åŠ è§’åº¦
                const clearanceNeeded = maxTerrainHeight - Math.min(aiPlayer.y, humanPlayer.y);
                if (clearanceNeeded > 0) {
                    const angleCorrection = Math.min(15, clearanceNeeded / 10);
                    return Math.min(180, angle + angleCorrection);
                }
                
                return angle;
            }
            
            calculateOptimalPower(aiPlayer, humanPlayer, angle) {
                // è®¡ç®—æœ€ä¼˜å‘å°„åŠ›é‡
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                const heightDiff = humanPlayer.y - aiPlayer.y;
                
                // åŸºç¡€åŠ›é‡æ ¹æ®è·ç¦»è®¡ç®—
                let basePower = Math.min(1.0, distance / 800);
                
                // é«˜åº¦ä¿®æ­£
                if (heightDiff > 0) {
                    // å‘ä¸Šå°„å‡»ï¼Œå¢åŠ åŠ›é‡
                    basePower += heightDiff / 1000;
                } else {
                    // å‘ä¸‹å°„å‡»ï¼Œå‡å°‘åŠ›é‡
                    basePower += heightDiff / 1500;
                }
                
                // è§’åº¦ä¿®æ­£
                if (angle > 45 && angle < 135) {
                    // é«˜æŠ›ç‰©çº¿ï¼Œå¢åŠ åŠ›é‡
                    basePower += 0.1;
                }
                
                return Math.max(0.4, Math.min(1.0, basePower));
            }
            
            aiMove(aiPlayer, humanPlayer) {
                // AIç§»åŠ¨ç­–ç•¥ï¼šå¯»æ‰¾æ›´å¥½çš„ä½ç½®
                const targetX = this.findBetterPosition(aiPlayer, humanPlayer);
                const moveDirection = targetX > aiPlayer.x ? 1 : -1;
                const moveDistance = Math.min(50, Math.abs(targetX - aiPlayer.x));
                
                // æ¨¡æ‹Ÿç§»åŠ¨
                const moveSteps = Math.floor(moveDistance / 3);
                let currentStep = 0;
                
                const moveInterval = setInterval(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2 || currentStep >= moveSteps) {
                        clearInterval(moveInterval);
                        // ç§»åŠ¨å®Œæˆåè¿›è¡Œæ”»å‡»
                        setTimeout(() => {
                            if (this.gameState === 'playing' && this.currentPlayer === 2) {
                                const dx = humanPlayer.x - aiPlayer.x;
                                const dy = humanPlayer.y - aiPlayer.y;
                                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                                this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                            } else {
                                aiPlayer.aiActionInProgress = false;
                            }
                        }, 300);
                        return;
                    }
                    
                    const newX = Math.max(20, Math.min(this.canvas.width - 20, aiPlayer.x + moveDirection * 3));
                    const oldX = aiPlayer.x;
                    const oldY = aiPlayer.y;
                    
                    // æ›´æ–°Xåæ ‡
                    aiPlayer.x = newX;
                    
                    // æ£€æŸ¥éšœç¢ç‰©ç¢°æ’
                    if (this.checkObstacleCollision(aiPlayer)) {
                        aiPlayer.x = oldX; // æ¢å¤Xåæ ‡
                        clearInterval(moveInterval);
                        // å¦‚æœæ— æ³•ç§»åŠ¨ï¼Œç›´æ¥æ”»å‡»
                        setTimeout(() => {
                            if (this.gameState === 'playing' && this.currentPlayer === 2) {
                                const dx = humanPlayer.x - aiPlayer.x;
                                const dy = humanPlayer.y - aiPlayer.y;
                                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                                this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                            } else {
                                aiPlayer.aiActionInProgress = false;
                            }
                        }, 300);
                        return;
                    }
                    
                    // åº”ç”¨åœ°å½¢ç‰©ç†ï¼šè®©AIè·Ÿéšåœ°å½¢é«˜åº¦
                    this.updatePlayerPhysics(aiPlayer);
                    
                    // åœ¨AIç§»åŠ¨è¿‡ç¨‹ä¸­ä¹Ÿæ£€æŸ¥æ˜¯å¦æ‰å‡ºç•Œé¢åº•éƒ¨
                    if (aiPlayer.y > this.canvas.height + 20) {
                        console.log(`AIç§»åŠ¨æ—¶æ‰å‡ºç•Œé¢åº•éƒ¨ï¼Œä½ç½®: ${Math.round(aiPlayer.y)}`);
                        // ç«‹å³è§¦å‘ç•Œé¢åº•éƒ¨æ£€æµ‹
                        this.checkPlayerBounds();
                    }
                    
                    currentStep++;
                }, 100);
            }
            
            aiFly(aiPlayer, humanPlayer) {
                if (aiPlayer.hasFlownThisTurn) {
                    this.aiMove(aiPlayer, humanPlayer);
                    return;
                }
                
                // åˆ‡æ¢åˆ°é£è¡Œæ¨¡å¼
                aiPlayer.flyMode = true;
                
                // é€‰æ‹©é£è¡Œç›®æ ‡ä½ç½®
                const targetPos = this.chooseFlyTarget(aiPlayer, humanPlayer);
                const dx = targetPos.x - aiPlayer.x;
                const dy = targetPos.y - aiPlayer.y;
                const flyAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                aiPlayer.angle = Math.max(0, Math.min(180, flyAngle));
                
                // æ¨¡æ‹Ÿé£è¡Œè“„åŠ›
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    // æ ¹æ®éš¾åº¦è°ƒæ•´é£è¡Œç²¾åº¦
                    const config = this.getAIConfig();
                    const basePower = 0.7;
                    const powerRange = 0.3;
                    const accuracy = config.flightAccuracy;
                    const power = basePower + (Math.random() - 0.5) * powerRange * (2 - accuracy);
                    const radians = (aiPlayer.angle * Math.PI) / 180;
                    
                    // æ‰§è¡Œé£è¡Œ
                    aiPlayer.isFlying = true;
                    aiPlayer.hasFlownThisTurn = true;
                    aiPlayer.onGround = false;
                    aiPlayer.standingOnObstacle = false;
                    aiPlayer.currentSupportingObstacle = null;
                    
                    const baseSpeed = 15.4;
                    aiPlayer.flyVelocityX = Math.cos(radians) * power * baseSpeed;
                    aiPlayer.flyVelocityY = -Math.sin(radians) * power * baseSpeed;
                    
                    this.createFlyStartEffect(aiPlayer.x, aiPlayer.y);
                    aiPlayer.aiActionInProgress = false;
                    
                    // é£è¡Œç»“æŸåï¼ŒAIä¼šåœ¨ç€é™†æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼ï¼Œç„¶ååœ¨ä¸‹ä¸ªå›åˆå¯ä»¥è¡ŒåŠ¨
                }, 800 + Math.random() * 700);
            }
            
            findBetterPosition(aiPlayer, humanPlayer) {
                // é«˜çº§AIä½¿ç”¨æ™ºèƒ½ä½ç½®åˆ†æ
                if (this.aiDifficulty === 'hard') {
                    return this.findOptimalPosition(aiPlayer, humanPlayer);
                }
                
                // å¯»æ‰¾æ›´å¥½çš„æ”»å‡»ä½ç½®
                const currentDistance = Math.abs(aiPlayer.x - humanPlayer.x);
                
                // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åœ¨å¼¹å‘ä¸­
                const currentHeight = this.getTerrainHeight(aiPlayer.x);
                const originalHeight = this.getOriginalTerrainHeight ? this.getOriginalTerrainHeight(aiPlayer.x) : currentHeight;
                const inCrater = currentHeight - originalHeight > 30; // å¦‚æœå½“å‰é«˜åº¦æ¯”åŸå§‹é«˜åº¦é«˜30åƒç´ ä»¥ä¸Šï¼Œè¯´æ˜åœ¨å¼¹å‘ä¸­
                
                // å¦‚æœåœ¨å¼¹å‘ä¸­ï¼Œä¼˜å…ˆå¯»æ‰¾å®‰å…¨ä½ç½®
                if (inCrater) {
                    for (let testX = aiPlayer.x - 100; testX <= aiPlayer.x + 100; testX += 20) {
                        if (testX < 50 || testX > this.canvas.width - 50) continue;
                        
                        const testHeight = this.getTerrainHeight(testX);
                        const testOriginalHeight = this.getOriginalTerrainHeight ? this.getOriginalTerrainHeight(testX) : testHeight;
                        const testInCrater = testHeight - testOriginalHeight > 30;
                        
                        if (!testInCrater) {
                            return testX; // æ‰¾åˆ°å®‰å…¨ä½ç½®
                        }
                    }
                }
                
                // å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œå°è¯•æ‹‰å¼€è·ç¦»
                if (currentDistance < 200) {
                    return aiPlayer.x < humanPlayer.x ? 
                        Math.max(50, aiPlayer.x - 100) : 
                        Math.min(this.canvas.width - 50, aiPlayer.x + 100);
                }
                
                // å¦‚æœè·ç¦»å¤ªè¿œï¼Œå°è¯•é è¿‘
                if (currentDistance > 500) {
                    return aiPlayer.x < humanPlayer.x ? 
                        Math.min(humanPlayer.x - 150, aiPlayer.x + 100) :
                        Math.max(humanPlayer.x + 150, aiPlayer.x - 100);
                }
                
                // è·ç¦»é€‚ä¸­ï¼Œå¯»æ‰¾é«˜åº¦ä¼˜åŠ¿
                const terrainHeight = this.getTerrainHeight(aiPlayer.x);
                const humanTerrainHeight = this.getTerrainHeight(humanPlayer.x);
                
                if (terrainHeight > humanTerrainHeight + 50) {
                    // å½“å‰ä½ç½®è¾ƒé«˜ï¼Œä¿æŒä½ç½®æˆ–ç¨å¾®è°ƒæ•´
                    return aiPlayer.x + (Math.random() - 0.5) * 100;
                }
                
                // å¯»æ‰¾æ›´é«˜çš„ä½ç½®
                return humanPlayer.x + (Math.random() - 0.5) * 200;
            }
            
            findOptimalPosition(aiPlayer, humanPlayer) {
                // é«˜çº§AIçš„æ™ºèƒ½ä½ç½®é€‰æ‹©
                const candidates = [];
                
                // åˆ†æå¤šä¸ªå€™é€‰ä½ç½®
                for (let x = 100; x < this.canvas.width - 100; x += 80) {
                    const score = this.evaluatePosition(x, aiPlayer, humanPlayer);
                    candidates.push({ x, score });
                }
                
                // æŒ‰åˆ†æ•°æ’åºï¼Œé€‰æ‹©æœ€ä½³ä½ç½®
                candidates.sort((a, b) => b.score - a.score);
                
                // ä»å‰3ä¸ªæœ€ä½³ä½ç½®ä¸­éšæœºé€‰æ‹©ï¼ˆå¢åŠ ä¸å¯é¢„æµ‹æ€§ï¼‰
                const topCandidates = candidates.slice(0, 3);
                const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                return selected.x;
            }
            
            evaluatePosition(x, aiPlayer, humanPlayer) {
                let score = 0;
                
                // 1. å®‰å…¨æ€§è¯„ä¼°ï¼ˆé¿å…å¼¹å‘ï¼‰
                const terrainHeight = this.getTerrainHeight(x);
                const originalHeight = this.getOriginalTerrainHeight(x);
                const craterDepth = terrainHeight - originalHeight; // ä¿®æ­£ï¼šå½“å‰é«˜åº¦ - åŸå§‹é«˜åº¦ = å¼¹å‘æ·±åº¦
                
                if (craterDepth > 80) score -= 100; // æ·±å‘ä¸¥é‡æ‰£åˆ†
                else if (craterDepth > 40) score -= 50; // æµ…å‘ä¸­ç­‰æ‰£åˆ†
                else if (craterDepth < 10) score += 20; // å¹³åœ°åŠ åˆ†
                
                // 2. é«˜åº¦ä¼˜åŠ¿
                const humanHeight = this.getTerrainHeight(humanPlayer.x);
                const heightAdvantage = humanHeight - terrainHeight;
                score += heightAdvantage * 0.5;
                
                // 3. è·ç¦»ä¼˜åŠ¿ï¼ˆ300-500åƒç´ ä¸ºæœ€ä½³å°„å‡»è·ç¦»ï¼‰
                const distance = Math.abs(x - humanPlayer.x);
                if (distance >= 300 && distance <= 500) {
                    score += 30;
                } else if (distance < 200) {
                    score -= 20; // å¤ªè¿‘å±é™©
                } else if (distance > 600) {
                    score -= 10; // å¤ªè¿œä¸å‡†
                }
                
                // 4. å°„å‡»è§’åº¦ä¼˜åŠ¿
                const dx = humanPlayer.x - x;
                const dy = humanPlayer.y - terrainHeight;
                const angle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                if (angle >= 30 && angle <= 150) {
                    score += 15; // å¥½çš„å°„å‡»è§’åº¦
                }
                
                // 5. åœ°å½¢é®æŒ¡åˆ†æ
                const hasObstacles = this.checkTerrainObstacles(x, humanPlayer.x);
                if (!hasObstacles) {
                    score += 25; // æ— é®æŒ¡åŠ åˆ†
                } else {
                    score -= 15; // æœ‰é®æŒ¡æ‰£åˆ†
                }
                
                // 6. é€ƒç”Ÿè·¯çº¿ï¼ˆå‘¨å›´æ˜¯å¦æœ‰å¥½çš„ç§»åŠ¨ç©ºé—´ï¼‰
                const escapeRoutes = this.countEscapeRoutes(x);
                score += escapeRoutes * 5;
                
                return score;
            }
            
            checkTerrainObstacles(startX, endX) {
                // æ£€æŸ¥ä¸¤ç‚¹ä¹‹é—´æ˜¯å¦æœ‰åœ°å½¢éšœç¢
                const steps = Math.abs(endX - startX) / 20;
                const stepSize = (endX - startX) / steps;
                
                let maxHeight = 0;
                for (let i = 1; i < steps; i++) {
                    const checkX = startX + stepSize * i;
                    const height = this.getTerrainHeight(checkX);
                    maxHeight = Math.max(maxHeight, height);
                }
                
                const startHeight = this.getTerrainHeight(startX);
                const endHeight = this.getTerrainHeight(endX);
                const minHeight = Math.min(startHeight, endHeight);
                
                // å¦‚æœä¸­é—´æœ‰æ¯”èµ·ç‚¹å’Œç»ˆç‚¹éƒ½é«˜çš„åœ°å½¢ï¼Œåˆ™æœ‰éšœç¢
                return maxHeight > minHeight + 50;
            }
            
            countEscapeRoutes(x) {
                // è®¡ç®—é€ƒç”Ÿè·¯çº¿æ•°é‡
                let routes = 0;
                
                // æ£€æŸ¥å·¦å³ä¸¤ä¸ªæ–¹å‘
                for (let direction of [-1, 1]) {
                    let canEscape = true;
                    for (let distance = 50; distance <= 150; distance += 50) {
                        const checkX = x + direction * distance;
                        if (checkX < 50 || checkX > this.canvas.width - 50) {
                            canEscape = false;
                            break;
                        }
                        
                                                    const checkHeight = this.getTerrainHeight(checkX);
                            const checkOriginal = this.getOriginalTerrainHeight(checkX);
                            const checkCrater = checkHeight - checkOriginal;
                        
                        if (checkCrater > 60) {
                            canEscape = false;
                            break;
                        }
                    }
                    
                    if (canEscape) routes++;
                }
                
                return routes;
            }
            
            chooseFlyTarget(aiPlayer, humanPlayer) {
                // é«˜çº§AIä½¿ç”¨æ™ºèƒ½é£è¡Œç›®æ ‡é€‰æ‹©
                if (this.aiDifficulty === 'hard') {
                    return this.chooseOptimalFlyTarget(aiPlayer, humanPlayer);
                }
                
                // é€‰æ‹©é£è¡Œç›®æ ‡ï¼šä¼˜å…ˆé€‰æ‹©é«˜åœ°æˆ–æœ‰åˆ©ä½ç½®
                const obstacles = this.obstacles.filter(obs => obs.canLandOn);
                
                if (obstacles.length > 0 && Math.random() < 0.6) {
                    // 60%æ¦‚ç‡é€‰æ‹©é£åˆ°éšœç¢ç‰©ä¸Š
                    const targetObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                    return { x: targetObstacle.x, y: targetObstacle.y - 50 };
                }
                
                // å¦åˆ™é€‰æ‹©åœ°é¢çš„æœ‰åˆ©ä½ç½®
                const targetX = humanPlayer.x + (Math.random() - 0.5) * 300;
                const clampedX = Math.max(100, Math.min(this.canvas.width - 100, targetX));
                const targetY = this.getTerrainHeight(clampedX) - 50;
                
                return { x: clampedX, y: targetY };
            }
            
            chooseOptimalFlyTarget(aiPlayer, humanPlayer) {
                // é«˜çº§AIçš„æ™ºèƒ½é£è¡Œç›®æ ‡é€‰æ‹©
                const candidates = [];
                
                // 1. è¯„ä¼°éšœç¢ç‰©å¹³å°
                const obstacles = this.obstacles.filter(obs => obs.canLandOn);
                for (let obstacle of obstacles) {
                    const score = this.evaluateFlyTarget(obstacle.x, obstacle.y - 50, aiPlayer, humanPlayer, true);
                    candidates.push({ 
                        x: obstacle.x, 
                        y: obstacle.y - 50, 
                        score, 
                        type: 'obstacle' 
                    });
                }
                
                // 2. è¯„ä¼°åœ°é¢ä½ç½®
                for (let x = 150; x < this.canvas.width - 150; x += 100) {
                    const y = this.getTerrainHeight(x) - 50;
                    const score = this.evaluateFlyTarget(x, y, aiPlayer, humanPlayer, false);
                    candidates.push({ 
                        x, 
                        y, 
                        score, 
                        type: 'ground' 
                    });
                }
                
                // æŒ‰åˆ†æ•°æ’åº
                candidates.sort((a, b) => b.score - a.score);
                
                // é€‰æ‹©æœ€ä½³ç›®æ ‡ï¼ˆå¸¦ä¸€ç‚¹éšæœºæ€§ï¼‰
                const topCandidates = candidates.slice(0, Math.min(3, candidates.length));
                const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                return { x: selected.x, y: selected.y };
            }
            
            evaluateFlyTarget(x, y, aiPlayer, humanPlayer, isObstacle) {
                let score = 0;
                
                // 1. é«˜åº¦ä¼˜åŠ¿ï¼ˆè¶Šé«˜è¶Šå¥½ï¼Œä½†ä¸è¦å¤ªé«˜ï¼‰
                const heightAdvantage = humanPlayer.y - y;
                if (heightAdvantage > 0 && heightAdvantage < 200) {
                    score += heightAdvantage * 0.8;
                } else if (heightAdvantage >= 200) {
                    score += 100; // å¤§é«˜åº¦ä¼˜åŠ¿
                } else {
                    score -= Math.abs(heightAdvantage) * 0.3; // é«˜åº¦åŠ£åŠ¿æ‰£åˆ†
                }
                
                // 2. è·ç¦»ä¼˜åŠ¿ï¼ˆæœ€ä½³å°„å‡»è·ç¦»ï¼‰
                const distance = Math.sqrt((x - humanPlayer.x) ** 2 + (y - humanPlayer.y) ** 2);
                if (distance >= 250 && distance <= 450) {
                    score += 40; // æœ€ä½³å°„å‡»è·ç¦»
                } else if (distance < 200) {
                    score -= 30; // å¤ªè¿‘å±é™©
                } else if (distance > 600) {
                    score -= 20; // å¤ªè¿œéš¾ç„å‡†
                }
                
                // 3. å®‰å…¨æ€§ï¼ˆè¿œç¦»å¼¹å‘ï¼‰
                if (!isObstacle) {
                    const terrainHeight = this.getTerrainHeight(x);
                    const originalHeight = this.getOriginalTerrainHeight(x);
                    const craterDepth = terrainHeight - originalHeight; // ä¿®æ­£ï¼šå½“å‰é«˜åº¦ - åŸå§‹é«˜åº¦ = å¼¹å‘æ·±åº¦
                    
                    if (craterDepth > 60) {
                        score -= 80; // å¼¹å‘ä½ç½®ä¸¥é‡æ‰£åˆ†
                    } else if (craterDepth < 20) {
                        score += 30; // å¹³åœ°åŠ åˆ†
                    }
                }
                
                // 4. å°„å‡»è§’åº¦ä¼˜åŠ¿
                const dx = humanPlayer.x - x;
                const dy = humanPlayer.y - y;
                const angle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                if (angle >= 20 && angle <= 160) {
                    score += 25; // å¥½çš„å°„å‡»è§’åº¦
                }
                
                // 5. éšœç¢ç‰©å¹³å°é¢å¤–ä¼˜åŠ¿
                if (isObstacle) {
                    score += 35; // éšœç¢ç‰©å¹³å°å¤©ç„¶ä¼˜åŠ¿
                    
                    // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦è¢«ç ´å
                    const obstacle = this.obstacles.find(obs => 
                        Math.abs(obs.x - x) < 10 && Math.abs(obs.y - (y + 50)) < 10
                    );
                    if (obstacle && obstacle.craters.length > 0) {
                        score -= obstacle.craters.length * 15; // è¢«ç ´åçš„éšœç¢ç‰©æ‰£åˆ†
                    }
                }
                
                // 6. æˆ˜æœ¯ä½ç½®ï¼ˆä¾§ç¿¼æ”»å‡»ï¼‰
                const playerDirection = humanPlayer.x < this.canvas.width / 2 ? 1 : -1;
                const flankingPosition = (x - humanPlayer.x) * playerDirection > 0;
                if (flankingPosition) {
                    score += 20; // ä¾§ç¿¼ä½ç½®åŠ åˆ†
                }
                
                // 7. é€ƒç”Ÿèƒ½åŠ›
                const escapeScore = this.evaluateEscapeOptions(x, y, isObstacle);
                score += escapeScore;
                
                return score;
            }
            
            evaluateEscapeOptions(x, y, isObstacle) {
                // è¯„ä¼°ä»è¯¥ä½ç½®çš„é€ƒç”Ÿé€‰é¡¹
                let escapeScore = 0;
                
                if (isObstacle) {
                    // éšœç¢ç‰©ä¸Šå¯ä»¥ç»§ç»­é£è¡Œ
                    escapeScore += 30;
                } else {
                    // åœ°é¢ä½ç½®æ£€æŸ¥å‘¨å›´çš„ç§»åŠ¨ç©ºé—´
                    for (let direction of [-1, 1]) {
                        let canMove = true;
                        for (let distance = 50; distance <= 100; distance += 25) {
                            const checkX = x + direction * distance;
                            if (checkX < 50 || checkX > this.canvas.width - 50) {
                                canMove = false;
                                break;
                            }
                            
                                                    const checkHeight = this.getTerrainHeight(checkX);
                        const checkOriginal = this.getOriginalTerrainHeight(checkX);
                        if (checkHeight - checkOriginal > 50) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        if (canMove) escapeScore += 10;
                    }
                }
                
                return escapeScore;
            }
            
            cleanup() {
                // æ¸…ç†æ¸¸æˆçŠ¶æ€
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = [];
                this.burnEffects = [];
                this.craters = [];
                this.obstacles = [];
                
                // æ¸…é™¤å®šæ—¶å™¨
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                if (this.chargeInterval) {
                    clearInterval(this.chargeInterval);
                    this.chargeInterval = null;
                }
                if (this.flyChargeInterval) {
                    clearInterval(this.flyChargeInterval);
                    this.flyChargeInterval = null;
                }
                
                // é‡ç½®ç©å®¶çŠ¶æ€
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    player.hp = player.maxHP;
                    player.x = id == 1 ? 100 : 900;
                    player.y = 500;
                    delete player.burning;
                    delete player.aiActionInProgress;
                    player.isFlying = false;
                    player.flyMode = false;
                    player.flyPower = 0;
                    player.flyVelocityX = 0;
                    player.flyVelocityY = 0;
                    player.onGround = true;
                    player.hasFlownThisTurn = false;
                    player.isChargingFly = false;
                    player.standingOnObstacle = false;
                    player.currentSupportingObstacle = null;
                    player.skipPhysicsThisFrame = false;
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    // æ·»åŠ è½¨è¿¹
                    proj.trail.push({x: proj.x, y: proj.y});
                    if (proj.trail.length > 20) {
                        proj.trail.shift();
                    }
                    
                    // æ›´æ–°ä½ç½®
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.vy += 0.3; // é‡åŠ›
                    
                    // å¢åŠ å¼¹è¯çš„é£è¡Œæ—¶é—´è®¡æ•°å™¨
                    if (!proj.flightTime) proj.flightTime = 0;
                    proj.flightTime++;
                    
                    // æ£€æŸ¥ç‰¹æ®Šæ­¦å™¨çš„ç©ºä¸­çˆ†ç‚¸æ¡ä»¶
                    let shouldExplodeInAir = false;
                    
                    // é›†æŸç‚¸å¼¹åœ¨é£è¡Œä¸€å®šæ—¶é—´åç©ºä¸­çˆ†ç‚¸
                    if (proj.weapon.type === 'cluster' && proj.flightTime > 60) {
                        shouldExplodeInAir = true;
                    }
                    
                    // æ ¸å¼¹åœ¨è¾¾åˆ°æœ€é«˜ç‚¹æ—¶ç©ºä¸­çˆ†ç‚¸ï¼ˆå¢åŠ å¨åŠ›èŒƒå›´ï¼‰
                    if (proj.weapon.name === 'æ ¸å¼¹' && proj.vy > 0 && proj.flightTime > 30) {
                        shouldExplodeInAir = true;
                    }
                    
                    // å¦‚æœéœ€è¦ç©ºä¸­çˆ†ç‚¸
                    if (shouldExplodeInAir) {
                        this.explode(proj.x, proj.y, proj.weapon, proj.player);
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // æ£€æŸ¥åœ°å½¢ç¢°æ’
                    if (proj.y >= this.getTerrainHeight(proj.x) || 
                        proj.x < 0 || proj.x > this.canvas.width || proj.y > this.canvas.height) {
                        this.explode(proj.x, proj.y, proj.weapon, proj.player);
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // æ£€æŸ¥éšœç¢ç‰©ç¢°æ’
                    let hitObstacle = false;
                    for (let j = this.obstacles.length - 1; j >= 0; j--) {
                        const obstacle = this.obstacles[j];
                        if (proj.x >= obstacle.x - obstacle.width/2 && proj.x <= obstacle.x + obstacle.width/2 &&
                            proj.y >= obstacle.y - obstacle.height/2 && proj.y <= obstacle.y + obstacle.height/2) {
                            
                            // åœ¨éšœç¢ç‰©ä¸Šåˆ›å»ºå¼¹å‘ï¼Œè€Œä¸æ˜¯æ‘§æ¯æ•´ä¸ªéšœç¢ç‰©
                            this.createObstacleCrater(obstacle, proj.x, proj.y, proj.weapon);
                            
                            // å¼¹è¯åœ¨éšœç¢ç‰©ä½ç½®çˆ†ç‚¸
                            this.explode(proj.x, proj.y, proj.weapon, proj.player);
                            this.projectiles.splice(i, 1);
                            hitObstacle = true;
                            break;
                        }
                    }
                    
                    if (hitObstacle) continue;
                }
            }
            
            explode(x, y, weapon, playerNum, splitLevel = 0) {
                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: weapon.radius,
                    color: weapon.color,
                    life: 30
                });
                
                // åˆ›å»ºç²’å­æ•ˆæœ
                const particleCount = weapon.type === 'fire' ? 30 : 20;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: weapon.color,
                        life: weapon.type === 'fire' ? 80 : 60,
                        maxLife: weapon.type === 'fire' ? 80 : 60
                    });
                }
                
                // æ£€æŸ¥ä¼¤å®³
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    const distance = Math.sqrt((player.x - x) ** 2 + (player.y - y) ** 2);
                    
                    if (distance <= weapon.radius) {
                        const damage = Math.floor(weapon.damage * (1 - distance / weapon.radius));
                        player.hp = Math.max(0, player.hp - damage);
                        
                        // æ˜¾ç¤ºä¼¤å®³æ•°å­—
                        this.showDamage(player.x, player.y - 30, damage);
                        
                        // è¢«å‡»ä¸­åç«‹å³æ›´æ–°ç‰©ç†çŠ¶æ€ï¼Œç¡®ä¿ç©å®¶ä¼šæ‰å…¥å¼¹å‘
                        player.onGround = false; // å¼ºåˆ¶é‡æ–°æ£€æŸ¥åœ°é¢çŠ¶æ€
                        player.standingOnObstacle = false; // æ¸…é™¤éšœç¢ç‰©ç«™ç«‹çŠ¶æ€
                        player.currentSupportingObstacle = null;
                        
                        // ç‡ƒçƒ§å¼¹ç‰¹æ®Šæ•ˆæœï¼šæ·»åŠ ç‡ƒçƒ§çŠ¶æ€
                        if (weapon.type === 'fire') {
                            player.burning = {
                                duration: weapon.burnDuration * 60, // è½¬æ¢ä¸ºå¸§æ•°
                                damage: weapon.burnDamage,
                                interval: 60 // æ¯ç§’ä¼¤å®³ä¸€æ¬¡
                            };
                        }
                        
                        if (player.hp <= 0) {
                            this.gameOver(id == 1 ? 2 : 1);
                        }
                    }
                });
                
                // ç‰¹æ®Šæ­¦å™¨æ•ˆæœ
                if (weapon.type === 'cluster' && splitLevel < weapon.splitCount) {
                    setTimeout(() => {
                        const subBombs = splitLevel === 0 ? 3 : 2; // ç¬¬ä¸€æ¬¡åˆ†è£‚3ä¸ªï¼Œåç»­åˆ†è£‚2ä¸ª
                        for (let i = 0; i < subBombs; i++) {
                            const angle = (i * (360 / subBombs)) * Math.PI / 180;
                            const distance = 40 + splitLevel * 10;
                            const subX = x + Math.cos(angle) * distance;
                            const subY = y + Math.sin(angle) * distance;
                            this.explode(subX, subY, {
                                ...weapon,
                                damage: weapon.damage * (0.7 - splitLevel * 0.1),
                                radius: weapon.radius * (0.8 - splitLevel * 0.1)
                            }, playerNum, splitLevel + 1);
                        }
                    }, 300);
                }
                
                // ç‡ƒçƒ§å¼¹åˆ›å»ºç«ç„°åŒºåŸŸ
                if (weapon.type === 'fire') {
                    this.fireZones.push({
                        x: x,
                        y: y,
                        radius: weapon.radius * 0.8,
                        damage: weapon.burnDamage,
                        life: weapon.burnDuration * 60,
                        maxLife: weapon.burnDuration * 60
                    });
                }
                
                // åˆ›å»ºå¼¹å‘
                this.createCrater(x, y, weapon);
                
                this.updateUI();
                // ä¸åœ¨è¿™é‡Œåˆ‡æ¢å›åˆï¼Œç”±waitForProjectileEndå¤„ç†
            }
            
            showDamage(x, y, damage) {
                const damageText = document.createElement('div');
                damageText.textContent = `-${damage}`;
                damageText.style.position = 'absolute';
                damageText.style.left = x + 'px';
                damageText.style.top = y + 'px';
                damageText.style.color = '#FF0000';
                damageText.style.fontWeight = 'bold';
                damageText.style.fontSize = '20px';
                damageText.style.pointerEvents = 'none';
                damageText.style.zIndex = '1000';
                damageText.classList.add('explosion');
                
                document.body.appendChild(damageText);
                
                setTimeout(() => {
                    document.body.removeChild(damageText);
                }, 500);
            }
            
            updateExplosions() {
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    const explosion = this.explosions[i];
                    explosion.radius = Math.min(explosion.radius + 2, explosion.maxRadius);
                    explosion.life--;
                    
                    if (explosion.life <= 0) {
                        this.explosions.splice(i, 1);
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updateFireZones() {
                for (let i = this.fireZones.length - 1; i >= 0; i--) {
                    const zone = this.fireZones[i];
                    zone.life--;
                    
                    // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡ç«ç„°ä¼¤å®³
                    if (zone.life % 60 === 0) {
                        Object.keys(this.players).forEach(id => {
                            const player = this.players[id];
                            const distance = Math.sqrt((player.x - zone.x) ** 2 + (player.y - zone.y) ** 2);
                            
                            if (distance <= zone.radius) {
                                const damage = zone.damage;
                                player.hp = Math.max(0, player.hp - damage);
                                this.showDamage(player.x, player.y - 30, damage);
                                
                                if (player.hp <= 0) {
                                    this.gameOver(id == 1 ? 2 : 1);
                                }
                            }
                        });
                    }
                    
                    if (zone.life <= 0) {
                        this.fireZones.splice(i, 1);
                    }
                }
            }
            
            updateBurnEffects() {
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    if (player.burning) {
                        player.burning.duration--;
                        
                        // æ¯ç§’é€ æˆç‡ƒçƒ§ä¼¤å®³
                        if (player.burning.duration % player.burning.interval === 0) {
                            const damage = player.burning.damage;
                            player.hp = Math.max(0, player.hp - damage);
                            this.showDamage(player.x, player.y - 40, damage);
                            
                            // åˆ›å»ºç‡ƒçƒ§ç²’å­æ•ˆæœ
                            for (let i = 0; i < 3; i++) {
                                this.particles.push({
                                    x: player.x + (Math.random() - 0.5) * 20,
                                    y: player.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -Math.random() * 3,
                                    color: '#FF6347',
                                    life: 30,
                                    maxLife: 30
                                });
                            }
                            
                            if (player.hp <= 0) {
                                this.gameOver(id == 1 ? 2 : 1);
                            }
                        }
                        
                        if (player.burning.duration <= 0) {
                            delete player.burning;
                        }
                    }
                });
            }
            
            startTurn() {
                // ç¡®ä¿æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                
                this.isTurnActive = true;
                this.turnTimeLeft = 20;
                
                // é‡ç½®å½“å‰ç©å®¶çš„é£è¡ŒçŠ¶æ€
                const player = this.players[this.currentPlayer];
                player.hasFlownThisTurn = false;
                player.isChargingFly = false;
                
                this.showTurnNotification();
                this.updateUI();
                
                // å¼€å§‹å€’è®¡æ—¶
                this.turnTimer = setInterval(() => {
                    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œå¦‚æœæ¸¸æˆç»“æŸåˆ™æ¸…é™¤å®šæ—¶å™¨
                    if (this.gameState !== 'playing') {
                        clearInterval(this.turnTimer);
                        this.turnTimer = null;
                        return;
                    }
                    
                    this.turnTimeLeft--;
                    this.updateUI();
                    
                    if (this.turnTimeLeft <= 0) {
                        this.endTurn();
                    }
                }, 1000);
            }
            
            endTurn() {
                this.isTurnActive = false;
                
                // æ¸…é™¤å›åˆå®šæ—¶å™¨
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                
                // å¦‚æœæ­£åœ¨å……èƒ½ï¼Œåœæ­¢å……èƒ½
                if (this.isCharging) {
                    this.isCharging = false;
                    if (this.chargeInterval) {
                        clearInterval(this.chargeInterval);
                        this.chargeInterval = null;
                    }
                    document.getElementById('powerMeter').style.display = 'none';
                }
                
                // å¦‚æœæ­£åœ¨é£è¡Œå……èƒ½ï¼Œåœæ­¢é£è¡Œå……èƒ½
                const player = this.players[this.currentPlayer];
                if (player.isChargingFly) {
                    player.isChargingFly = false;
                    player.flyPower = 0;
                    if (this.flyChargeInterval) {
                        clearInterval(this.flyChargeInterval);
                        this.flyChargeInterval = null;
                    }
                    document.getElementById('flyMeter').style.display = 'none';
                }
                
                // ç­‰å¾…ä¸€ç§’ååˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                setTimeout(() => {
                    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿æ¸¸æˆä»åœ¨è¿›è¡Œ
                    if (this.gameState === 'playing') {
                        this.nextTurn();
                    }
                }, 1000);
            }
            
            nextTurn() {
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                this.startTurn();
            }
            
            showTurnNotification() {
                const notification = document.getElementById('turnNotification');
                const text = document.getElementById('turnNotificationText');
                const playerColor = this.players[this.currentPlayer].color;
                
                let notificationText = '';
                if (this.gameMode === 'single') {
                    notificationText = this.currentPlayer === 1 ? 'ä½ çš„å›åˆå¼€å§‹!' : 'AIå›åˆå¼€å§‹!';
                } else {
                    notificationText = `ç©å®¶${this.currentPlayer}çš„å›åˆå¼€å§‹!`;
                }
                
                text.textContent = notificationText;
                text.style.color = playerColor;
                notification.style.display = 'block';
                
                // 2ç§’åéšè—æç¤º
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }
            
            waitForProjectileEnd() {
                const checkProjectiles = () => {
                    // å¦‚æœæ¸¸æˆä¸åœ¨è¿›è¡Œä¸­ï¼Œåœæ­¢æ£€æŸ¥
                    if (this.gameState !== 'playing') {
                        return;
                    }
                    
                    if (this.projectiles.length === 0 && this.explosions.length === 0) {
                        setTimeout(() => {
                            // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿æ²¡æœ‰åœ¨é‡æ–°å¼€å§‹è¿‡ç¨‹ä¸­
                            if (this.gameState === 'playing') {
                                this.nextTurn();
                            }
                        }, 1000);
                    } else {
                        setTimeout(checkProjectiles, 100);
                    }
                };
                
                setTimeout(checkProjectiles, 500);
            }
            
            toggleFlyMode() {
                if (!this.isTurnActive) return;
                
                const player = this.players[this.currentPlayer];
                const oldFlyMode = player.flyMode;
                player.flyMode = !player.flyMode;
                
                // æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢æç¤º
                if (player.flyMode) {
                    this.showModeChangeNotification(player.x, player.y, 'åˆ‡æ¢åˆ°é£è¡Œæ¨¡å¼');
                } else {
                    this.showModeChangeNotification(player.x, player.y, 'åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                }
                
                if (!player.flyMode) {
                    // é€€å‡ºé£è¡Œæ¨¡å¼æ—¶ï¼Œåœæ­¢æ‰€æœ‰é£è¡Œç›¸å…³çŠ¶æ€
                    if (player.isChargingFly) {
                        player.isChargingFly = false;
                        clearInterval(this.flyChargeInterval);
                        document.getElementById('flyMeter').style.display = 'none';
                    }
                    if (player.isFlying) {
                        player.isFlying = false;
                        player.flyVelocityX = 0;
                        player.flyVelocityY = 0;
                    }
                    player.flyPower = 0;
                }
                
                this.updateUI();
            }
            
            startFlyCharging() {
                if (this.gameState !== 'playing' || !this.isTurnActive) return;
                
                const player = this.players[this.currentPlayer];
                if (!player.flyMode || player.isFlying || player.hasFlownThisTurn || player.isChargingFly) {
                    // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºæ— æ³•é£è¡Œçš„åŸå› 
                    if (!player.flyMode) {
                        this.showModeChangeNotification(player.x, player.y, 'è¯·å…ˆåˆ‡æ¢åˆ°é£è¡Œæ¨¡å¼');
                    } else if (player.hasFlownThisTurn) {
                        this.showModeChangeNotification(player.x, player.y, 'æœ¬å›åˆå·²é£è¡Œè¿‡');
                    } else if (player.isFlying) {
                        this.showModeChangeNotification(player.x, player.y, 'æ­£åœ¨é£è¡Œä¸­');
                    } else if (player.isChargingFly) {
                        this.showModeChangeNotification(player.x, player.y, 'æ­£åœ¨è“„åŠ›ä¸­');
                    }
                    return;
                }
                
                player.isChargingFly = true;
                player.flyPower = 0;
                document.getElementById('flyMeter').style.display = 'flex';
                
                this.flyChargeInterval = setInterval(() => {
                    player.flyPower = Math.min(player.flyPower + 1.5, 100);
                    const flyFill = document.getElementById('flyFill');
                    if (flyFill) {
                        flyFill.style.width = player.flyPower + '%';
                    }
                }, 50);
            }
            
            fly() {
                const player = this.players[this.currentPlayer];
                if (!player.flyMode || player.flyPower <= 0 || !player.isChargingFly) return;
                
                clearInterval(this.flyChargeInterval);
                document.getElementById('flyMeter').style.display = 'none';
                
                // è®¡ç®—é£è¡ŒåŠ›åº¦å’Œæ–¹å‘
                const power = player.flyPower / 100;
                const radians = (player.angle * Math.PI) / 180;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨éšœç¢ç‰©ä¸Šï¼Œéœ€è¦é¢å¤–æ¨åŠ›
                const wasOnObstacle = player.standingOnObstacle;
                
                // è®¾ç½®é£è¡ŒçŠ¶æ€
                player.isFlying = true;
                player.isChargingFly = false;
                player.hasFlownThisTurn = true;
                player.onGround = false;
                player.standingOnObstacle = false; // æ¸…é™¤éšœç¢ç‰©ç«™ç«‹çŠ¶æ€ï¼Œç¡®ä¿èƒ½å¤Ÿèµ·é£
                player.currentSupportingObstacle = null; // æ¸…é™¤æ”¯æ’‘éšœç¢ç‰©å¼•ç”¨
                
                // æ ¹æ®è“„åŠ›ç¨‹åº¦è®¾ç½®åˆå§‹é€Ÿåº¦ (é™ä½30%)
                const baseSpeed = 15.4; // ä»22é™ä½30%åˆ°15.4
                player.flyVelocityX = Math.cos(radians) * power * baseSpeed;
                player.flyVelocityY = -Math.sin(radians) * power * baseSpeed;
                
                // å¦‚æœåœ¨éšœç¢ç‰©ä¸Šï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„å‚ç›´é€Ÿåº¦æ¥è„±ç¦»
                if (wasOnObstacle && Math.abs(player.flyVelocityY) < 3) {
                    player.flyVelocityY = player.flyVelocityY >= 0 ? -3 : player.flyVelocityY - 3;
                }
                player.flyPower = 0;
                
                // ç»™ä¸€ä¸ªå‘ä¸Šæ¨åŠ›ï¼Œç¡®ä¿èƒ½å¤Ÿè„±ç¦»éšœç¢ç‰©è¡¨é¢
                if (wasOnObstacle) {
                    player.y -= 10; // å‘ä¸Šç§»åŠ¨10åƒç´ ï¼Œç¡®ä¿å®Œå…¨è„±ç¦»éšœç¢ç‰©è¡¨é¢
                    // å¦‚æœè§’åº¦å‘ä¸Šï¼Œé¢å¤–å¢åŠ å‘ä¸Šæ¨åŠ›
                    if (player.angle > 90) {
                        player.y -= 5;
                    }
                    // ç»™é£è¡Œä¸€ä¸ªé¢å¤–çš„å‘ä¸Šåˆå§‹é€Ÿåº¦
                    player.flyVelocityY -= 2;
                }
                
                // åˆ›å»ºé£è¡Œèµ·å§‹æ•ˆæœ
                this.createFlyStartEffect(player.x, player.y);
                
                // æ˜¾ç¤ºé£è¡Œå¼€å§‹æç¤º
                const startMessage = wasOnObstacle ? 'ğŸš€ ä»å¹³å°èµ·é£ï¼' : 'ğŸš€ å¼€å§‹é£è¡Œï¼';
                this.showModeChangeNotification(player.x, player.y, startMessage);
                
                // å¼ºåˆ¶ç¡®ä¿é£è¡ŒçŠ¶æ€ç«‹å³ç”Ÿæ•ˆï¼Œè·³è¿‡ä¸€æ¬¡ç‰©ç†æ›´æ–°
                player.skipPhysicsThisFrame = true;
                
                // æ›´æ–°UIæ˜¾ç¤ºé£è¡ŒçŠ¶æ€
                this.updateUI();
            }
            
            updatePlayerPhysics(player) {
                // å¦‚æœæ ‡è®°è·³è¿‡ç‰©ç†æ›´æ–°ï¼Œæ¸…é™¤æ ‡è®°å¹¶è¿”å›
                if (player.skipPhysicsThisFrame) {
                    player.skipPhysicsThisFrame = false;
                    return;
                }
                
                if (player.isFlying) {
                    // é£è¡Œç‰©ç† - æŠ›ç‰©çº¿è¿åŠ¨
                    player.x += player.flyVelocityX;
                    player.y += player.flyVelocityY;
                    
                    // é‡åŠ›å½±å“
                    player.flyVelocityY += 0.28; // è¿›ä¸€æ­¥é™ä½é‡åŠ›åŠ é€Ÿåº¦ï¼Œè®©é£è¡Œè·ç¦»æ›´è¿œ
                    
                    // ç©ºæ°”é˜»åŠ›ï¼ˆæ°´å¹³æ–¹å‘ï¼‰
                    player.flyVelocityX *= 0.998; // è¿›ä¸€æ­¥å‡å°‘ç©ºæ°”é˜»åŠ›ï¼Œè®©é£è¡Œè·ç¦»æ›´è¿œ
                    
                    // è¾¹ç•Œæ£€æŸ¥
                    player.x = Math.max(20, Math.min(this.canvas.width - 20, player.x));
                    
                    // æ£€æŸ¥æ˜¯å¦æ’åˆ°åœ°é¢æˆ–éšœç¢ç‰©
                    const groundHeight = this.getTerrainHeight(player.x);
                    let landedOnObstacle = false;
                    
                    // æ£€æŸ¥éšœç¢ç‰©åˆšä½“ç€é™†
                    for (let obstacle of this.obstacles) {
                        if (obstacle.isSolid && obstacle.canLandOn) {
                            const obstacleLeft = obstacle.x - obstacle.width/2;
                            const obstacleRight = obstacle.x + obstacle.width/2;
                            const obstacleTop = obstacle.y - obstacle.height/2;
                            
                            // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨éšœç¢ç‰©èŒƒå›´å†…å¹¶æ¥è¿‘é¡¶éƒ¨
                            if (player.x >= obstacleLeft - 15 && 
                                player.x <= obstacleRight + 15 &&
                                player.y >= obstacleTop - 40 && 
                                player.y <= obstacleTop + 25) {
                                
                                // æ£€æŸ¥ç€é™†ä½ç½®æ˜¯å¦è¢«å¼¹å‘ç ´å
                                let canLand = true;
                                const relativeX = player.x - obstacle.x;
                                
                                for (let crater of obstacle.craters) {
                                    const distance = Math.sqrt(
                                        Math.pow(relativeX - crater.x, 2) + 
                                        Math.pow(0 - crater.y, 2)
                                    );
                                    if (distance <= crater.radius + 12) {
                                        canLand = false;
                                        break;
                                    }
                                }
                                
                                if (canLand) {
                                    // æˆåŠŸç€é™†åˆ°éšœç¢ç‰©åˆšä½“
                                    player.y = obstacleTop - 20;
                                    player.isFlying = false;
                                    player.flyVelocityX = 0;
                                    player.flyVelocityY = 0;
                                    player.onGround = true;
                                    // ç€é™†åˆ°éšœç¢ç‰©åè‡ªåŠ¨åˆ‡æ¢åˆ°æ”»å‡»å’Œç§»åŠ¨æ¨¡å¼
                                    player.flyMode = false;
                                    player.standingOnObstacle = true;
                                    
                                    this.createObstacleLandingEffect(player.x, player.y);
                                    this.showModeChangeNotification(player.x, player.y, 'ç€é™†åœ¨å¹³å°ä¸Šï¼Œåˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                                    this.updateUI();
                                    landedOnObstacle = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰ç€é™†åœ¨éšœç¢ç‰©ä¸Šï¼Œæ£€æŸ¥åœ°é¢ç€é™†
                    if (!landedOnObstacle) {
                        // æ£€æŸ¥æ˜¯å¦åº”è¯¥ç€é™†åˆ°åœ°é¢
                        if (player.y >= groundHeight - 20) {
                            player.y = groundHeight - 20;
                            player.isFlying = false;
                            player.flyVelocityX = 0;
                            player.flyVelocityY = 0;
                            player.onGround = true;
                            
                            // é£è¡Œç»“æŸåè‡ªåŠ¨åˆ‡æ¢å›æ™®é€šæ¨¡å¼
                            player.flyMode = false;
                            
                            // ç€é™†ç²’å­æ•ˆæœ
                            this.createLandingEffect(player.x, player.y);
                            
                            // æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢æç¤º
                            this.showModeChangeNotification(player.x, player.y, 'åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                            
                            // æ›´æ–°UIæ˜¾ç¤ºæ¨¡å¼å˜åŒ–
                            this.updateUI();
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ’åˆ°é¡¶éƒ¨
                    if (player.y <= 20) {
                        player.y = 20;
                        player.flyVelocityY = Math.max(0, player.flyVelocityY); // åªå…è®¸å‘ä¸‹
                    }
                    
                    // å¦‚æœé£è¡Œé€Ÿåº¦å¤ªå°ï¼Œè§†ä¸ºé£è¡Œç»“æŸ
                    if (Math.abs(player.flyVelocityX) < 0.5 && Math.abs(player.flyVelocityY) < 0.5) {
                        player.isFlying = false;
                        player.flyVelocityX = 0;
                        player.flyVelocityY = 0;
                        
                        // é£è¡Œç»“æŸåç»Ÿä¸€åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼
                        player.flyMode = false;
                        if (player.standingOnObstacle) {
                            this.showModeChangeNotification(player.x, player.y, 'é£è¡Œç»“æŸï¼Œåˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                        } else {
                            this.showModeChangeNotification(player.x, player.y, 'åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                        }
                        this.updateUI();
                    }
                } else {
                    // åœ°é¢ç‰©ç† - åˆšä½“ç¢°æ’ç³»ç»Ÿ
                    // ç¡®ä¿åªæœ‰åœ¨éé£è¡ŒçŠ¶æ€ä¸‹æ‰æ‰§è¡Œåœ°é¢ç‰©ç†
                    if (player.isFlying) return;
                    
                    const groundHeight = this.getTerrainHeight(player.x);
                    let supportingObstacle = null;
                    let supportHeight = groundHeight;
                    
                    // æ£€æŸ¥æ‰€æœ‰éšœç¢ç‰©çš„åˆšä½“ç¢°æ’
                    for (let obstacle of this.obstacles) {
                        if (obstacle.isSolid) {
                            const obstacleLeft = obstacle.x - obstacle.width/2;
                            const obstacleRight = obstacle.x + obstacle.width/2;
                            const obstacleTop = obstacle.y - obstacle.height/2;
                            
                            // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨éšœç¢ç‰©çš„æ°´å¹³èŒƒå›´å†…ï¼ˆå¢åŠ å®¹é”™èŒƒå›´ï¼‰
                            if (player.x >= obstacleLeft - 8 && player.x <= obstacleRight + 8) {
                                // æ£€æŸ¥ç©å®¶æ˜¯å¦åº”è¯¥ç«™åœ¨è¿™ä¸ªéšœç¢ç‰©ä¸Š
                                if (player.y >= obstacleTop - 30 && player.y <= obstacleTop + 15) {
                                    
                                    // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦è¢«å¼¹å‘ç ´å
                                    let canStand = true;
                                    const relativeX = player.x - obstacle.x;
                                    
                                    for (let crater of obstacle.craters) {
                                        const distance = Math.sqrt(
                                            Math.pow(relativeX - crater.x, 2) + 
                                            Math.pow(0 - crater.y, 2)
                                        );
                                        if (distance <= crater.radius + 8) {
                                            canStand = false;
                                            break;
                                        }
                                    }
                                    
                                    // å¦‚æœå¯ä»¥ç«™ç«‹ä¸”è¿™ä¸ªéšœç¢ç‰©æ¯”å½“å‰æ”¯æ’‘é¢æ›´é«˜ï¼ˆå³æ›´é è¿‘ç©å®¶ï¼‰
                                    if (canStand && obstacleTop < supportHeight) {
                                        supportHeight = obstacleTop;
                                        supportingObstacle = obstacle;
                                    }
                                }
                            }
                        }
                    }
                    
                    // åº”ç”¨ç‰©ç†
                    const targetY = supportHeight - 20;
                    
                    if (player.y < targetY - 2) {
                        // é‡åŠ›ä¸‹è½åˆ°æ”¯æ’‘é¢
                        player.y = Math.min(player.y + 6, targetY);
                        player.onGround = false;
                    } else if (player.y > targetY + 2) {
                        // å¦‚æœç©å®¶é«˜äºæ”¯æ’‘é¢å¤ªå¤šï¼Œå¼€å§‹ä¸‹è½
                        player.y = Math.max(player.y - 3, targetY);
                        player.onGround = (player.y <= targetY + 1);
                    } else {
                        // ç«™ç«‹åœ¨æ”¯æ’‘é¢ä¸Šï¼ˆå…è®¸å°èŒƒå›´æ³¢åŠ¨ï¼‰
                        player.y = targetY;
                        player.onGround = true;
                    }
                    
                    // æ›´æ–°ç«™ç«‹çŠ¶æ€
                    if (supportingObstacle && player.onGround) {
                        player.standingOnObstacle = true;
                        player.currentSupportingObstacle = supportingObstacle; // è®°å½•å½“å‰æ”¯æ’‘çš„éšœç¢ç‰©
                    } else {
                        player.standingOnObstacle = false;
                        player.currentSupportingObstacle = null;
                    }
                }
            }
            
            createFlyStartEffect(x, y) {
                // åˆ›å»ºé£è¡Œèµ·å§‹ç²’å­æ•ˆæœ
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 15,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 6,
                        vy: Math.random() * 4 + 2, // å‘ä¸‹çš„ç²’å­è¡¨ç¤ºèµ·é£
                        color: '#00BFFF',
                        life: 30,
                        maxLife: 30
                    });
                }
                
                // æ·»åŠ ä¸€äº›ç™½è‰²ç²’å­è¡¨ç¤ºæ¨è¿›åŠ›
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 12,
                        y: y + 5 + (Math.random() - 0.5) * 8,
                        vx: (Math.random() - 0.5) * 3,
                        vy: Math.random() * 6 + 1,
                        color: '#FFFFFF',
                        life: 20,
                        maxLife: 20
                    });
                }
            }
            
            createObstacleLandingEffect(x, y) {
                // åˆ›å»ºéšœç¢ç‰©ç€é™†ç²’å­æ•ˆæœ - é‡‘è‰²ä¸»é¢˜
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 30,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -Math.random() * 8,
                        color: '#FFD700', // é‡‘è‰²
                        life: 45,
                        maxLife: 45
                    });
                }
                
                // æ·»åŠ ä¸€äº›æ©™è‰²ç²’å­è¡¨ç¤ºå¹³å°æ¥è§¦
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 25,
                        y: y - 5 + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -Math.random() * 5,
                        color: '#FFA500', // æ©™è‰²
                        life: 30,
                        maxLife: 30
                    });
                }
                
                // æ·»åŠ ä¸€äº›ç™½è‰²é—ªå…‰æ•ˆæœ
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3,
                        color: '#FFFFFF',
                        life: 25,
                        maxLife: 25,
                        size: 3 // æ›´å¤§çš„ç²’å­
                    });
                }
            }
            
            createLandingEffect(x, y) {
                // åˆ›å»ºç€é™†ç²’å­æ•ˆæœ
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 25,
                        y: y + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6,
                        color: '#8B4513',
                        life: 40,
                        maxLife: 40
                    });
                }
                
                // æ·»åŠ ä¸€äº›è“è‰²ç²’å­è¡¨ç¤ºé£è¡Œç»“æŸ
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y - 10 + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3,
                        color: '#87CEEB',
                        life: 35,
                        maxLife: 35
                    });
                }
            }
            
            checkObstacleCollision(player) {
                // æ£€æŸ¥ç©å®¶ä¸éšœç¢ç‰©çš„åˆšä½“ç¢°æ’
                for (let obstacle of this.obstacles) {
                    if (obstacle.isSolid) {
                        const obstacleLeft = obstacle.x - obstacle.width/2;
                        const obstacleRight = obstacle.x + obstacle.width/2;
                        const obstacleTop = obstacle.y - obstacle.height/2;
                        const obstacleBottom = obstacle.y + obstacle.height/2;
                        
                        const playerLeft = player.x - 10;
                        const playerRight = player.x + 10;
                        const playerTop = player.y - 10;
                        const playerBottom = player.y + 10;
                        
                        // æ£€æŸ¥AABBç¢°æ’
                        if (playerRight > obstacleLeft && 
                            playerLeft < obstacleRight && 
                            playerBottom > obstacleTop && 
                            playerTop < obstacleBottom) {
                            
                            // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦è¢«å¼¹å‘ç ´å
                            let isDestroyed = false;
                            const relativeX = player.x - obstacle.x;
                            const relativeY = player.y - obstacle.y;
                            
                            for (let crater of obstacle.craters) {
                                const distance = Math.sqrt(
                                    Math.pow(relativeX - crater.x, 2) + 
                                    Math.pow(relativeY - crater.y, 2)
                                );
                                if (distance <= crater.radius) {
                                    isDestroyed = true;
                                    break;
                                }
                            }
                            
                            // å¦‚æœæ²¡æœ‰è¢«ç ´åï¼Œåˆ™å‘ç”Ÿç¢°æ’
                            if (!isDestroyed) {
                                return obstacle;
                            }
                        }
                    }
                }
                return null;
            }
            
            createObstacleCrater(obstacle, hitX, hitY, weapon) {
                // è®¡ç®—å¼¹å‘åœ¨éšœç¢ç‰©ä¸Šçš„ç›¸å¯¹ä½ç½®
                const relativeX = hitX - obstacle.x;
                const relativeY = hitY - obstacle.y;
                
                // æ ¹æ®æ­¦å™¨ç±»å‹ç¡®å®šå¼¹å‘å¤§å°ï¼ˆè°ƒæ•´ä¸ºæ›´åˆç†çš„æ¶ˆè€—æ¯”ä¾‹ï¼‰
                let craterRadius = 18; // æ™®é€šç‚¸å¼¹
                if (weapon.name === 'è¶…çº§ç‚¸å¼¹') craterRadius = 28;
                else if (weapon.name === 'ç©¿ç”²å¼¹') craterRadius = 15;
                else if (weapon.name === 'é›†æŸç‚¸å¼¹') craterRadius = 12; // é›†æŸå¼¹å•ä¸ªå¼¹å‘è¾ƒå°
                else if (weapon.name === 'è¿å°„ç‚¸å¼¹') craterRadius = 10; // è¿å°„å¼¹å‘è¾ƒå°
                else if (weapon.name === 'ç‡ƒçƒ§å¼¹') craterRadius = 20;
                else if (weapon.name === 'æ•£å°„å¼¹') craterRadius = 8; // æ•£å°„å¼¹å‘å¾ˆå°
                else if (weapon.name === 'æ ¸å¼¹') craterRadius = 35; // æ ¸å¼¹å¼¹å‘æœ€å¤§
                
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰å¼¹å‘é‡å ï¼Œå¦‚æœé‡å åˆ™æ‰©å¤§ç°æœ‰å¼¹å‘
                let merged = false;
                for (let existingCrater of obstacle.craters) {
                    const distance = Math.sqrt(
                        Math.pow(existingCrater.x - relativeX, 2) + 
                        Math.pow(existingCrater.y - relativeY, 2)
                    );
                    
                    // å¦‚æœè·ç¦»å°äºä¸¤ä¸ªå¼¹å‘åŠå¾„ä¹‹å’Œçš„80%ï¼Œåˆ™åˆå¹¶
                    if (distance < (existingCrater.radius + craterRadius) * 0.8) {
                        // æ‰©å¤§ç°æœ‰å¼¹å‘
                        existingCrater.radius = Math.max(existingCrater.radius, 
                            existingCrater.radius + craterRadius * 0.3);
                        merged = true;
                        break;
                    }
                }
                
                // å¦‚æœæ²¡æœ‰åˆå¹¶ï¼Œåˆ™æ·»åŠ æ–°å¼¹å‘
                if (!merged) {
                    obstacle.craters.push({
                        x: relativeX,
                        y: relativeY,
                        radius: craterRadius,
                        weapon: weapon
                    });
                }
                
                // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
                const debrisCount = 8;
                const baseColor = obstacle.type === 'platform' ? '#8B7355' : '#E0E0E0';
                
                for (let i = 0; i < debrisCount; i++) {
                    this.particles.push({
                        x: hitX + (Math.random() - 0.5) * craterRadius,
                        y: hitY + (Math.random() - 0.5) * craterRadius,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6 - 1,
                        color: baseColor,
                        life: 40 + Math.random() * 30,
                        maxLife: 40 + Math.random() * 30
                    });
                }
            }
            
            showModeChangeNotification(x, y, text) {
                // åˆ›å»ºæ¨¡å¼åˆ‡æ¢æç¤º
                const notification = document.createElement('div');
                notification.textContent = text;
                notification.style.position = 'absolute';
                notification.style.left = (x - 50) + 'px';
                notification.style.top = (y - 40) + 'px';
                notification.style.color = '#87CEEB';
                notification.style.fontWeight = 'bold';
                notification.style.fontSize = '14px';
                notification.style.pointerEvents = 'none';
                notification.style.zIndex = '1000';
                notification.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
                notification.style.animation = 'fadeUpOut 2s ease-out forwards';
                
                // æ·»åŠ CSSåŠ¨ç”»
                if (!document.getElementById('modeChangeStyle')) {
                    const style = document.createElement('style');
                    style.id = 'modeChangeStyle';
                    style.textContent = `
                        @keyframes fadeUpOut {
                            0% {
                                opacity: 1;
                                transform: translateY(0);
                            }
                            100% {
                                opacity: 0;
                                transform: translateY(-30px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(notification);
                
                // 2ç§’åç§»é™¤æç¤º
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 2000);
            }
            
            createCrater(x, y, weapon) {
                // æ‰€æœ‰çˆ†ç‚¸éƒ½å¯ä»¥å½±å“åœ°å½¢ï¼Œæ ¹æ®è·ç¦»åœ°é¢çš„é«˜åº¦è°ƒæ•´å¨åŠ›
                const groundHeight = this.getTerrainHeight(x);
                const distanceToGround = Math.abs(y - groundHeight);
                
                // è®¡ç®—çˆ†ç‚¸å¯¹åœ°å½¢çš„å½±å“åŠ›ï¼Œè·ç¦»è¶Šè¿‘å½±å“è¶Šå¤§
                const maxEffectiveDistance = weapon.radius * 2; // æœ€å¤§æœ‰æ•ˆè·ç¦»
                let effectMultiplier = 1.0;
                
                if (distanceToGround > maxEffectiveDistance) {
                    // è·ç¦»å¤ªè¿œï¼Œæ²¡æœ‰å½±å“
                    return;
                } else if (distanceToGround > weapon.radius) {
                    // è·ç¦»è¾ƒè¿œï¼Œå½±å“åŠ›è¡°å‡
                    effectMultiplier = 1.0 - (distanceToGround - weapon.radius) / weapon.radius;
                }
                // è·ç¦»å¾ˆè¿‘æˆ–åœ¨åœ°é¢ä»¥ä¸‹ï¼Œä¿æŒæœ€å¤§å½±å“åŠ›
                
                const craterRadius = weapon.radius * 1.0 * effectMultiplier; // å¼¹å‘åŠå¾„æ ¹æ®è·ç¦»è°ƒæ•´
                const craterDepth = weapon.damage * 2.2 * effectMultiplier; // å¢åŠ å¼¹å‘æ·±åº¦å€æ•°ï¼Œç¡®ä¿åº•éƒ¨åœ°å½¢ä¹Ÿèƒ½å½¢æˆæ˜æ˜¾å¼¹å‘
                
                // console.log(`åˆ›å»ºå¼¹å‘ - çˆ†ç‚¸ä½ç½®: (${Math.round(x)}, ${Math.round(y)}), åœ°é¢é«˜åº¦: ${Math.round(groundHeight)}, è·ç¦»: ${Math.round(distanceToGround)}, å½±å“å€æ•°: ${effectMultiplier.toFixed(2)}`);
                
                // ç›´æ¥ä¿®æ”¹åœ°å½¢æ•°æ®ï¼Œä¼ é€’çˆ†ç‚¸ä½ç½®ç”¨äºè®¡ç®—å†²å‡»æ³¢å½±å“
                this.modifyTerrain(x, craterRadius, craterDepth, y);
                
                // è·å–æŒ–æ˜åçš„æ–°åœ°å½¢é«˜åº¦
                const newGroundHeight = this.getTerrainHeight(x);
                
                // console.log(`å¼¹å‘åˆ›å»ºå - æ–°é«˜åº¦: ${Math.round(newGroundHeight)}, é«˜åº¦å˜åŒ–: ${Math.round(newGroundHeight - groundHeight)}`);
                
                // è®°å½•å¼¹å‘ä¿¡æ¯ç”¨äºè§†è§‰æ•ˆæœï¼ˆä½¿ç”¨çˆ†ç‚¸ä½ç½®å’Œåœ°é¢é«˜åº¦ä¸­è¾ƒä½çš„ä½ç½®ï¼‰
                this.craters.push({
                    x: x,
                    y: Math.max(y, newGroundHeight), // ä½¿ç”¨çˆ†ç‚¸ä½ç½®å’Œæ–°åœ°é¢é«˜åº¦ä¸­è¾ƒä½çš„ä½ç½®
                    radius: craterRadius,
                    depth: craterDepth,
                    age: 0 // å¼¹å‘å¹´é¾„ï¼Œç”¨äºè§†è§‰æ•ˆæœ
                });
            }
            
            modifyTerrain(centerX, radius, depth, explosionY = null) {
                // ä¿®æ”¹åœ°å½¢æ•°æ®ï¼Œåˆ›å»ºçœŸå®çš„å¼¹å‘
                const startIndex = Math.max(0, Math.floor((centerX - radius) / 10));
                const endIndex = Math.min(this.terrain.length - 1, Math.floor((centerX + radius) / 10));
                
                // è®°å½•ä¿®æ”¹å‰çš„ä¸­å¿ƒç‚¹é«˜åº¦ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                const centerIndex = Math.floor(centerX / 10);
                const beforeHeight = this.terrain[centerIndex]?.height;
                
                // å¢å¼ºçš„å¼¹å‘æŒ–æ˜ç®—æ³•
                for (let i = startIndex; i <= endIndex; i++) {
                    const terrainPoint = this.terrain[i];
                    const distance = Math.abs(terrainPoint.x - centerX);
                    
                    if (distance <= radius) {
                        // è®¡ç®—åœ°å½¢ç ´åæ·±åº¦ï¼Œè€ƒè™‘çˆ†ç‚¸ä½ç½®
                        let actualDepth = depth;
                        
                        if (explosionY !== null) {
                            // å¦‚æœçˆ†ç‚¸åœ¨åœ°å½¢ä¸Šæ–¹ï¼Œæ ¹æ®é«˜åº¦å·®è°ƒæ•´ç ´åæ·±åº¦
                            const heightDiff = explosionY - terrainPoint.height;
                            if (heightDiff < 0) {
                                // çˆ†ç‚¸åœ¨åœ°å½¢ä¸Šæ–¹ï¼Œå†²å‡»æ³¢å‘ä¸‹ä¼ æ’­
                                const airDistance = Math.abs(heightDiff);
                                const penetrationFactor = Math.max(0.2, 1.0 - airDistance / (radius * 2));
                                actualDepth *= penetrationFactor;
                            }
                        }
                        
                        // ä½¿ç”¨æ›´é™¡å³­çš„æŠ›ç‰©çº¿å‡½æ•°ï¼Œåˆ›å»ºæ›´æ˜æ˜¾çš„å¼¹å‘
                        const normalizedDistance = distance / radius;
                        
                        // ä¸‰ç§æ·±åº¦å‡½æ•°ä¾›é€‰æ‹©
                        let depthFactor;
                        if (normalizedDistance < 0.3) {
                            // å¼¹å‘ä¸­å¿ƒï¼šä¿æŒæœ€å¤§æ·±åº¦
                            depthFactor = 1.0;
                        } else if (normalizedDistance < 0.7) {
                            // å¼¹å‘ä¸­é—´ï¼šé™¡å³­ä¸‹é™
                            const t = (normalizedDistance - 0.3) / 0.4;
                            depthFactor = 1.0 - (t * t * t); // ç«‹æ–¹è¡°å‡ï¼Œä¿æŒæ·±åº¦
                        } else {
                            // å¼¹å‘è¾¹ç¼˜ï¼šå¿«é€Ÿè¡°å‡åˆ°0
                            const t = (normalizedDistance - 0.7) / 0.3;
                            depthFactor = (1 - t) * (1 - t) * 0.3; // è¾¹ç¼˜å¿«é€Ÿè¡°å‡
                        }
                        
                        const finalDepth = actualDepth * depthFactor;
                        const originalHeight = terrainPoint.height;
                        
                        // ä¿®æ”¹åœ°å½¢é«˜åº¦ï¼ˆå‘ä¸‹æŒ–æ˜ï¼‰- åœ¨Canvasåæ ‡ç³»ä¸­ï¼Œå‘ä¸‹æŒ–æ˜åº”è¯¥å¢åŠ Yåæ ‡
                        terrainPoint.height += finalDepth;
                        
                        // ç§»é™¤æ·±åº¦é™åˆ¶ï¼Œå…è®¸åœ°å½¢è¢«å®Œå…¨é”€æ¯
                        // ç©å®¶å¯ä»¥æ‰å‡ºæ¸¸æˆç•Œé¢ï¼Œè¿™æ—¶ä¼šè§¦å‘æ·±å‘å¤±è´¥åˆ¤å®š
                        
                        // è®°å½•å¼¹å‘æ ‡è®°ï¼Œç”¨äºæ™ºèƒ½å¹³æ»‘
                        if (finalDepth > 2) { // é™ä½é˜ˆå€¼ï¼Œè®©è½»å¾®çš„æŒ–æ˜ä¹Ÿèƒ½è¢«è®°å½•
                            terrainPoint.hasCrater = true;
                            terrainPoint.craterDepth = (terrainPoint.craterDepth || 0) + finalDepth;
                        }
                    }
                }
                
                // æ™ºèƒ½å¹³æ»‘ï¼Œä¿æŠ¤å¼¹å‘å½¢çŠ¶
                this.smartSmoothTerrain(startIndex, endIndex, centerX, radius);
                
                // å¯é€‰ï¼šè°ƒè¯•ä¿¡æ¯
                if (false) { // è®¾ä¸ºtrueå¯ç”¨è°ƒè¯•
                    const finalHeight = this.terrain[centerIndex]?.height;
                    const digDepth = finalHeight - beforeHeight;
                    console.log(`å¼¹å‘åˆ›å»ºå®Œæˆ - ä½ç½®: (${Math.round(centerX)}, ${Math.round(beforeHeight)} -> ${Math.round(finalHeight)}), æŒ–æ˜æ·±åº¦: ${Math.round(digDepth)}åƒç´ `);
                    
                    // ç‰¹åˆ«æ ‡è®°æ·±åº¦æŒ–æ˜æƒ…å†µ
                    if (finalHeight > this.canvas.height) {
                        console.log(`ğŸ” åœ°å½¢å·²è¢«æŒ–æ˜åˆ°ç•Œé¢åº•éƒ¨ä»¥ä¸‹ - æœ€ç»ˆé«˜åº¦: ${Math.round(finalHeight)}, ç•Œé¢é«˜åº¦: ${this.canvas.height}`);
                    }
                }
            }
            
            smartSmoothTerrain(startIndex, endIndex, centerX, radius) {
                // ä¸“é—¨ä¸ºå¼¹å‘è®¾è®¡çš„æ™ºèƒ½å¹³æ»‘ç®—æ³•ï¼šä¿æŠ¤å¼¹å‘å½¢çŠ¶ï¼Œåªå¹³æ»‘è¾¹ç¼˜
                
                // åªå¯¹å¼¹å‘å¤–å›´è¾¹ç¼˜è¿›è¡Œè½»å¾®å¹³æ»‘ï¼Œå®Œå…¨ä¿æŠ¤å¼¹å‘å†…éƒ¨
                const edgeRange = Math.max(1, Math.ceil(radius / 30)); // æœ€å°1ä¸ªç‚¹ï¼Œæ ¹æ®åŠå¾„è°ƒæ•´
                const actualStart = Math.max(0, startIndex - edgeRange);
                const actualEnd = Math.min(this.terrain.length - 1, endIndex + edgeRange);
                
                for (let i = actualStart; i < actualEnd; i++) {
                    // åªå¤„ç†å¼¹å‘è¾¹ç•Œå¤–çš„ç‚¹
                    if (i < startIndex || i > endIndex) {
                        const prev = this.terrain[Math.max(0, i - 1)].height;
                        const current = this.terrain[i].height;
                        const next = this.terrain[Math.min(this.terrain.length - 1, i + 1)].height;
                        
                        // è®¡ç®—è·ç¦»å¼¹å‘ä¸­å¿ƒçš„è·ç¦»
                        const distanceFromCenter = Math.abs(this.terrain[i].x - centerX);
                        
                        // åªå¯¹è·ç¦»å¼¹å‘è¾¹ç¼˜è¾ƒè¿œçš„ç‚¹è¿›è¡Œè½»å¾®å¹³æ»‘
                        if (distanceFromCenter > radius * 0.9) {
                            // è·ç¦»è¶Šè¿œï¼Œå¹³æ»‘å¼ºåº¦è¶Šå¤§
                            const distanceFactor = Math.min(1, (distanceFromCenter - radius) / (radius * 0.5));
                            const smoothFactor = 0.15 + distanceFactor * 0.15; // 15-30%çš„å¹³æ»‘å¼ºåº¦
                            
                            const smoothed = (prev + current * 3 + next) / 5;
                            this.terrain[i].height = current * (1 - smoothFactor) + smoothed * smoothFactor;
                        }
                    }
                    // å¼¹å‘å†…éƒ¨å’Œè¿‘è¾¹ç¼˜åŒºåŸŸå®Œå…¨ä¸å¹³æ»‘ï¼Œä¿æŒåŸå§‹å½¢çŠ¶
                }
            }
            
            smoothTerrain(startIndex, endIndex) {
                // ä¼ ç»Ÿå¹³æ»‘ç®—æ³•ï¼ˆç°åœ¨ä¸»è¦ç”¨smartSmoothTerrainï¼‰
                const smoothRange = 1;
                const actualStart = Math.max(0, startIndex - smoothRange);
                const actualEnd = Math.min(this.terrain.length - 1, endIndex + smoothRange);
                
                for (let i = actualStart + 1; i < actualEnd; i++) {
                    const prev = this.terrain[i - 1].height;
                    const current = this.terrain[i].height;
                    const next = this.terrain[i + 1].height;
                    
                    // è½»å¾®å¹³æ»‘
                    this.terrain[i].height = (prev + current * 3 + next) / 5;
                }
            }
            
            getOriginalTerrainHeight(x) {
                // è·å–åŸå§‹åœ°å½¢é«˜åº¦ï¼ˆä¸è€ƒè™‘å¼¹å‘å½±å“ï¼‰
                const index = Math.floor(x / 10);
                if (index >= 0 && index < this.terrain.length) {
                    return this.terrain[index].originalHeight || this.terrain[index].height;
                }
                return 500;
            }
            
            checkPlayerBounds() {
                if (this.gameState !== 'playing') return;
                
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦æ‰å‡ºæ¸¸æˆç•Œé¢åº•éƒ¨ï¼ˆæ‰å…¥æ·±å‘ï¼‰
                    // ä½¿ç”¨æ›´å®½æ¾çš„æ£€æµ‹èŒƒå›´ï¼Œç¡®ä¿ç©å®¶çœŸæ­£æ‰å‡ºç•Œé¢
                    if (player.y > this.canvas.height + 20) {
                        // ç©å®¶æ‰å‡ºç•Œé¢åº•éƒ¨ï¼Œåˆ¤å®šä¸ºæ‰å…¥æ·±å‘å¤±è´¥
                        if (this.gameState === 'playing') {
                            this.gameState = 'gameOver';
                            const winner = id == 1 ? 2 : 1;
                            console.log(`ç©å®¶${id}æ‰å‡ºæ¸¸æˆç•Œé¢ - ä½ç½®: (${Math.round(player.x)}, ${Math.round(player.y)}), ç•Œé¢é«˜åº¦: ${this.canvas.height}`);
                            this.showFallOutMessage(id, true);
                            setTimeout(() => {
                                this.gameOver(winner);
                            }, 1500);
                        }
                        return;
                    }
                });
            }
            
            analyzePlayerCraterSituation(player) {
                // é‡æ–°è®¾è®¡çš„ç²¾ç¡®æ·±å‘åˆ†æ
                const currentHeight = this.getTerrainHeight(player.x);
                const originalHeight = this.getOriginalTerrainHeight(player.x);
                
                // è®¡ç®—å¼¹å‘æ·±åº¦ï¼šå½“å‰åœ°å½¢é«˜åº¦ - åŸå§‹åœ°å½¢é«˜åº¦
                const actualDepth = currentHeight - originalHeight;
                
                // ç©å®¶è„šåº•ä½ç½®ï¼ˆç©å®¶ä¸­å¿ƒY + 10ï¼Œå› ä¸ºç©å®¶é«˜åº¦20ï¼‰
                const playerBottomY = player.y + 10;
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å¼¹å‘ä¸­ï¼ˆå¼¹å‘æ·±åº¦è¶…è¿‡40åƒç´ ä¸”ç©å®¶åœ¨å‘å†…ï¼‰
                const inCrater = actualDepth > 40 && playerBottomY > originalHeight;
                
                // æ£€æŸ¥ç©å®¶ä¸å‘åº•çš„è·ç¦»
                const distanceToBottom = Math.abs(playerBottomY - currentHeight);
                const nearBottom = distanceToBottom < 30; // è·ç¦»å‘åº•30åƒç´ å†…
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ·±å‘ï¼ˆæ·±åº¦è¶…è¿‡80åƒç´ ï¼‰
                const isDeepCrater = actualDepth > 80;
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å‘ä¸­ä¸”æ— æ³•è½»æ˜“é€ƒè„±
                const trapped = inCrater && this.isPlayerTrappedInCrater(player, actualDepth);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­£åœ¨ä¸‹è½åˆ°æ·±å‘ä¸­
                const fallingIntoDeepCrater = !player.onGround && 
                                            playerBottomY > originalHeight - 10 && 
                                            playerBottomY < currentHeight + 20 &&
                                            isDeepCrater;
                
                // ç»¼åˆåˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘æ·±å‘æ¸¸æˆç»“æŸ
                const shouldTriggerGameOver = (isDeepCrater && (nearBottom || trapped)) || fallingIntoDeepCrater;
                
                return {
                    inCrater,
                    nearBottom,
                    actualDepth,
                    isDeepCrater,
                    trapped,
                    fallingIntoDeepCrater,
                    shouldTriggerGameOver,
                    playerBottomY,
                    currentHeight,
                    originalHeight
                };
            }
            
            isPlayerTrappedInCrater(player, craterDepth) {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦è¢«å›°åœ¨æ·±å‘ä¸­ï¼Œæ— æ³•è½»æ˜“é€ƒè„±
                if (craterDepth < 60) return false; // æµ…å‘ä¸ç®—è¢«å›°
                
                const escapeDistance = 100; // é€ƒè„±æ£€æŸ¥è·ç¦»
                const maxClimbHeight = 40; // ç©å®¶èƒ½çˆ¬çš„æœ€å¤§é«˜åº¦å·®
                
                // æ£€æŸ¥å·¦å³ä¸¤ä¸ªæ–¹å‘æ˜¯å¦æœ‰é€ƒè„±è·¯å¾„
                for (let direction of [-1, 1]) {
                    let canEscape = false;
                    
                    // é€æ­¥æ£€æŸ¥é€ƒè„±è·¯å¾„
                    for (let step = 20; step <= escapeDistance; step += 20) {
                        const checkX = player.x + direction * step;
                        
                        // è¾¹ç•Œæ£€æŸ¥
                        if (checkX < 50 || checkX > this.canvas.width - 50) break;
                        
                        const checkCurrentHeight = this.getTerrainHeight(checkX);
                        const checkOriginalHeight = this.getOriginalTerrainHeight(checkX);
                        const checkCraterDepth = checkCurrentHeight - checkOriginalHeight;
                        
                        // å¦‚æœæ‰¾åˆ°æ˜æ˜¾æ›´æµ…çš„ä½ç½®
                        if (checkCraterDepth < craterDepth - 30) {
                            // æ£€æŸ¥ä»å½“å‰ä½ç½®åˆ°è¿™ä¸ªä½ç½®çš„å¡åº¦æ˜¯å¦å¯çˆ¬
                            const playerCurrentHeight = this.getTerrainHeight(player.x);
                            const heightDiff = checkCurrentHeight - playerCurrentHeight;
                            
                            // å¦‚æœé«˜åº¦å·®åœ¨å¯çˆ¬èŒƒå›´å†…ï¼Œæ‰¾åˆ°é€ƒè„±è·¯å¾„
                            if (Math.abs(heightDiff) <= maxClimbHeight) {
                                canEscape = true;
                                break;
                            }
                        }
                    }
                    
                    if (canEscape) return false; // æ‰¾åˆ°é€ƒè„±è·¯å¾„ï¼Œä¸ç®—è¢«å›°
                }
                
                return true; // ä¸¤ä¸ªæ–¹å‘éƒ½æ— æ³•é€ƒè„±ï¼Œç®—è¢«å›°
            }
            
            isPlayerTrapped(player, currentHeight, originalHeight) {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦è¢«å›°åœ¨å¼¹å‘ä¸­ï¼ˆå‘¨å›´åœ°å½¢éƒ½æ¯”è¾ƒé«˜ï¼‰
                const actualDepth = currentHeight - originalHeight;
                
                // åªæœ‰åœ¨çœŸæ­£çš„å¼¹å‘ä¸­æ‰æ£€æŸ¥æ˜¯å¦è¢«å›°
                if (actualDepth < 40) return false;
                
                const checkRadius = 120; // æ£€æŸ¥åŠå¾„
                const escapeThreshold = Math.min(actualDepth * 0.7, 50); // åŠ¨æ€é€ƒè„±é˜ˆå€¼
                
                let canEscape = false;
                
                // æ£€æŸ¥å·¦å³æ–¹å‘æ˜¯å¦æœ‰é€ƒè„±è·¯å¾„
                for (let direction of [-1, 1]) {
                    for (let distance = 40; distance <= checkRadius; distance += 25) {
                        const checkX = player.x + direction * distance;
                        if (checkX < 50 || checkX > this.canvas.width - 50) continue;
                        
                        const checkHeight = this.getTerrainHeight(checkX);
                        const checkOriginal = this.getOriginalTerrainHeight(checkX);
                        const checkDepth = checkHeight - checkOriginal;
                        
                        // å¦‚æœæ‰¾åˆ°æ·±åº¦æ˜æ˜¾æ›´æµ…çš„ä½ç½®ï¼ˆé€ƒè„±è·¯å¾„ï¼‰
                        if (checkDepth < actualDepth - escapeThreshold) {
                            canEscape = true;
                            break;
                        }
                    }
                    if (canEscape) break;
                }
                
                return !canEscape && actualDepth > 60;
            }
            
            checkEscapeability(player, currentHeight, originalHeight) {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ— æ³•ä»å½“å‰ä½ç½®é€ƒè„±
                const actualDepth = currentHeight - originalHeight;
                
                // å¦‚æœå¼¹å‘ä¸å¤Ÿæ·±ï¼Œä¸ç®—æ— æ³•é€ƒè„±
                if (actualDepth < 60) return false;
                
                const playerBottomY = player.y + 10; // ç©å®¶åº•éƒ¨ä½ç½®
                const craterBottomY = currentHeight - 20; // å¼¹å‘åº•éƒ¨ä½ç½®
                
                // ç©å®¶å¿…é¡»åœ¨å¼¹å‘åº•éƒ¨é™„è¿‘
                if (Math.abs(playerBottomY - craterBottomY) > 30) return false;
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦èƒ½å¤Ÿé€šè¿‡ç§»åŠ¨é€ƒå‡ºå¼¹å‘
                const escapeDistance = 80; // é€ƒè„±æ£€æŸ¥è·ç¦»
                
                for (let direction of [-1, 1]) {
                    let canClimbOut = true;
                    
                    // æ£€æŸ¥é€ƒè„±è·¯å¾„ä¸Šçš„åœ°å½¢å¡åº¦
                    for (let step = 20; step <= escapeDistance; step += 20) {
                        const checkX = player.x + direction * step;
                        if (checkX < 50 || checkX > this.canvas.width - 50) {
                            canClimbOut = false;
                            break;
                        }
                        
                        const checkHeight = this.getTerrainHeight(checkX);
                        const heightDiff = checkHeight - currentHeight;
                        const maxClimbableHeight = step * 0.8; // å¯æ”€çˆ¬çš„æœ€å¤§é«˜åº¦
                        
                        // å¦‚æœå¡åº¦å¤ªé™¡ï¼Œæ— æ³•æ”€çˆ¬
                        if (heightDiff > maxClimbableHeight) {
                            canClimbOut = false;
                            break;
                        }
                    }
                    
                    if (canClimbOut) return false; // æ‰¾åˆ°é€ƒè„±è·¯å¾„
                }
                
                return true; // æ— æ³•é€ƒè„±
            }
            
            showFallOutMessage(playerId, isDeepCrater = false) {
                const player = this.players[playerId];
                const message = isDeepCrater ? 'æ‰å…¥æ·±å‘!' : 'æ‰å‡ºç•Œé¢!';
                
                // æ ¹æ®æ¸¸æˆæ¨¡å¼æ˜¾ç¤ºä¸åŒçš„æ¶ˆæ¯
                let displayText = '';
                if (this.gameMode === 'single') {
                    displayText = playerId == 1 ? `ä½  ${message}` : `AI ${message}`;
                } else {
                    displayText = `ç©å®¶${playerId} ${message}`;
                }
                
                // åˆ›å»ºæ‰è½æç¤º
                const notification = document.createElement('div');
                notification.textContent = displayText;
                notification.style.position = 'absolute';
                notification.style.left = '50%';
                notification.style.top = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.color = '#FF0000';
                notification.style.fontWeight = 'bold';
                notification.style.fontSize = '24px';
                notification.style.pointerEvents = 'none';
                notification.style.zIndex = '1000';
                notification.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                notification.style.background = 'rgba(0,0,0,0.7)';
                notification.style.padding = '20px 40px';
                notification.style.borderRadius = '10px';
                notification.style.animation = 'pulse 0.5s infinite';
                
                document.body.appendChild(notification);
                
                // 1.5ç§’åç§»é™¤æç¤º
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 1500);
            }
            
            gameOver(winner) {
                this.gameState = 'gameOver';
                document.getElementById('winnerText').textContent = `ç©å®¶${winner}è·èƒœ!`;
                document.getElementById('gameOver').style.display = 'flex';
            }
            
            restart() {
                // é‡ç½®æ¸¸æˆæ ¸å¿ƒçŠ¶æ€
                this.gameState = 'playing';
                this.currentPlayer = 1;
                this.isCharging = false;
                this.chargePower = 0;
                this.turnTimeLeft = 20;
                this.isTurnActive = false; // å…ˆè®¾ä¸ºfalseï¼ŒstartTurnä¼šè®¾ä¸ºtrue
                
                // æ¸…ç†æ¸¸æˆå¯¹è±¡
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = [];
                this.burnEffects = [];
                this.craters = [];
                this.obstacles = [];
                
                // æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
                clearInterval(this.turnTimer);
                clearInterval(this.chargeInterval);
                clearInterval(this.flyChargeInterval);
                this.turnTimer = null;
                this.chargeInterval = null;
                this.flyChargeInterval = null;
                
                // é‡ç½®ç©å®¶çŠ¶æ€
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    player.hp = player.maxHP;
                    player.x = id == 1 ? 100 : 900;
                    player.y = 500;
                    
                    // æ¸…é™¤æ‰€æœ‰çŠ¶æ€
                    delete player.burning;
                    player.isFlying = false;
                    player.flyMode = false;
                    player.flyPower = 0;
                    player.flyVelocityX = 0;
                    player.flyVelocityY = 0;
                    player.onGround = true;
                    player.hasFlownThisTurn = false;
                    player.isChargingFly = false;
                    player.standingOnObstacle = false;
                    player.currentSupportingObstacle = null;
                    player.skipPhysicsThisFrame = false;
                });
                
                // é‡æ–°ç”Ÿæˆåœ°å½¢å’Œéšœç¢ç‰©
                this.generateTerrain();
                
                // éšè—æ‰€æœ‰UIå…ƒç´ 
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('weaponSelector').style.display = 'none';
                document.getElementById('powerMeter').style.display = 'none';
                document.getElementById('flyMeter').style.display = 'none';
                document.getElementById('turnNotification').style.display = 'none';
                
                // æœ€åå¯åŠ¨æ–°å›åˆ
                setTimeout(() => {
                    this.startTurn();
                }, 100); // ç»™ä¸€ä¸ªå°å»¶è¿Ÿç¡®ä¿æ‰€æœ‰çŠ¶æ€éƒ½å·²é‡ç½®
            }
            
            updateUI() {
                const currentTurnElement = document.getElementById('currentTurn');
                const turnTimerElement = document.getElementById('turnTimer');
                const player = this.players[this.currentPlayer];
                
                let playerStatus = '';
                if (this.gameMode === 'single') {
                    if (this.currentPlayer === 1) {
                        playerStatus = 'ä½ çš„å›åˆ';
                    } else {
                        const difficultyNames = {
                            'easy': 'åˆçº§AI',
                            'medium': 'ä¸­çº§AI', 
                            'hard': 'é«˜çº§AI'
                        };
                        playerStatus = `${difficultyNames[this.aiDifficulty]}æ€è€ƒä¸­...`;
                    }
                } else {
                    playerStatus = `ç©å®¶${this.currentPlayer}å›åˆ`;
                }
                
                if (player.flyMode) {
                    if (player.hasFlownThisTurn) {
                        playerStatus += ' (å·²é£è¡Œ)';
                    } else {
                        playerStatus += ' (é£è¡Œæ¨¡å¼)';
                    }
                }
                currentTurnElement.textContent = playerStatus;
                currentTurnElement.style.color = this.players[this.currentPlayer].color;
                
                // æ›´æ–°å€’è®¡æ—¶
                if (this.isTurnActive) {
                    turnTimerElement.textContent = `å‰©ä½™æ—¶é—´: ${this.turnTimeLeft}ç§’`;
                    if (this.turnTimeLeft <= 5) {
                        turnTimerElement.style.color = '#FF0000';
                        turnTimerElement.style.animation = 'pulse 0.5s infinite';
                    } else {
                        turnTimerElement.style.color = '#FFD700';
                        turnTimerElement.style.animation = 'none';
                    }
                } else {
                    turnTimerElement.textContent = 'ç­‰å¾…ä¸­...';
                    turnTimerElement.style.color = '#888';
                    turnTimerElement.style.animation = 'none';
                }
                
                document.getElementById('currentWeapon').textContent = 
                    this.weapons[this.players[this.currentPlayer].selectedWeapon].name;
                
                // æ›´æ–°è¡€é‡
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    const percentage = (player.hp / player.maxHP) * 100;
                    document.getElementById(`player${id}HP`).textContent = player.hp;
                    document.getElementById(`player${id}HPBar`).style.width = percentage + '%';
                });
            }
            
            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // è°ƒè¯•ä¿¡æ¯ï¼šæ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®è¦ç»˜åˆ¶
                if (!this.terrain) {
                    console.warn('åœ°å½¢æ•°æ®ä¸å­˜åœ¨');
                    return;
                }
                
                if (!this.players) {
                    console.warn('ç©å®¶æ•°æ®ä¸å­˜åœ¨');
                    return;
                }
                
                // ç»˜åˆ¶åœ°å½¢
                this.drawTerrain();
                
                // ç»˜åˆ¶ç«ç„°åŒºåŸŸ
                this.drawFireZones();
                
                // ç»˜åˆ¶éšœç¢ç‰©
                this.drawObstacles();
                
                // ç»˜åˆ¶ç©å®¶
                this.drawPlayers();
                
                // ç»˜åˆ¶å¼¹é“
                this.drawProjectiles();
                
                // ç»˜åˆ¶çˆ†ç‚¸
                this.drawExplosions();
                
                // ç»˜åˆ¶ç²’å­
                this.drawParticles();
                
                // ç»˜åˆ¶ç‰©ç†çŠ¶æ€ä¿¡æ¯
                this.drawPhysicsStatus();
            }
            
            drawTerrain() {
                // è°ƒè¯•ä¿¡æ¯
                if (!this.terrain || this.terrain.length === 0) {
                    console.warn('drawTerrain: åœ°å½¢æ•°æ®ä¸ºç©º');
                    return;
                }
                
                // ç»˜åˆ¶åŸºç¡€åœ°å½¢ï¼ˆåœŸå£¤ï¼‰ï¼Œä½¿ç”¨å½“å‰ä¸»é¢˜é¢œè‰²
                const groundColor = this.currentTheme ? this.currentTheme.ground : '#8B4513';
                this.ctx.fillStyle = groundColor;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height);
                
                // ç»˜åˆ¶çœŸå®åœ°å½¢è½®å»“
                this.terrain.forEach(point => {
                    this.ctx.lineTo(point.x, point.height);
                });
                
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // ç»˜åˆ¶åœ°è¡¨ï¼Œé¢œè‰²æ ¹æ®ä¸»é¢˜è°ƒæ•´
                let surfaceColor = '#228B22'; // é»˜è®¤ç»¿è‰²
                if (this.currentTheme) {
                    switch(this.currentTheme.name) {
                        case 'desert':
                            surfaceColor = '#F4A460'; // æ²™è‰²
                            break;
                        case 'arctic':
                            surfaceColor = '#FFFFFF'; // ç™½è‰²
                            break;
                        case 'night':
                            surfaceColor = '#2F4F4F'; // æ·±ç°è‰²
                            break;
                        case 'alien':
                            surfaceColor = '#9370DB'; // ç´«è‰²
                            break;
                        case 'forest':
                            surfaceColor = '#228B22'; // æ·±ç»¿è‰²
                            break;
                        default:
                            surfaceColor = '#228B22'; // é»˜è®¤ç»¿è‰²
                    }
                }
                
                this.ctx.fillStyle = surfaceColor;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height);
                
                this.terrain.forEach(point => {
                    this.ctx.lineTo(point.x, point.height);
                });
                
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // ç»˜åˆ¶å¼¹å‘è§†è§‰æ•ˆæœ
                this.drawCraterEffects();
            }
            
            drawPlayers() {
                if (!this.players) {
                    console.warn('drawPlayers: ç©å®¶æ•°æ®ä¸å­˜åœ¨');
                    return;
                }
                
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    
                    if (!player) {
                        console.warn(`drawPlayers: ç©å®¶${id}æ•°æ®ä¸å­˜åœ¨`);
                        return;
                    }
                    
                    // ç»˜åˆ¶ç©å®¶
                    this.ctx.fillStyle = player.color;
                    this.ctx.fillRect(player.x - 10, player.y - 10, 20, 20);
                    
                    // å¦‚æœç©å®¶ç«™åœ¨éšœç¢ç‰©ä¸Šï¼Œç»˜åˆ¶ç‰¹æ®ŠæŒ‡ç¤º
                    if (player.standingOnObstacle) {
                        this.ctx.strokeStyle = '#FFD700';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(player.x, player.y, 16, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // ç»˜åˆ¶å°çš„å¹³å°æŒ‡ç¤º
                        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        this.ctx.fillRect(player.x - 12, player.y + 12, 24, 3);
                    }
                    
                    // å¦‚æœç©å®¶åœ¨é£è¡Œï¼Œç»˜åˆ¶é£è¡Œæ•ˆæœ
                    if (player.isFlying) {
                        this.ctx.fillStyle = 'rgba(135, 206, 235, 0.5)';
                        this.ctx.fillRect(player.x - 15, player.y - 15, 30, 30);
                        
                        // ç»˜åˆ¶é£è¡Œè½¨è¿¹
                        this.ctx.strokeStyle = 'rgba(135, 206, 235, 0.8)';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    // å¦‚æœç©å®¶åœ¨ç‡ƒçƒ§ï¼Œç»˜åˆ¶ç«ç„°æ•ˆæœ
                    if (player.burning) {
                        this.ctx.fillStyle = '#FF6347';
                        this.ctx.globalAlpha = 0.7;
                        this.ctx.fillRect(player.x - 12, player.y - 12, 24, 24);
                        this.ctx.globalAlpha = 1;
                    }
                    
                    // ç»˜åˆ¶ç‚®ç®¡æ–¹å‘
                    if (id == this.currentPlayer && this.isTurnActive) {
                        const radians = (player.angle * Math.PI) / 180;
                        const endX = player.x + Math.cos(radians) * 30;
                        const endY = player.y - Math.sin(radians) * 30;
                        
                        // æ ¹æ®æ¨¡å¼æ”¹å˜ç‚®ç®¡é¢œè‰²
                        this.ctx.strokeStyle = player.flyMode ? '#87CEEB' : player.color;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                        
                        // ç»˜åˆ¶è§’åº¦èŒƒå›´æŒ‡ç¤ºå™¨ï¼ˆåŠé€æ˜æ‰‡å½¢ï¼‰
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.arc(player.x, player.y, 40, 0, Math.PI, false);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // ç»˜åˆ¶0Â°å’Œ180Â°è¾¹ç•Œçº¿
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 1;
                        this.ctx.setLineDash([5, 5]);
                        
                        // 0Â°çº¿ï¼ˆå‘å³ï¼‰
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(player.x + 35, player.y);
                        this.ctx.stroke();
                        
                        // 180Â°çº¿ï¼ˆå‘å·¦ï¼‰
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(player.x - 35, player.y);
                        this.ctx.stroke();
                        
                        this.ctx.setLineDash([]); // é‡ç½®è™šçº¿
                        
                        // ç»˜åˆ¶è§’åº¦æ ‡è®°
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'center';
                        
                        // 0Â°æ ‡è®°
                        this.ctx.fillText('0Â°', player.x + 45, player.y + 3);
                        // 90Â°æ ‡è®°
                        this.ctx.fillText('90Â°', player.x, player.y - 45);
                        // 180Â°æ ‡è®°
                        this.ctx.fillText('180Â°', player.x - 45, player.y + 3);
                    }
                    
                    // ç»˜åˆ¶ç©å®¶ç¼–å·
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(id, player.x, player.y + 5);
                    
                    // å¦‚æœæ˜¯é£è¡Œæ¨¡å¼ï¼Œåœ¨ç©å®¶ä¸Šæ–¹æ˜¾ç¤ºæç¤º
                    if (player.flyMode && id == this.currentPlayer) {
                        this.ctx.fillStyle = player.hasFlownThisTurn ? '#888888' : '#87CEEB';
                        this.ctx.font = 'bold 12px Arial';
                        const text = player.hasFlownThisTurn ? 'å·²é£è¡Œ' : 'é£è¡Œ';
                        this.ctx.fillText(text, player.x, player.y - 25);
                    }
                });
            }
            
            drawProjectiles() {
                this.projectiles.forEach(proj => {
                    // ç»˜åˆ¶è½¨è¿¹
                    if (proj.trail.length > 1) {
                        this.ctx.strokeStyle = proj.weapon.color;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(proj.trail[0].x, proj.trail[0].y);
                        
                        for (let i = 1; i < proj.trail.length; i++) {
                            this.ctx.lineTo(proj.trail[i].x, proj.trail[i].y);
                        }
                        this.ctx.stroke();
                    }
                    
                    // ç»˜åˆ¶å¼¹å¤´
                    this.ctx.fillStyle = proj.weapon.color;
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawExplosions() {
                this.explosions.forEach(explosion => {
                    const alpha = explosion.life / 30;
                    this.ctx.fillStyle = explosion.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    this.ctx.beginPath();
                    this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    this.ctx.beginPath();
                    const size = particle.size || 2; // ä½¿ç”¨ç²’å­çš„å¤§å°å±æ€§ï¼Œé»˜è®¤ä¸º2
                    this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawFireZones() {
                this.fireZones.forEach(zone => {
                    const alpha = zone.life / zone.maxLife;
                    
                    // ç»˜åˆ¶ç«ç„°åŒºåŸŸ
                    this.ctx.fillStyle = `rgba(255, 99, 71, ${alpha * 0.3})`;
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // ç»˜åˆ¶ç«ç„°è¾¹ç¼˜
                    this.ctx.strokeStyle = `rgba(255, 69, 0, ${alpha * 0.8})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // ç»˜åˆ¶è·³åŠ¨çš„ç«ç„°æ•ˆæœ
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * 45) * Math.PI / 180;
                        const flameLength = 10 + Math.random() * 15;
                        const startX = zone.x + Math.cos(angle) * (zone.radius - 5);
                        const startY = zone.y + Math.sin(angle) * (zone.radius - 5);
                        const endX = startX + Math.cos(angle) * flameLength;
                        const endY = startY + Math.sin(angle) * flameLength;
                        
                        this.ctx.strokeStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha * 0.6})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                    }
                });
            }
            
            drawCraterEffects() {
                this.craters.forEach(crater => {
                    crater.age++; // å¢åŠ å¼¹å‘å¹´é¾„
                    
                    // è®¡ç®—é€æ˜åº¦ï¼ˆæ–°å¼¹å‘æ›´æ˜æ˜¾ï¼‰
                    const maxAge = 300; // 5ç§’åå®Œå…¨æ·¡åŒ–
                    const alpha = Math.max(0, 1 - crater.age / maxAge);
                    
                    if (alpha > 0) {
                        // ç»˜åˆ¶å¼¹å‘é˜´å½±
                        this.ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                        this.ctx.beginPath();
                        this.ctx.ellipse(crater.x, crater.y + 15, crater.radius * 1.0, crater.radius * 0.3, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // ç»˜åˆ¶å¼¹å‘è¾¹ç¼˜åœŸè‰²é«˜å…‰
                        this.ctx.strokeStyle = `rgba(139, 69, 19, ${alpha * 0.9})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.95, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // ç»˜åˆ¶å¼¹å‘å†…éƒ¨æ·±è‰²åŒºåŸŸ
                        this.ctx.fillStyle = `rgba(101, 67, 33, ${alpha * 0.6})`;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.7, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // ç»˜åˆ¶å¼¹å‘æœ€æ·±å¤„
                        this.ctx.fillStyle = `rgba(80, 50, 20, ${alpha * 0.7})`;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // æ–°å¼¹å‘æœ‰çƒŸé›¾æ•ˆæœ
                        if (crater.age < 60) {
                            this.drawCraterSmoke(crater, alpha);
                        }
                    }
                });
                
                // æ¸…ç†è€åŒ–çš„å¼¹å‘è§†è§‰æ•ˆæœ
                this.craters = this.craters.filter(crater => crater.age < 300);
            }
            
            drawCraterSmoke(crater, alpha) {
                // ç»˜åˆ¶å¼¹å‘çƒŸé›¾æ•ˆæœ
                const smokeParticles = 5;
                for (let i = 0; i < smokeParticles; i++) {
                    const angle = (crater.age * 0.1 + i * (Math.PI * 2 / smokeParticles)) % (Math.PI * 2);
                    const distance = crater.radius * 0.3 + Math.sin(crater.age * 0.05 + i) * 10;
                    const x = crater.x + Math.cos(angle) * distance;
                    const y = crater.y - crater.age * 0.5 + Math.sin(crater.age * 0.1 + i) * 5;
                    
                    const smokeAlpha = alpha * (1 - crater.age / 60) * 0.3;
                    this.ctx.fillStyle = `rgba(100, 100, 100, ${smokeAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3 + Math.sin(crater.age * 0.1 + i) * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawObstacles() {
                // å€’åºéå†ä»¥å®‰å…¨åˆ é™¤å…ƒç´ 
                for (let obstacleIndex = this.obstacles.length - 1; obstacleIndex >= 0; obstacleIndex--) {
                    const obstacle = this.obstacles[obstacleIndex];
                    
                    // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦åº”è¯¥è¢«ç§»é™¤ï¼ˆè¢«æ¶ˆè€—å®Œæ¯•ï¼‰
                    if (this.checkObstacleDestruction(obstacle, obstacleIndex)) {
                        continue; // å¦‚æœè¢«ç§»é™¤ï¼Œè·³è¿‡ç»˜åˆ¶
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰ç©å®¶çš„æ”¯æ’‘éšœç¢ç‰©
                    const currentPlayer = this.players[this.currentPlayer];
                    const isSupporting = (currentPlayer.currentSupportingObstacle === obstacle);
                    
                    // ä½¿ç”¨å‰ªåˆ‡è·¯å¾„æ¥åˆ›å»ºå˜å½¢æ•ˆæœ
                    this.ctx.save();
                    
                    // ç»˜åˆ¶ä¸åŒç±»å‹çš„éšœç¢ç‰©
                    this.drawObstacleByType(obstacle, isSupporting);
                    
                    this.ctx.restore();
                }
            }
            
            drawObstacleByType(obstacle, isSupporting) {
                // æ ¹æ®éšœç¢ç‰©ç±»å‹å’Œä¸»é¢˜ç»˜åˆ¶ä¸åŒçš„å¤–è§‚
                
                // åˆ›å»ºåŸºæœ¬å½¢çŠ¶è·¯å¾„å¹¶å¤„ç†å¼¹å‘
                this.ctx.beginPath();
                
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                    case 'moon_rock':
                        this.ctx.rect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                        break;
                        
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        break;
                        
                    case 'crystal':
                        // æ°´æ™¶å½¢çŠ¶ - å…­è¾¹å½¢
                        const sides = 6;
                        const radius = obstacle.width / 2;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const x = obstacle.x + radius * Math.cos(angle);
                            const y = obstacle.y + radius * Math.sin(angle);
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        break;
                        
                    case 'tree_platform':
                    case 'mushroom':
                        // åœ†å½¢å¹³å°
                        this.ctx.arc(obstacle.x, obstacle.y, obstacle.width/2, 0, Math.PI * 2);
                        break;
                        
                    default:
                        this.ctx.rect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                }
                
                // ä»åŸºæœ¬å½¢çŠ¶ä¸­å‡å»å¼¹å‘
                obstacle.craters.forEach(crater => {
                    const worldX = obstacle.x + crater.x;
                    const worldY = obstacle.y + crater.y;
                    
                    if (worldX >= obstacle.x - obstacle.width/2 && worldX <= obstacle.x + obstacle.width/2 &&
                        worldY >= obstacle.y - obstacle.height/2 && worldY <= obstacle.y + obstacle.height/2) {
                        this.ctx.arc(worldX, worldY, crater.radius, 0, Math.PI * 2, true);
                    }
                });
                
                this.ctx.clip();
                
                // æ ¹æ®ç±»å‹å’Œä¸»é¢˜é€‰æ‹©é¢œè‰²
                const colors = this.getObstacleColors(obstacle.type, obstacle.theme);
                
                // ç»˜åˆ¶ä¸»ä½“
                this.ctx.fillStyle = colors.main;
                this.drawObstacleShape(obstacle);
                
                // ç»˜åˆ¶é¡¶éƒ¨é«˜äº®
                if (isSupporting) {
                    this.ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                } else {
                    this.ctx.fillStyle = colors.highlight;
                }
                this.drawObstacleHighlight(obstacle);
                
                // ç»˜åˆ¶çº¹ç†å’Œè£…é¥°
                this.drawObstacleTexture(obstacle, colors);
            }
            
            getObstacleColors(type, theme) {
                const colorSchemes = {
                    platform: { main: '#8B7355', highlight: 'rgba(139, 115, 85, 0.8)', texture: 'rgba(101, 67, 33, 0.4)' },
                    cloud: { main: 'rgba(255, 255, 255, 0.9)', highlight: 'rgba(255, 255, 255, 1)', texture: 'rgba(200, 200, 200, 0.8)' },
                    iceberg: { main: '#E0FFFF', highlight: '#F0F8FF', texture: 'rgba(176, 224, 230, 0.6)' },
                    rock: { main: '#8B7355', highlight: '#A0522D', texture: 'rgba(139, 69, 19, 0.5)' },
                    crystal: { main: '#9370DB', highlight: '#BA55D3', texture: 'rgba(138, 43, 226, 0.3)' },
                    tree_platform: { main: '#8FBC8F', highlight: '#98FB98', texture: 'rgba(34, 139, 34, 0.4)' },
                    mushroom: { main: '#F4A460', highlight: '#DEB887', texture: 'rgba(210, 180, 140, 0.5)' },
                    moon_rock: { main: '#708090', highlight: '#778899', texture: 'rgba(105, 105, 105, 0.4)' },
                    cactus: { main: '#228B22', highlight: '#32CD32', texture: 'rgba(0, 100, 0, 0.3)' },
                    floating_rock: { main: '#4B0082', highlight: '#6A0DAD', texture: 'rgba(75, 0, 130, 0.3)' }
                };
                
                return colorSchemes[type] || colorSchemes.platform;
            }
            
            drawObstacleShape(obstacle) {
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                    case 'moon_rock':
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                        break;
                        
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'crystal':
                        this.ctx.beginPath();
                        const sides = 6;
                        const radius = obstacle.width / 2;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const x = obstacle.x + radius * Math.cos(angle);
                            const y = obstacle.y + radius * Math.sin(angle);
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                        
                    case 'tree_platform':
                    case 'mushroom':
                        this.ctx.beginPath();
                        this.ctx.arc(obstacle.x, obstacle.y, obstacle.width/2, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    default:
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                }
            }
            
            drawObstacleHighlight(obstacle) {
                switch(obstacle.type) {
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y - obstacle.height/3, obstacle.width/2.2, obstacle.height/6, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    default:
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            4
                        );
                }
            }
            
            drawObstacleTexture(obstacle, colors) {
                this.ctx.fillStyle = colors.texture;
                
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                        // çŸ³å¤´çº¹ç†
                        const textureCount = Math.floor(obstacle.width / 30);
                        for (let i = 0; i < textureCount; i++) {
                            const tx = obstacle.x - obstacle.width/2 + (i + 0.5) * obstacle.width/textureCount;
                            const ty = obstacle.y - obstacle.height/2 + obstacle.height/2;
                            this.ctx.fillRect(tx - 2, ty - 2, 4, 4);
                        }
                        break;
                        
                    case 'crystal':
                        // æ°´æ™¶å…‰æ³½
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.fillRect(obstacle.x - 5, obstacle.y - obstacle.height/3, 10, obstacle.height/3);
                        break;
                        
                    case 'cloud':
                        // äº‘æœµè¾¹ç¼˜
                        this.ctx.strokeStyle = colors.texture;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        this.ctx.stroke();
                        break;
                        
                    case 'tree_platform':
                        // æ ‘å¶çº¹ç†
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * 120) * Math.PI / 180;
                            const leafX = obstacle.x + Math.cos(angle) * obstacle.width/4;
                            const leafY = obstacle.y + Math.sin(angle) * obstacle.height/4;
                            this.ctx.fillRect(leafX - 2, leafY - 2, 4, 4);
                        }
                        break;
                }
            }
            
            checkObstacleDestruction(obstacle, obstacleIndex) {
                // è®¡ç®—éšœç¢ç‰©çš„å‰©ä½™é¢ç§¯ï¼ˆä½¿ç”¨æ›´ç²¾ç¡®çš„è®¡ç®—æ–¹æ³•ï¼‰
                const originalArea = obstacle.width * obstacle.height;
                
                // ä½¿ç”¨é‡‡æ ·æ–¹æ³•è®¡ç®—å®é™…è¢«ç ´åçš„é¢ç§¯
                let destroyedPixels = 0;
                const sampleStep = 2; // æ¯2åƒç´ é‡‡æ ·ä¸€æ¬¡ï¼Œå¹³è¡¡ç²¾åº¦å’Œæ€§èƒ½
                
                for (let x = -obstacle.width/2; x < obstacle.width/2; x += sampleStep) {
                    for (let y = -obstacle.height/2; y < obstacle.height/2; y += sampleStep) {
                        // æ£€æŸ¥è¿™ä¸ªç‚¹æ˜¯å¦åœ¨ä»»ä½•å¼¹å‘å†…
                        let inCrater = false;
                        for (let crater of obstacle.craters) {
                            const distance = Math.sqrt(
                                Math.pow(x - crater.x, 2) + 
                                Math.pow(y - crater.y, 2)
                            );
                            if (distance <= crater.radius) {
                                inCrater = true;
                                break;
                            }
                        }
                        if (inCrater) {
                            destroyedPixels += sampleStep * sampleStep;
                        }
                    }
                }
                
                // å¦‚æœè¢«ç ´åçš„é¢ç§¯è¶…è¿‡80%ï¼Œåˆ™ç§»é™¤éšœç¢ç‰©
                const destructionRatio = destroyedPixels / originalArea;
                if (destructionRatio > 0.8) {
                    // åˆ›å»ºéšœç¢ç‰©å®Œå…¨æ‘§æ¯çš„ç²’å­æ•ˆæœ
                    this.createObstacleDestructionEffect(obstacle);
                    
                    // ä»æ•°ç»„ä¸­ç§»é™¤éšœç¢ç‰©
                    this.obstacles.splice(obstacleIndex, 1);
                    return true; // è¿”å›trueè¡¨ç¤ºéšœç¢ç‰©è¢«ç§»é™¤
                }
                return false; // è¿”å›falseè¡¨ç¤ºéšœç¢ç‰©ä»ç„¶å­˜åœ¨
            }
            
            createObstacleDestructionEffect(obstacle) {
                // åˆ›å»ºå¤§é‡ç ´åç²’å­
                const particleCount = obstacle.type === 'platform' ? 20 : 15;
                const baseColor = obstacle.type === 'platform' ? '#8B7355' : '#E0E0E0';
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: obstacle.x + (Math.random() - 0.5) * obstacle.width,
                        y: obstacle.y + (Math.random() - 0.5) * obstacle.height,
                        vx: (Math.random() - 0.5) * 15,
                        vy: -Math.random() * 10 - 3,
                        color: baseColor,
                        life: 80 + Math.random() * 50,
                        maxLife: 80 + Math.random() * 50,
                        size: 2 + Math.random() * 3
                    });
                }
                
                // æ·»åŠ ä¸€äº›ç‰¹æ®Šçš„ç ´åæ•ˆæœ
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: obstacle.x,
                        y: obstacle.y,
                        vx: Math.cos(i * Math.PI / 4) * 12,
                        vy: Math.sin(i * Math.PI / 4) * 12,
                        color: obstacle.type === 'platform' ? '#654321' : '#C0C0C0',
                        life: 60,
                        maxLife: 60,
                        size: 4
                    });
                }
            }
            
            drawPhysicsStatus() {
                // ç»˜åˆ¶å½“å‰ç©å®¶çš„ç‰©ç†çŠ¶æ€
                const currentPlayer = this.players[this.currentPlayer];
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                
                let statusText = '';
                let statusColor = '';
                
                if (currentPlayer.standingOnObstacle) {
                    statusText = 'çŠ¶æ€: ç«™åœ¨åˆšä½“å¹³å°ä¸Š';
                    statusColor = '#FFD700';
                } else if (currentPlayer.onGround) {
                    statusText = 'çŠ¶æ€: ç«™åœ¨åœ°é¢ä¸Š';
                    statusColor = '#90EE90';
                } else if (currentPlayer.isFlying) {
                    statusText = 'çŠ¶æ€: é£è¡Œä¸­';
                    statusColor = '#87CEEB';
                } else {
                    statusText = 'çŠ¶æ€: ç©ºä¸­ä¸‹è½';
                    statusColor = '#FFA500';
                }
                
                // ç»˜åˆ¶çŠ¶æ€èƒŒæ™¯
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, this.canvas.height - 70, 250, 50);
                
                // ç»˜åˆ¶çŠ¶æ€æ–‡å­—
                this.ctx.fillStyle = statusColor;
                this.ctx.fillText(statusText, 15, this.canvas.height - 50);
                
                // ç»˜åˆ¶è§’åº¦ä¿¡æ¯
                this.ctx.fillStyle = '#87CEEB';
                this.ctx.fillText(`å‘å°„è§’åº¦: ${Math.round(currentPlayer.angle)}Â° (èŒƒå›´: 0-180Â°)`, 15, this.canvas.height - 35);
                
                // ç»˜åˆ¶éšœç¢ç‰©æ•°é‡ä¿¡æ¯
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`åˆšä½“å¹³å°æ•°é‡: ${this.obstacles.length}`, 15, this.canvas.height - 20);
                
                // ç»˜åˆ¶å½“å‰æ”¯æ’‘éšœç¢ç‰©ä¿¡æ¯
                if (currentPlayer.currentSupportingObstacle) {
                    const obstacle = currentPlayer.currentSupportingObstacle;
                    this.ctx.fillText(`æ”¯æ’‘å¹³å°: ${obstacle.type} (${Math.round(obstacle.x)}, ${Math.round(obstacle.y)})`, 270, this.canvas.height - 50);
                }
            }
            
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // æ˜¾ç¤ºéš¾åº¦é€‰æ‹©ç•Œé¢
        function showDifficultySelect() {
            document.getElementById('gameModeScreen').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'flex';
        }

        // å…¨å±€å‡½æ•°ï¼šå¯åŠ¨æ¸¸æˆæ¨¡å¼
        function startGameMode(mode, difficulty = 'medium') {
            console.log('startGameModeè¢«è°ƒç”¨ï¼Œæ¨¡å¼:', mode, 'éš¾åº¦:', difficulty);
            console.log('æ£€æŸ¥window.game:', window.game);
            
            // å¦‚æœæ¸¸æˆå®ä¾‹ä¸å­˜åœ¨ï¼Œå°è¯•ç«‹å³åˆ›å»º
            if (!window.game) {
                console.log('æ¸¸æˆå®ä¾‹ä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»º...');
                try {
                    window.game = new TNTBattleGame();
                    console.log('æ¸¸æˆå®ä¾‹åˆ›å»ºæˆåŠŸ');
                } catch (error) {
                    console.error('åˆ›å»ºæ¸¸æˆå®ä¾‹å¤±è´¥:', error);
                    alert('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ' + error.message);
                    return;
                }
            }
            
            try {
                console.log('æ¸¸æˆå®ä¾‹å­˜åœ¨ï¼Œè°ƒç”¨startGame');
                window.game.startGame(mode, difficulty);
            } catch (error) {
                console.error('å¯åŠ¨æ¸¸æˆæ—¶å‡ºé”™:', error);
                alert('å¯åŠ¨æ¸¸æˆæ—¶å‡ºé”™: ' + error.message);
            }
        }

        // å…¨å±€å‡½æ•°ï¼šé‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            try {
                if (window.game && window.game.restart) {
                    window.game.restart();
                } else {
                    console.error('æ¸¸æˆå®ä¾‹æœªåˆå§‹åŒ–æˆ–restartæ–¹æ³•ä¸å­˜åœ¨');
                    alert('æ¸¸æˆæœªæ­£ç¡®åˆå§‹åŒ–');
                }
            } catch (error) {
                console.error('é‡æ–°å¼€å§‹æ¸¸æˆæ—¶å‡ºé”™:', error);
                alert('é‡æ–°å¼€å§‹æ¸¸æˆæ—¶å‡ºé”™: ' + error.message);
            }
        }

        // å…¨å±€å‡½æ•°ï¼šè¿”å›æ¨¡å¼é€‰æ‹©
        function backToModeSelect() {
            try {
                if (window.game && window.game.backToModeSelect) {
                    window.game.backToModeSelect();
                } else {
                    console.error('æ¸¸æˆå®ä¾‹æœªåˆå§‹åŒ–æˆ–backToModeSelectæ–¹æ³•ä¸å­˜åœ¨');
                    alert('æ¸¸æˆæœªæ­£ç¡®åˆå§‹åŒ–');
                }
            } catch (error) {
                console.error('è¿”å›æ¨¡å¼é€‰æ‹©æ—¶å‡ºé”™:', error);
                alert('è¿”å›æ¨¡å¼é€‰æ‹©æ—¶å‡ºé”™: ' + error.message);
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('load', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–æ¸¸æˆ');
            try {
                console.log('åˆ›å»ºTNTBattleGameå®ä¾‹...');
                window.game = new TNTBattleGame();
                console.log('æ¸¸æˆå®ä¾‹åˆ›å»ºæˆåŠŸ:', window.game);
                console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                alert('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        });

        // æ·»åŠ DOMContentLoadedäº‹ä»¶ç›‘å¬ï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMå†…å®¹åŠ è½½å®Œæˆ');
        });
    </script>
</body>
</html> 
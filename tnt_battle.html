<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TNT双人弹道大战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #98FB98, #8B4513);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-container {
            position: relative;
            width: 1000px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #228B22 60%, #8B4513 100%);
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            background: transparent;
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            color: white;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }

        .player1 {
            color: #4CAF50;
        }

        .player2 {
            color: #FF6B6B;
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-hp {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 150px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .hp-fill.player2 {
            background: linear-gradient(90deg, #FF6B6B, #FF8A8A);
        }

        .game-info {
            text-align: center;
            flex: 1;
        }

        .current-turn {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .turn-timer {
            font-size: 18px;
            color: #FFD700;
            margin-top: 5px;
            font-weight: bold;
        }

        .turn-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 3px solid #FFD700;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .weapon-info {
            font-size: 14px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .power-meter {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            display: none;
            align-items: center;
            padding: 5px;
        }

        .power-fill {
            height: 20px;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .power-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .fly-meter {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 25px;
            background: rgba(0,0,0,0.8);
            border-radius: 12px;
            display: none;
            align-items: center;
            padding: 3px;
        }

        .fly-fill {
            height: 19px;
            background: linear-gradient(90deg, #87CEEB, #4169E1, #0000FF);
            border-radius: 9px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .fly-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .controls {
            width: 1000px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            margin-top: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
        }
        
        .controls-grid > div {
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            line-height: 1.4;
        }
        
        .controls-tip {
            text-align: center;
            color: #87CEEB;
            font-size: 13px;
            border-top: 1px solid #444;
            padding-top: 8px;
        }

        .weapon-selector {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }

        .weapon-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .weapon-item {
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .weapon-item:hover {
            border-color: #4CAF50;
            background: rgba(255,255,255,0.2);
        }

        .weapon-item.selected {
            border-color: #FFD700;
            background: rgba(255,215,0,0.2);
        }

        .weapon-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .weapon-name {
            font-size: 14px;
            font-weight: bold;
        }

        .weapon-desc {
            font-size: 10px;
            color: #ccc;
            margin-top: 5px;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        .winner-text {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .restart-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
        }

        .explosion {
            position: absolute;
            pointer-events: none;
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .game-mode-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 2000;
        }

        .mode-title {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .mode-subtitle {
            font-size: 18px;
            margin-bottom: 40px;
            color: #87CEEB;
            line-height: 1.5;
        }

        .mode-options {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .mode-option {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 30px 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            position: relative;
            overflow: hidden;
        }

        .mode-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
            border-color: #FFD700;
        }

        .mode-option.ai-mode {
            background: linear-gradient(45deg, #FF6B6B, #FF8A8A);
        }

        .mode-option.ai-mode:hover {
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        }

        .mode-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .mode-option:hover::before {
            left: 100%;
        }

        .mode-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
        }

        .mode-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .mode-desc {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            line-height: 1.4;
        }

        .mode-features {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-top: 8px;
            font-style: italic;
        }

        .difficulty-easy {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
        }

        .difficulty-easy:hover {
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
        }

        .difficulty-medium {
            background: linear-gradient(45deg, #FF9800, #FFB74D);
        }

        .difficulty-medium:hover {
            box-shadow: 0 10px 25px rgba(255, 152, 0, 0.4);
        }

        .difficulty-hard {
            background: linear-gradient(45deg, #F44336, #EF5350);
        }

        .difficulty-hard:hover {
            box-shadow: 0 10px 25px rgba(244, 67, 54, 0.4);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <!-- UI面板 -->
        <div class="ui-panel">
            <div class="player-info player1">
                <div class="player-name" id="player1Name">玩家1 (WASD)</div>
                <div class="player-hp">HP: <span id="player1HP">100</span>/100</div>
                <div class="hp-bar">
                    <div class="hp-fill" id="player1HPBar" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="game-info">
                <div class="current-turn" id="currentTurn">玩家1回合</div>
                <div class="turn-timer" id="turnTimer">剩余时间: 10秒</div>
                <div class="weapon-info">
                    <span>武器: <span id="currentWeapon">普通炸弹</span></span>
                    <span>按Q切换武器</span>
                </div>
            </div>
            
            <div class="player-info player2">
                <div class="player-name" id="player2Name">玩家2 (方向键)</div>
                <div class="player-hp">HP: <span id="player2HP">100</span>/100</div>
                <div class="hp-bar">
                    <div class="hp-fill player2" id="player2HPBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- 力量条 -->
        <div class="power-meter" id="powerMeter">
            <div class="power-fill" id="powerFill"></div>
            <div class="power-text">按住空格键蓄力</div>
        </div>

        <!-- 飞行力量条 -->
        <div class="fly-meter" id="flyMeter">
            <div class="fly-fill" id="flyFill"></div>
            <div class="fly-text">按住空格键蓄力飞行</div>
        </div>

        <!-- 武器选择器 -->
        <div class="weapon-selector" id="weaponSelector">
            <h3>选择武器</h3>
            <div class="weapon-grid" id="weaponGrid">
                <!-- 武器选项将通过JS生成 -->
            </div>
            <p>按Q关闭</p>
        </div>



        <!-- 回合提示 -->
        <div class="turn-notification" id="turnNotification">
            <div id="turnNotificationText">玩家1的回合开始!</div>
        </div>

        <!-- 游戏模式选择界面 -->
        <div class="game-mode-screen" id="gameModeScreen">
            <div class="mode-title">TNT双人弹道大战</div>
            <div class="mode-subtitle">
                选择游戏模式开始你的战斗之旅<br>
                体验不同的游戏乐趣！
            </div>
            
            <div class="mode-options">
                <div class="mode-option ai-mode" onclick="showDifficultySelect()">
                    <span class="mode-icon">🤖</span>
                    <div class="mode-name">单人游戏</div>
                    <div class="mode-desc">
                        与智能AI对战<br>
                        挑战你的战术技巧
                    </div>
                    <div class="mode-features">
                        AI自动操作 • 策略挑战 • 技能提升
                    </div>
                </div>
                
                <div class="mode-option" onclick="startGameMode('multiplayer')">
                    <span class="mode-icon">👥</span>
                    <div class="mode-name">双人对战</div>
                    <div class="mode-desc">
                        与朋友面对面对战<br>
                        享受竞技的乐趣
                    </div>
                    <div class="mode-features">
                        本地对战 • 即时竞技 • 友谊比拼
                    </div>
                </div>
            </div>
            
            <div style="color: #888; font-size: 14px; margin-top: 20px;">
                💡 提示：两种模式都支持飞行、多种武器和地形破坏
            </div>
        </div>

        <!-- AI难度选择界面 -->
        <div class="game-mode-screen" id="difficultyScreen" style="display: none;">
            <div class="mode-title">选择AI难度</div>
            <div class="mode-subtitle">
                选择适合你的挑战等级<br>
                不同难度的AI有不同的战斗策略
            </div>
            
            <div class="mode-options">
                <div class="mode-option difficulty-easy" onclick="startGameMode('single', 'easy')">
                    <span class="mode-icon">😊</span>
                    <div class="mode-name">初级AI</div>
                    <div class="mode-desc">
                        适合新手玩家<br>
                        AI反应较慢，策略简单
                    </div>
                    <div class="mode-features">
                        瞄准误差大 • 思考时间长 • 策略保守
                    </div>
                </div>
                
                <div class="mode-option difficulty-medium" onclick="startGameMode('single', 'medium')">
                    <span class="mode-icon">🤔</span>
                    <div class="mode-name">中级AI</div>
                    <div class="mode-desc">
                        平衡的挑战体验<br>
                        AI有一定战术意识
                    </div>
                    <div class="mode-features">
                        瞄准适中 • 策略平衡 • 会使用特殊武器
                    </div>
                </div>
                
                <div class="mode-option difficulty-hard" onclick="startGameMode('single', 'hard')">
                    <span class="mode-icon">😤</span>
                    <div class="mode-name">高级AI</div>
                    <div class="mode-desc">
                        专家级挑战<br>
                        AI反应敏捷，策略高深
                    </div>
                    <div class="mode-features">
                        瞄准精准 • 思考快速 • 策略激进
                    </div>
                </div>
            </div>
            
            <div style="color: #888; font-size: 14px; margin-top: 20px;">
                <button onclick="backToModeSelect()" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">返回模式选择</button>
            </div>
        </div>

        <!-- 游戏结束界面 -->
        <div class="game-over" id="gameOver">
            <div class="winner-text" id="winnerText">玩家1获胜!</div>
            <p>恭喜获得胜利!</p>
            <button class="restart-btn" onclick="restartGame()">重新开始</button>
            <button class="restart-btn" onclick="backToModeSelect()" style="margin-left: 15px; background: linear-gradient(45deg, #FF6B6B, #FF8A8A);">返回模式选择</button>
        </div>
    </div>

    <!-- 控制说明 -->
    <div class="controls">
        <div class="controls-grid">
            <div>
                <strong style="color: #4CAF50;">玩家1 (绿色):</strong><br>
                • AD键移动，WS键调角度(0-180°)<br>
                • 空格键蓄力发射/飞行<br>
                • Q键选择武器，G键切换飞行模式
            </div>
            <div>
                <strong style="color: #FF6B6B;">玩家2 (红色):</strong><br>
                • 方向键移动，上下键调角度(0-180°)<br>
                • 空格键蓄力发射/飞行<br>
                • Q键选择武器，1键切换飞行模式
            </div>
        </div>
        <div class="controls-tip">
            <strong>游戏提示:</strong> 飞行着陆后会自动切换到移动模式，可重新切换飞行模式 | 每回合限时20秒 | 击中对手或掉入深坑/界外即可获胜
        </div>
    </div>

    <script>
        class TNTBattleGame {
            constructor() {
                console.log('TNTBattleGame构造函数开始执行');
                this.canvas = document.getElementById('gameCanvas');
                console.log('Canvas元素:', this.canvas);
                if (!this.canvas) {
                    throw new Error('找不到gameCanvas元素');
                }
                this.ctx = this.canvas.getContext('2d');
                console.log('Canvas上下文:', this.ctx);
                
                // 游戏状态
                this.currentPlayer = 1;
                this.gameState = 'modeSelect'; // modeSelect, playing, gameOver
                this.gameMode = null; // 'single' or 'multiplayer'
                this.aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
                this.isCharging = false;
                this.chargePower = 0;
                this.maxPower = 100;
                this.turnTimeLeft = 20;
                this.turnTimer = null;
                this.isTurnActive = true;
                
                // 玩家数据
                this.players = {
                    1: {
                        x: 100,
                        y: 500,
                        hp: 100,
                        maxHP: 100,
                        color: '#4CAF50',
                        selectedWeapon: 0,
                        angle: 45,
                        isFlying: false,
                        flyMode: false,
                        flyPower: 0,
                        flyVelocityX: 0,
                        flyVelocityY: 0,
                        onGround: true,
                        hasFlownThisTurn: false,
                        isChargingFly: false,
                        standingOnObstacle: false,
                        currentSupportingObstacle: null
                    },
                    2: {
                        x: 900,
                        y: 500,
                        hp: 100,
                        maxHP: 100,
                        color: '#FF6B6B',
                        selectedWeapon: 0,
                        angle: 135,
                        isFlying: false,
                        flyMode: false,
                        flyPower: 0,
                        flyVelocityX: 0,
                        flyVelocityY: 0,
                        onGround: true,
                        hasFlownThisTurn: false,
                        isChargingFly: false,
                        standingOnObstacle: false,
                        currentSupportingObstacle: null
                    }
                };
                
                // 武器类型
                this.weapons = [
                    {
                        name: '普通炸弹',
                        icon: '💣',
                        damage: 25,
                        radius: 40,
                        color: '#FF6B35',
                        speed: 0.7, // 降低30%
                        description: '基础炸弹',
                        type: 'normal'
                    },
                    {
                        name: '超级炸弹',
                        icon: '💥',
                        damage: 40,
                        radius: 60,
                        color: '#FF0000',
                        speed: 0.56, // 降低30%
                        description: '高伤害大范围',
                        type: 'normal'
                    },
                    {
                        name: '穿甲弹',
                        icon: '🚀',
                        damage: 35,
                        radius: 25,
                        color: '#4169E1',
                        speed: 1.05, // 降低30%
                        description: '高速低范围',
                        type: 'normal'
                    },
                    {
                        name: '集束炸弹',
                        icon: '🎆',
                        damage: 18,
                        radius: 28,
                        color: '#FFD700',
                        speed: 0.7, // 降低30%
                        description: '分裂4次小弹',
                        type: 'cluster',
                        splitCount: 4
                    },
                    {
                        name: '连射炸弹',
                        icon: '🔫',
                        damage: 15,
                        radius: 25,
                        color: '#FF4500',
                        speed: 0.84, // 降低30%
                        description: '连射6发子弹',
                        type: 'rapid',
                        bulletCount: 6
                    },
                    {
                        name: '燃烧弹',
                        icon: '🔥',
                        damage: 20,
                        radius: 35,
                        color: '#FF6347',
                        speed: 0.7, // 降低30%
                        description: '持续燃烧伤害',
                        type: 'fire',
                        burnDuration: 5,
                        burnDamage: 5
                    },
                    {
                        name: '散射弹',
                        icon: '🌟',
                        damage: 18,
                        radius: 30,
                        color: '#9370DB',
                        speed: 0.7, // 降低30%
                        description: '散射3发×3次',
                        type: 'scatter',
                        scatterCount: 3,
                        burstCount: 3
                    },
                    {
                        name: '核弹',
                        icon: '☢️',
                        damage: 60,
                        radius: 80,
                        color: '#FF1493',
                        speed: 0.42, // 降低30%
                        description: '超强威力',
                        type: 'normal'
                    }
                ];
                
                // 弹道相关
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = []; // 燃烧区域
                this.burnEffects = []; // 燃烧效果
                this.craters = []; // 弹坑数据
                this.obstacles = []; // 空中障碍物
                
                // 键盘状态
                this.keys = {};
                
                try {
                    console.log('开始绑定事件...');
                    this.bindEvents();
                    console.log('事件绑定完成');
                } catch (error) {
                    console.error('绑定事件时出错:', error);
                    throw error;
                }
                
                try {
                    console.log('创建武器选择器...');
                    this.createWeaponSelector();
                    console.log('武器选择器创建完成');
                } catch (error) {
                    console.error('创建武器选择器时出错:', error);
                    throw error;
                }
                
                try {
                    console.log('显示模式选择器...');
                    this.showModeSelector();
                    console.log('模式选择器显示完成');
                } catch (error) {
                    console.error('显示模式选择器时出错:', error);
                    throw error;
                }
                
                // 将游戏循环移到最后启动
                console.log('准备启动游戏循环...');
                
                console.log('TNTBattleGame构造函数执行完成');
                
                // 在构造函数完成后启动游戏循环
                setTimeout(() => {
                    try {
                        console.log('启动游戏循环...');
                        this.gameLoop();
                        console.log('游戏循环启动完成');
                    } catch (error) {
                        console.error('启动游戏循环时出错:', error);
                    }
                }, 100);
            }
            
            showModeSelector() {
                document.getElementById('gameModeScreen').style.display = 'flex';
                document.getElementById('gameOver').style.display = 'none';
            }
            
            startGame(mode, difficulty = 'medium') {
                console.log('startGame函数被调用，模式:', mode, '难度:', difficulty);
                this.gameMode = mode;
                this.aiDifficulty = difficulty;
                this.gameState = 'playing';
                console.log('隐藏模式选择界面');
                document.getElementById('gameModeScreen').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                
                // 根据游戏模式更新玩家名称显示
                if (mode === 'single') {
                    document.getElementById('player1Name').textContent = '你 (WASD)';
                    const difficultyNames = {
                        'easy': '初级AI',
                        'medium': '中级AI', 
                        'hard': '高级AI'
                    };
                    document.getElementById('player2Name').textContent = `${difficultyNames[difficulty]} (自动)`;
                } else {
                    document.getElementById('player1Name').textContent = '玩家1 (WASD)';
                    document.getElementById('player2Name').textContent = '玩家2 (方向键)';
                }
                
                this.initializeGame();
            }
            
            getAIConfig() {
                // 根据难度返回AI配置
                const configs = {
                    'easy': {
                        thinkTime: [2000, 4000], // 思考时间2-4秒
                        aimError: 40, // 瞄准误差±40度
                        powerVariation: 0.4, // 力量变化±40%
                        aimTime: [1000, 2000], // 瞄准时间1-2秒
                        strategyWeights: {
                            attack: 0.6,
                            move: 0.3,
                            fly: 0.1
                        },
                        weaponPreference: [0, 1], // 偏好简单武器
                        weaponChangeChance: 0.1, // 10%概率换武器
                        flightAccuracy: 0.5, // 飞行精度50%
                        craterAvoidance: 0.3 // 弹坑回避能力30%
                    },
                    'medium': {
                        thinkTime: [1000, 2500], // 思考时间1-2.5秒
                        aimError: 20, // 瞄准误差±20度
                        powerVariation: 0.2, // 力量变化±20%
                        aimTime: [500, 1000], // 瞄准时间0.5-1秒
                        strategyWeights: {
                            attack: 0.7,
                            move: 0.2,
                            fly: 0.1
                        },
                        weaponPreference: [0, 1, 3, 4], // 偏好常用武器
                        weaponChangeChance: 0.3, // 30%概率换武器
                        flightAccuracy: 0.7, // 飞行精度70%
                        craterAvoidance: 0.6 // 弹坑回避能力60%
                    },
                    'hard': {
                        thinkTime: [300, 800], // 思考时间0.3-0.8秒 (更快)
                        aimError: 5, // 瞄准误差±5度 (更精准)
                        powerVariation: 0.05, // 力量变化±5% (更精确)
                        aimTime: [100, 300], // 瞄准时间0.1-0.3秒 (更快)
                        strategyWeights: {
                            attack: 0.5,
                            move: 0.25,
                            fly: 0.25
                        },
                        weaponPreference: [0, 1, 2, 3, 4, 5, 6, 7], // 使用所有武器
                        weaponChangeChance: 0.8, // 80%概率换武器 (更频繁)
                        flightAccuracy: 0.95, // 飞行精度95% (更高)
                        craterAvoidance: 0.95, // 弹坑回避能力95% (更高)
                        // 新增高级AI特性
                        predictiveAiming: true, // 预测性瞄准
                        terrainAnalysis: true, // 地形分析能力
                        weaponOptimization: true, // 武器优化选择
                        aggressiveStrategy: true, // 激进策略
                        counterAttack: true, // 反击能力
                        positionOptimization: true // 位置优化
                    }
                };
                
                return configs[this.aiDifficulty] || configs['medium'];
            }
            
            backToModeSelect() {
                this.gameState = 'modeSelect';
                this.gameMode = null;
                this.aiDifficulty = 'medium';
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('difficultyScreen').style.display = 'none';
                document.getElementById('gameModeScreen').style.display = 'flex';
                
                // 清理游戏状态
                this.cleanup();
            }
            
            initializeGame() {
                console.log('initializeGame开始执行');
                console.log('当前游戏状态:', this.gameState);
                console.log('当前游戏模式:', this.gameMode);
                
                this.updateUI();
                console.log('UI更新完成');
                
                this.generateTerrain();
                console.log('地形生成完成，地形点数量:', this.terrain?.length);
                
                this.startTurn();
                console.log('回合开始，initializeGame执行完成');
            }
            
            generateTerrain() {
                // 生成随机地形，每局都不同
                this.terrain = [];
                
                // 随机选择地形类型
                const terrainTypes = [
                    'hills',      // 丘陵地形
                    'mountains',  // 山地地形  
                    'valleys',    // 峡谷地形
                    'plateau',    // 高原地形
                    'waves'       // 波浪地形
                ];
                
                const terrainType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                console.log(`生成地形类型: ${terrainType}`);
                
                // 随机地形参数
                const seed = Math.random() * 1000; // 随机种子
                const frequency = 0.005 + Math.random() * 0.015; // 0.005 - 0.02
                const amplitude = 30 + Math.random() * 40; // 30 - 70
                const baseHeight = 420 + Math.random() * 60; // 420 - 480
                
                for (let x = 0; x < this.canvas.width; x += 10) {
                    let height;
                    
                    switch(terrainType) {
                        case 'hills':
                            // 柔和的丘陵
                            height = baseHeight + 
                                    Math.sin((x + seed) * frequency) * amplitude +
                                    Math.sin((x + seed) * frequency * 2.3) * (amplitude * 0.3) +
                                    Math.sin((x + seed) * frequency * 0.7) * (amplitude * 0.5);
                            break;
                            
                        case 'mountains':
                            // 尖锐的山峰
                            height = baseHeight + 
                                    Math.abs(Math.sin((x + seed) * frequency * 1.5)) * amplitude * 1.2 +
                                    Math.cos((x + seed) * frequency * 0.8) * amplitude * 0.6;
                            break;
                            
                        case 'valleys':
                            // 深谷地形
                            height = baseHeight - 
                                    Math.abs(Math.sin((x + seed) * frequency * 0.8)) * amplitude * 0.8 +
                                    Math.sin((x + seed) * frequency * 3) * amplitude * 0.3;
                            break;
                            
                        case 'plateau':
                            // 高原台地
                            const plateauBase = Math.sin((x + seed) * frequency * 0.5) * amplitude * 0.8;
                            const plateauNoise = Math.sin((x + seed) * frequency * 8) * 5;
                            height = baseHeight + plateauBase + plateauNoise;
                            break;
                            
                        case 'waves':
                            // 波浪起伏
                            height = baseHeight + 
                                    Math.sin((x + seed) * frequency * 2) * amplitude * 0.7 +
                                    Math.sin((x + seed) * frequency * 5) * amplitude * 0.2 +
                                    Math.cos((x + seed) * frequency * 1.2) * amplitude * 0.4;
                            break;
                            
                        default:
                            height = baseHeight + Math.sin((x + seed) * frequency) * amplitude;
                    }
                    
                    // 添加随机噪声
                    const noise = (Math.random() - 0.5) * 12;
                    height += noise;
                    
                    // 确保高度在合理范围内
                    height = Math.max(350, Math.min(530, height));
                    
                    this.terrain.push({
                        x: x,
                        height: height,
                        originalHeight: height
                    });
                }
                
                // 平滑地形，避免过于尖锐的变化
                this.smoothTerrain();
                
                // 调整玩家位置到地形上
                this.players[1].y = this.getTerrainHeight(this.players[1].x) - 20;
                this.players[2].y = this.getTerrainHeight(this.players[2].x) - 20;
                
                console.log('玩家1位置:', this.players[1].x, this.players[1].y);
                console.log('玩家2位置:', this.players[2].x, this.players[2].y);
                
                // 生成空中障碍物
                this.generateObstacles();
                
                // 生成随机背景
                this.generateRandomBackground();
            }
            
            smoothTerrain() {
                // 平滑地形，减少过于尖锐的变化
                for (let i = 1; i < this.terrain.length - 1; i++) {
                    const prev = this.terrain[i - 1].height;
                    const current = this.terrain[i].height;
                    const next = this.terrain[i + 1].height;
                    
                    // 使用加权平均进行平滑
                    const smoothed = (prev * 0.25 + current * 0.5 + next * 0.25);
                    this.terrain[i].height = smoothed;
                    this.terrain[i].originalHeight = smoothed;
                }
            }
            
            generateRandomBackground() {
                // 生成随机背景主题
                const backgroundThemes = [
                    {
                        name: 'classic',
                        sky: ['#87CEEB', '#98FB98'], // 经典蓝天绿地
                        ground: '#8B4513'
                    },
                    {
                        name: 'sunset',
                        sky: ['#FF6B35', '#F7931E', '#FFD700'], // 日落
                        ground: '#8B4513'
                    },
                    {
                        name: 'dawn',
                        sky: ['#FF69B4', '#FF1493', '#87CEEB'], // 黎明
                        ground: '#654321'
                    },
                    {
                        name: 'night',
                        sky: ['#191970', '#483D8B', '#2F4F4F'], // 夜晚
                        ground: '#2F2F2F'
                    },
                    {
                        name: 'desert',
                        sky: ['#FFD700', '#FFA500', '#FF8C00'], // 沙漠
                        ground: '#DEB887'
                    },
                    {
                        name: 'arctic',
                        sky: ['#B0E0E6', '#87CEEB', '#E0FFFF'], // 北极
                        ground: '#F0F8FF'
                    },
                    {
                        name: 'alien',
                        sky: ['#9370DB', '#8A2BE2', '#4B0082'], // 外星
                        ground: '#800080'
                    },
                    {
                        name: 'forest',
                        sky: ['#228B22', '#32CD32', '#90EE90'], // 森林
                        ground: '#556B2F'
                    }
                ];
                
                this.currentTheme = backgroundThemes[Math.floor(Math.random() * backgroundThemes.length)];
                console.log(`生成背景主题: ${this.currentTheme.name}`);
                
                // 应用背景到游戏容器
                this.applyBackgroundTheme();
            }
            
            applyBackgroundTheme() {
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer && this.currentTheme) {
                    const skyColors = this.currentTheme.sky;
                    let gradient;
                    
                    if (skyColors.length === 2) {
                        gradient = `linear-gradient(to bottom, ${skyColors[0]} 0%, ${skyColors[1]} 60%, ${this.currentTheme.ground} 60%, ${this.currentTheme.ground} 100%)`;
                    } else if (skyColors.length === 3) {
                        gradient = `linear-gradient(to bottom, ${skyColors[0]} 0%, ${skyColors[1]} 30%, ${skyColors[2]} 60%, ${this.currentTheme.ground} 60%, ${this.currentTheme.ground} 100%)`;
                    }
                    
                    gameContainer.style.background = gradient;
                }
            }
            
            getTerrainHeight(x) {
                const index = Math.floor(x / 10);
                if (index >= 0 && index < this.terrain.length) {
                    return this.terrain[index].height;
                }
                return 500;
            }
            
            generateObstacles() {
                // 生成随机空中障碍物
                this.obstacles = [];
                
                // 根据地形类型调整障碍物数量和类型
                const baseCount = 4 + Math.floor(Math.random() * 5); // 4-8个障碍物
                let obstacleTypes = ['platform', 'cloud'];
                
                // 根据主题添加特殊障碍物类型
                if (this.currentTheme) {
                    switch(this.currentTheme.name) {
                        case 'arctic':
                            obstacleTypes.push('iceberg');
                            break;
                        case 'desert':
                            obstacleTypes.push('rock', 'cactus');
                            break;
                        case 'alien':
                            obstacleTypes.push('crystal', 'floating_rock');
                            break;
                        case 'forest':
                            obstacleTypes.push('tree_platform', 'mushroom');
                            break;
                        case 'night':
                            obstacleTypes.push('moon_rock');
                            break;
                    }
                }
                
                for (let i = 0; i < baseCount; i++) {
                    // 随机分布，有些区域密集，有些稀疏
                    const zoneType = Math.random();
                    let x, y;
                    
                    if (zoneType < 0.3) {
                        // 左侧区域
                        x = 150 + Math.random() * 300;
                    } else if (zoneType < 0.6) {
                        // 中间区域
                        x = 350 + Math.random() * 300;
                    } else {
                        // 右侧区域
                        x = 550 + Math.random() * 300;
                    }
                    
                    // 随机高度分布
                    const heightZone = Math.random();
                    if (heightZone < 0.4) {
                        y = 150 + Math.random() * 120; // 高空
                    } else if (heightZone < 0.8) {
                        y = 250 + Math.random() * 150; // 中空
                    } else {
                        y = 350 + Math.random() * 100; // 低空
                    }
                    
                    // 随机尺寸
                    const sizeVariation = Math.random();
                    let width, height;
                    
                    if (sizeVariation < 0.2) {
                        // 小型障碍物
                        width = 60 + Math.random() * 40;
                        height = 20 + Math.random() * 20;
                    } else if (sizeVariation < 0.7) {
                        // 中型障碍物
                        width = 80 + Math.random() * 60;
                        height = 25 + Math.random() * 30;
                    } else {
                        // 大型障碍物
                        width = 120 + Math.random() * 80;
                        height = 35 + Math.random() * 40;
                    }
                    
                    // 随机选择障碍物类型
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    
                    // 确保障碍物不重叠
                    let overlap = false;
                    for (let existing of this.obstacles) {
                        if (Math.abs(x - existing.x) < (width + existing.width) / 2 + 60 &&
                            Math.abs(y - existing.y) < (height + existing.height) / 2 + 50) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        this.obstacles.push({
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            type: type,
                            craters: [],
                            isSolid: true,
                            canLandOn: true,
                            isRigidBody: true,
                            mass: width * height * 0.01,
                            friction: 0.8,
                            theme: this.currentTheme ? this.currentTheme.name : 'classic'
                        });
                    }
                }
                
                console.log(`生成了 ${this.obstacles.length} 个障碍物`);
            }
            
            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.key.toLowerCase() === 'q') {
                        this.toggleWeaponSelector();
                    }
                    
                    if (e.key.toLowerCase() === 'g' && this.currentPlayer === 1) {
                        this.toggleFlyMode();
                    }
                    
                    if (e.key === '1' && this.currentPlayer === 2) {
                        this.toggleFlyMode();
                    }
                    
                    if (e.key === ' ') {
                        e.preventDefault();
                        const player = this.players[this.currentPlayer];
                        if (player.flyMode) {
                            this.startFlyCharging();
                        } else {
                            this.startCharging();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    
                    if (e.key === ' ') {
                        e.preventDefault();
                        const player = this.players[this.currentPlayer];
                        if (player.flyMode) {
                            this.fly();
                        } else {
                            this.fire();
                        }
                    }
                });
            }
            
            createWeaponSelector() {
                const weaponGrid = document.getElementById('weaponGrid');
                if (!weaponGrid) {
                    console.error('找不到weaponGrid元素');
                    return;
                }
                
                if (!this.weapons) {
                    console.error('weapons数组未初始化');
                    return;
                }
                
                if (!this.players || !this.players[this.currentPlayer]) {
                    console.error('players对象未正确初始化');
                    return;
                }
                
                weaponGrid.innerHTML = '';
                
                this.weapons.forEach((weapon, index) => {
                    const weaponItem = document.createElement('div');
                    weaponItem.className = 'weapon-item';
                    if (index === this.players[this.currentPlayer].selectedWeapon) {
                        weaponItem.classList.add('selected');
                    }
                    
                    weaponItem.innerHTML = `
                        <div class="weapon-icon">${weapon.icon}</div>
                        <div class="weapon-name">${weapon.name}</div>
                        <div class="weapon-desc">${weapon.description}</div>
                    `;
                    
                    weaponItem.addEventListener('click', () => {
                        this.selectWeapon(index);
                    });
                    
                    weaponGrid.appendChild(weaponItem);
                });
            }
            
            selectWeapon(index) {
                this.players[this.currentPlayer].selectedWeapon = index;
                this.updateUI();
                this.toggleWeaponSelector();
            }
            
            toggleWeaponSelector() {
                const selector = document.getElementById('weaponSelector');
                if (selector.style.display === 'flex') {
                    selector.style.display = 'none';
                } else {
                    selector.style.display = 'flex';
                    this.createWeaponSelector();
                }
            }
            
            startCharging() {
                if (this.gameState !== 'playing' || this.isCharging || !this.isTurnActive) return;
                
                this.isCharging = true;
                this.chargePower = 0;
                document.getElementById('powerMeter').style.display = 'flex';
                
                this.chargeInterval = setInterval(() => {
                    this.chargePower = Math.min(this.chargePower + 2, this.maxPower);
                    const powerFill = document.getElementById('powerFill');
                    powerFill.style.width = (this.chargePower / this.maxPower * 100) + '%';
                }, 50);
            }
            
            fire() {
                if (!this.isCharging || !this.isTurnActive) return;
                
                this.isCharging = false;
                this.isTurnActive = false; // 结束当前回合
                clearInterval(this.chargeInterval);
                clearInterval(this.turnTimer); // 停止倒计时
                document.getElementById('powerMeter').style.display = 'none';
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.selectedWeapon];
                const power = this.chargePower / this.maxPower;
                
                // 根据武器类型发射不同的弹药
                this.fireWeapon(player, weapon, power);
                this.chargePower = 0;
                
                // 等待弹道结束后切换回合
                this.waitForProjectileEnd();
            }
            
            fireWeapon(player, weapon, power) {
                const radians = (player.angle * Math.PI) / 180;
                const speed = 10 + power * 15;
                
                switch(weapon.type) {
                    case 'rapid':
                        this.fireRapidShot(player, weapon, radians, speed);
                        break;
                    case 'scatter':
                        this.fireScatterShot(player, weapon, radians, speed);
                        break;
                    default:
                        this.fireSingleShot(player, weapon, radians, speed);
                        break;
                }
            }
            
            fireSingleShot(player, weapon, radians, speed) {
                const projectile = {
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(radians) * speed * weapon.speed,
                    vy: -Math.sin(radians) * speed * weapon.speed,
                    weapon: weapon,
                    player: this.currentPlayer,
                    trail: []
                };
                this.projectiles.push(projectile);
            }
            
            fireRapidShot(player, weapon, radians, speed) {
                for (let i = 0; i < weapon.bulletCount; i++) {
                    setTimeout(() => {
                        const angleVariation = (Math.random() - 0.5) * 0.2;
                        const speedVariation = 0.8 + Math.random() * 0.4;
                        
                        const projectile = {
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(radians + angleVariation) * speed * weapon.speed * speedVariation,
                            vy: -Math.sin(radians + angleVariation) * speed * weapon.speed * speedVariation,
                            weapon: weapon,
                            player: this.currentPlayer,
                            trail: []
                        };
                        this.projectiles.push(projectile);
                    }, i * 200);
                }
            }
            
            fireScatterShot(player, weapon, radians, speed) {
                for (let burst = 0; burst < weapon.burstCount; burst++) {
                    setTimeout(() => {
                        for (let i = 0; i < weapon.scatterCount; i++) {
                            const angleSpread = (i - Math.floor(weapon.scatterCount / 2)) * 0.3;
                            const projectile = {
                                x: player.x,
                                y: player.y,
                                vx: Math.cos(radians + angleSpread) * speed * weapon.speed,
                                vy: -Math.sin(radians + angleSpread) * speed * weapon.speed,
                                weapon: weapon,
                                player: this.currentPlayer,
                                trail: []
                            };
                            this.projectiles.push(projectile);
                        }
                    }, burst * 300);
                }
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                this.handleInput();
                
                // 更新所有玩家的物理状态（不仅仅是当前玩家）
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    this.updatePlayerPhysics(player);
                });
                
                this.updateProjectiles();
                this.updateExplosions();
                this.updateParticles();
                this.updateFireZones();
                this.updateBurnEffects();
                this.checkPlayerBounds(); // 检查玩家是否掉出界面
            }
            
            handleInput() {
                if (!this.isTurnActive) return; // 只有在活跃回合才能操作
                
                const player = this.players[this.currentPlayer];
                
                // 单人模式下，玩家2由AI控制
                if (this.gameMode === 'single' && this.currentPlayer === 2) {
                    this.handleAI();
                    return;
                }
                const moveSpeed = 3;
                const angleSpeed = 2;
                
                // 飞行中不允许移动控制，只允许自然的物理运动
                if (player.isFlying) return;
                
                if (this.currentPlayer === 1) {
                    // WASD控制
                    if (this.keys['a']) {
                        const newX = Math.max(20, player.x - moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // 检查刚体碰撞
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // 恢复位置
                        }
                        // 移除强制地形高度更新 - 让物理系统自然处理
                    }
                    if (this.keys['d']) {
                        const newX = Math.min(this.canvas.width - 20, player.x + moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // 检查刚体碰撞
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // 恢复位置
                        }
                        // 移除强制地形高度更新 - 让物理系统自然处理
                    }
                    if (this.keys['w']) {
                        player.angle = Math.min(180, player.angle + angleSpeed);
                    }
                    if (this.keys['s']) {
                        player.angle = Math.max(0, player.angle - angleSpeed);
                    }
                } else {
                    // 方向键控制
                    if (this.keys['arrowleft']) {
                        const newX = Math.max(20, player.x - moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // 检查刚体碰撞
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // 恢复位置
                        }
                        // 移除强制地形高度更新 - 让物理系统自然处理
                    }
                    if (this.keys['arrowright']) {
                        const newX = Math.min(this.canvas.width - 20, player.x + moveSpeed);
                        const oldX = player.x;
                        player.x = newX;
                        
                        // 检查刚体碰撞
                        const collision = this.checkObstacleCollision(player);
                        if (collision) {
                            player.x = oldX; // 恢复位置
                        }
                        // 移除强制地形高度更新 - 让物理系统自然处理
                    }
                    if (this.keys['arrowup']) {
                        player.angle = Math.min(180, player.angle + angleSpeed);
                    }
                    if (this.keys['arrowdown']) {
                        player.angle = Math.max(0, player.angle - angleSpeed);
                    }
                }
            }
            
            handleAI() {
                if (!this.isTurnActive || this.currentPlayer !== 2) return;
                
                const aiPlayer = this.players[2];
                const humanPlayer = this.players[1];
                
                // AI已经在执行动作，避免重复
                if (aiPlayer.aiActionInProgress) return;
                aiPlayer.aiActionInProgress = true;
                
                // 根据难度获取AI配置
                const config = this.getAIConfig();
                
                // AI决策延迟，根据难度调整思考时间
                const thinkTime = config.thinkTime[0] + Math.random() * (config.thinkTime[1] - config.thinkTime[0]);
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    this.executeAIAction(aiPlayer, humanPlayer);
                }, thinkTime);
            }
            
            executeAIAction(aiPlayer, humanPlayer) {
                // 计算到敌人的距离和角度
                const dx = humanPlayer.x - aiPlayer.x;
                const dy = humanPlayer.y - aiPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                // AI策略决策
                const strategy = this.chooseAIStrategy(aiPlayer, humanPlayer, distance);
                
                switch(strategy) {
                    case 'attack':
                        this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                        break;
                    case 'move':
                        this.aiMove(aiPlayer, humanPlayer);
                        break;
                    case 'fly':
                        this.aiFly(aiPlayer, humanPlayer);
                        break;
                    default:
                        this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                }
            }
            
            chooseAIStrategy(aiPlayer, humanPlayer, distance) {
                const config = this.getAIConfig();
                const weights = config.strategyWeights;
                
                // 高级AI的智能分析
                if (this.aiDifficulty === 'hard') {
                    return this.chooseAdvancedAIStrategy(aiPlayer, humanPlayer, distance, config);
                }
                
                // 检查弹坑回避（根据难度）
                const craterInfo = this.analyzePlayerCraterSituation(aiPlayer);
                const inCrater = craterInfo.inCrater;
                
                // 如果在弹坑中且AI有足够的回避能力，优先逃脱
                if (inCrater && Math.random() < config.craterAvoidance) {
                    return !aiPlayer.hasFlownThisTurn && Math.random() < 0.7 ? 'fly' : 'move';
                }
                
                // 如果距离很近且在有利位置，倾向攻击
                if (distance < 300 && aiPlayer.y <= humanPlayer.y) {
                    return Math.random() < (weights.attack + 0.2) ? 'attack' : 'move';
                }
                
                // 如果血量较低，根据难度调整策略
                if (aiPlayer.hp < 50 && !aiPlayer.hasFlownThisTurn) {
                    return Math.random() < weights.fly * 3 ? 'fly' : 'move';
                }
                
                // 如果在不利位置，考虑移动或飞行
                if (aiPlayer.y > humanPlayer.y + 100) {
                    if (!aiPlayer.hasFlownThisTurn && Math.random() < weights.fly * 2) {
                        return 'fly';
                    }
                    return 'move';
                }
                
                // 根据权重随机选择策略
                const rand = Math.random();
                if (rand < weights.attack) {
                    return 'attack';
                } else if (rand < weights.attack + weights.move) {
                    return 'move';
                } else {
                    return !aiPlayer.hasFlownThisTurn ? 'fly' : 'attack';
                }
            }
            
            chooseAdvancedAIStrategy(aiPlayer, humanPlayer, distance, config) {
                // 高级AI的深度策略分析
                const situation = this.analyzeGameSituation(aiPlayer, humanPlayer);
                
                // 危险评估
                const dangerLevel = this.assessDanger(aiPlayer, humanPlayer);
                
                // 机会评估
                const opportunityLevel = this.assessOpportunity(aiPlayer, humanPlayer);
                
                // 基于分析结果选择策略
                if (dangerLevel > 0.7 && !aiPlayer.hasFlownThisTurn) {
                    // 高危险情况，优先逃脱
                    return Math.random() < 0.8 ? 'fly' : 'move';
                }
                
                if (opportunityLevel > 0.8) {
                    // 高机会情况，立即攻击
                    return 'attack';
                }
                
                if (situation.healthAdvantage > 30 && distance < 400) {
                    // 血量优势且距离适中，激进攻击
                    return Math.random() < 0.9 ? 'attack' : 'move';
                }
                
                if (situation.positionAdvantage > 0.5 && !aiPlayer.hasFlownThisTurn) {
                    // 位置劣势，寻找更好位置
                    return Math.random() < 0.7 ? 'fly' : 'move';
                }
                
                if (situation.terrainAdvantage < -0.3) {
                    // 地形劣势，重新定位
                    return !aiPlayer.hasFlownThisTurn && Math.random() < 0.6 ? 'fly' : 'move';
                }
                
                // 默认策略：平衡的选择
                const rand = Math.random();
                if (rand < 0.6) return 'attack';
                else if (rand < 0.8) return 'move';
                else return !aiPlayer.hasFlownThisTurn ? 'fly' : 'attack';
            }
            
            analyzeGameSituation(aiPlayer, humanPlayer) {
                // 分析当前游戏局势
                const healthAdvantage = aiPlayer.hp - humanPlayer.hp;
                
                // 位置优势分析
                const heightDiff = humanPlayer.y - aiPlayer.y;
                const positionAdvantage = heightDiff / 200; // 归一化到-1到1
                
                // 地形优势分析
                const aiTerrain = this.getTerrainHeight(aiPlayer.x);
                const humanTerrain = this.getTerrainHeight(humanPlayer.x);
                const aiOriginal = this.getOriginalTerrainHeight(aiPlayer.x);
                const humanOriginal = this.getOriginalTerrainHeight(humanPlayer.x);
                
                const aiCraterDepth = aiTerrain - aiOriginal;
                const humanCraterDepth = humanTerrain - humanOriginal;
                const terrainAdvantage = (humanCraterDepth - aiCraterDepth) / 100;
                
                return {
                    healthAdvantage,
                    positionAdvantage,
                    terrainAdvantage
                };
            }
            
            assessDanger(aiPlayer, humanPlayer) {
                let danger = 0;
                
                // 血量危险
                if (aiPlayer.hp < 30) danger += 0.5;
                else if (aiPlayer.hp < 50) danger += 0.2;
                
                // 位置危险（接近界面底部）
                const distanceToBottom = this.canvas.height - aiPlayer.y;
                
                if (distanceToBottom < 30) danger += 0.8; // 非常接近底部，极度危险
                else if (distanceToBottom < 80) danger += 0.5; // 接近底部，危险
                else if (distanceToBottom < 150) danger += 0.3; // 比较接近底部，中等危险
                
                // 额外检查：如果在深坑中，增加危险值
                const currentHeight = this.getTerrainHeight(aiPlayer.x);
                const originalHeight = this.getOriginalTerrainHeight(aiPlayer.x);
                const craterDepth = currentHeight - originalHeight;
                if (craterDepth > 80) danger += 0.3; // 深坑额外危险
                
                // 距离危险（太近容易被击中）
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                if (distance < 200) danger += 0.3;
                
                // 高度劣势
                if (aiPlayer.y > humanPlayer.y + 50) danger += 0.2;
                
                return Math.min(danger, 1.0);
            }
            
            assessOpportunity(aiPlayer, humanPlayer) {
                let opportunity = 0;
                
                // 血量优势
                if (aiPlayer.hp > humanPlayer.hp + 20) opportunity += 0.3;
                
                // 位置优势（高地）
                if (aiPlayer.y < humanPlayer.y - 30) opportunity += 0.4;
                
                // 敌人在弹坑中或接近底部
                const humanDistanceToBottom = this.canvas.height - humanPlayer.y;
                
                if (humanDistanceToBottom < 80) opportunity += 0.6; // 敌人接近底部，容易击杀
                
                // 检查敌人是否在深坑中
                const humanCurrentHeight = this.getTerrainHeight(humanPlayer.x);
                const humanOriginalHeight = this.getOriginalTerrainHeight(humanPlayer.x);
                const humanCraterDepth = humanCurrentHeight - humanOriginalHeight;
                if (humanCraterDepth > 80) opportunity += 0.4; // 敌人在深坑中
                
                // 距离适中（容易击中）
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                if (distance > 200 && distance < 500) opportunity += 0.2;
                
                return Math.min(opportunity, 1.0);
            }
            
            aiAttack(aiPlayer, humanPlayer, targetAngle) {
                const config = this.getAIConfig();
                
                // 高级AI使用增强攻击系统
                if (this.aiDifficulty === 'hard') {
                    this.advancedAIAttack(aiPlayer, humanPlayer, targetAngle, config);
                    return;
                }
                
                // 调整角度到目标方向
                let finalAngle = targetAngle;
                if (finalAngle < 0) finalAngle += 360;
                if (finalAngle > 180) finalAngle = 180;
                if (finalAngle < 0) finalAngle = 0;
                
                // 根据难度添加瞄准误差
                finalAngle += (Math.random() - 0.5) * config.aimError;
                finalAngle = Math.max(0, Math.min(180, finalAngle));
                
                aiPlayer.angle = finalAngle;
                
                // 根据难度选择武器
                if (Math.random() < config.weaponChangeChance) {
                    const availableWeapons = config.weaponPreference;
                    aiPlayer.selectedWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                }
                
                // 根据难度调整瞄准时间
                const aimTime = config.aimTime[0] + Math.random() * (config.aimTime[1] - config.aimTime[0]);
                
                // 模拟蓄力射击
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    // 根据难度调整力量精度
                    const basePower = 0.7;
                    const powerVariation = config.powerVariation;
                    const power = Math.max(0.3, Math.min(1.0, basePower + (Math.random() - 0.5) * powerVariation));
                    
                    const weapon = this.weapons[aiPlayer.selectedWeapon];
                    
                    this.fireWeapon(aiPlayer, weapon, power);
                    this.isTurnActive = false;
                    this.waitForProjectileEnd();
                    aiPlayer.aiActionInProgress = false;
                }, aimTime);
            }
            
            advancedAIAttack(aiPlayer, humanPlayer, targetAngle, config) {
                // 高级AI的智能攻击系统
                
                // 1. 智能武器选择
                const optimalWeapon = this.selectOptimalWeapon(aiPlayer, humanPlayer);
                aiPlayer.selectedWeapon = optimalWeapon;
                
                // 2. 预测性瞄准
                const predictedAngle = this.calculatePredictiveAim(aiPlayer, humanPlayer);
                
                // 3. 地形分析瞄准修正
                const terrainCorrectedAngle = this.applyTerrainCorrection(predictedAngle, aiPlayer, humanPlayer);
                
                // 4. 微调瞄准误差（极小）
                const finalAngle = Math.max(0, Math.min(180, 
                    terrainCorrectedAngle + (Math.random() - 0.5) * config.aimError
                ));
                
                aiPlayer.angle = finalAngle;
                
                // 5. 动态力量计算
                const optimalPower = this.calculateOptimalPower(aiPlayer, humanPlayer, finalAngle);
                
                // 6. 极短瞄准时间
                const aimTime = config.aimTime[0] + Math.random() * (config.aimTime[1] - config.aimTime[0]);
                
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    const weapon = this.weapons[aiPlayer.selectedWeapon];
                    
                    this.fireWeapon(aiPlayer, weapon, optimalPower);
                    this.isTurnActive = false;
                    this.waitForProjectileEnd();
                    aiPlayer.aiActionInProgress = false;
                }, aimTime);
            }
            
            selectOptimalWeapon(aiPlayer, humanPlayer) {
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                const heightDiff = Math.abs(aiPlayer.y - humanPlayer.y);
                
                // 检查敌人位置情况
                const humanDistanceToBottom = this.canvas.height - humanPlayer.y;
                
                // 检查敌人是否在深坑中
                const humanCurrentHeight = this.getTerrainHeight(humanPlayer.x);
                const humanOriginalHeight = this.getOriginalTerrainHeight(humanPlayer.x);
                const humanCraterDepth = humanCurrentHeight - humanOriginalHeight;
                
                // 根据情况选择最优武器
                if (humanDistanceToBottom < 80 && distance < 400) {
                    // 敌人接近底部，使用大威力武器确保击杀
                    return Math.random() < 0.9 ? 7 : 1; // 核弹或超级炸弹
                } else if (humanCraterDepth > 80 && distance < 400) {
                    // 敌人在深坑中，使用大威力武器
                    return Math.random() < 0.8 ? 7 : 1; // 核弹或超级炸弹
                } else if (humanCraterDepth > 40 && distance < 350) {
                    // 敌人在浅坑中，使用中等威力武器
                    return Math.random() < 0.6 ? 1 : 3; // 超级炸弹或集束炸弹
                }
                
                if (distance < 250) {
                    // 近距离，使用快速武器
                    return Math.random() < 0.6 ? 4 : 2; // 连射炸弹或穿甲弹
                }
                
                if (distance > 600) {
                    // 远距离，使用高速武器
                    return 2; // 穿甲弹
                }
                
                if (heightDiff > 100) {
                    // 高度差大，使用散射武器
                    return Math.random() < 0.5 ? 6 : 3; // 散射弹或集束炸弹
                }
                
                if (humanPlayer.hp < 40) {
                    // 敌人血量低，使用燃烧弹持续伤害
                    return 5; // 燃烧弹
                }
                
                // 默认使用超级炸弹
                return 1;
            }
            
            calculatePredictiveAim(aiPlayer, humanPlayer) {
                // 预测性瞄准：考虑玩家可能的移动
                const dx = humanPlayer.x - aiPlayer.x;
                const dy = humanPlayer.y - aiPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 估算弹道飞行时间
                const estimatedFlightTime = distance / 15; // 假设平均速度
                
                // 预测玩家可能的移动（假设玩家会尝试躲避）
                const predictedMovement = estimatedFlightTime * 3; // 假设玩家移动速度
                
                // 根据玩家位置预测移动方向
                let predictedX = humanPlayer.x;
                if (humanPlayer.x < this.canvas.width / 2) {
                    // 玩家在左侧，可能向右移动
                    predictedX += predictedMovement;
                } else {
                    // 玩家在右侧，可能向左移动
                    predictedX -= predictedMovement;
                }
                
                // 重新计算角度
                const newDx = predictedX - aiPlayer.x;
                const newDy = humanPlayer.y - aiPlayer.y;
                let predictedAngle = Math.atan2(-newDy, newDx) * 180 / Math.PI;
                
                if (predictedAngle < 0) predictedAngle += 360;
                if (predictedAngle > 180) predictedAngle = 180;
                
                return predictedAngle;
            }
            
            applyTerrainCorrection(angle, aiPlayer, humanPlayer) {
                // 地形分析修正瞄准
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                
                // 检查弹道路径上的地形障碍
                const steps = Math.floor(distance / 50);
                let maxTerrainHeight = 0;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = aiPlayer.x + (humanPlayer.x - aiPlayer.x) * (i / steps);
                    const terrainHeight = this.getTerrainHeight(checkX);
                    maxTerrainHeight = Math.max(maxTerrainHeight, terrainHeight);
                }
                
                // 如果路径上有高地形，增加角度
                const clearanceNeeded = maxTerrainHeight - Math.min(aiPlayer.y, humanPlayer.y);
                if (clearanceNeeded > 0) {
                    const angleCorrection = Math.min(15, clearanceNeeded / 10);
                    return Math.min(180, angle + angleCorrection);
                }
                
                return angle;
            }
            
            calculateOptimalPower(aiPlayer, humanPlayer, angle) {
                // 计算最优发射力量
                const distance = Math.sqrt((aiPlayer.x - humanPlayer.x) ** 2 + (aiPlayer.y - humanPlayer.y) ** 2);
                const heightDiff = humanPlayer.y - aiPlayer.y;
                
                // 基础力量根据距离计算
                let basePower = Math.min(1.0, distance / 800);
                
                // 高度修正
                if (heightDiff > 0) {
                    // 向上射击，增加力量
                    basePower += heightDiff / 1000;
                } else {
                    // 向下射击，减少力量
                    basePower += heightDiff / 1500;
                }
                
                // 角度修正
                if (angle > 45 && angle < 135) {
                    // 高抛物线，增加力量
                    basePower += 0.1;
                }
                
                return Math.max(0.4, Math.min(1.0, basePower));
            }
            
            aiMove(aiPlayer, humanPlayer) {
                // AI移动策略：寻找更好的位置
                const targetX = this.findBetterPosition(aiPlayer, humanPlayer);
                const moveDirection = targetX > aiPlayer.x ? 1 : -1;
                const moveDistance = Math.min(50, Math.abs(targetX - aiPlayer.x));
                
                // 模拟移动
                const moveSteps = Math.floor(moveDistance / 3);
                let currentStep = 0;
                
                const moveInterval = setInterval(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2 || currentStep >= moveSteps) {
                        clearInterval(moveInterval);
                        // 移动完成后进行攻击
                        setTimeout(() => {
                            if (this.gameState === 'playing' && this.currentPlayer === 2) {
                                const dx = humanPlayer.x - aiPlayer.x;
                                const dy = humanPlayer.y - aiPlayer.y;
                                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                                this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                            } else {
                                aiPlayer.aiActionInProgress = false;
                            }
                        }, 300);
                        return;
                    }
                    
                    const newX = Math.max(20, Math.min(this.canvas.width - 20, aiPlayer.x + moveDirection * 3));
                    const oldX = aiPlayer.x;
                    const oldY = aiPlayer.y;
                    
                    // 更新X坐标
                    aiPlayer.x = newX;
                    
                    // 检查障碍物碰撞
                    if (this.checkObstacleCollision(aiPlayer)) {
                        aiPlayer.x = oldX; // 恢复X坐标
                        clearInterval(moveInterval);
                        // 如果无法移动，直接攻击
                        setTimeout(() => {
                            if (this.gameState === 'playing' && this.currentPlayer === 2) {
                                const dx = humanPlayer.x - aiPlayer.x;
                                const dy = humanPlayer.y - aiPlayer.y;
                                const targetAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                                this.aiAttack(aiPlayer, humanPlayer, targetAngle);
                            } else {
                                aiPlayer.aiActionInProgress = false;
                            }
                        }, 300);
                        return;
                    }
                    
                    // 应用地形物理：让AI跟随地形高度
                    this.updatePlayerPhysics(aiPlayer);
                    
                    // 在AI移动过程中也检查是否掉出界面底部
                    if (aiPlayer.y > this.canvas.height + 20) {
                        console.log(`AI移动时掉出界面底部，位置: ${Math.round(aiPlayer.y)}`);
                        // 立即触发界面底部检测
                        this.checkPlayerBounds();
                    }
                    
                    currentStep++;
                }, 100);
            }
            
            aiFly(aiPlayer, humanPlayer) {
                if (aiPlayer.hasFlownThisTurn) {
                    this.aiMove(aiPlayer, humanPlayer);
                    return;
                }
                
                // 切换到飞行模式
                aiPlayer.flyMode = true;
                
                // 选择飞行目标位置
                const targetPos = this.chooseFlyTarget(aiPlayer, humanPlayer);
                const dx = targetPos.x - aiPlayer.x;
                const dy = targetPos.y - aiPlayer.y;
                const flyAngle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                aiPlayer.angle = Math.max(0, Math.min(180, flyAngle));
                
                // 模拟飞行蓄力
                setTimeout(() => {
                    if (this.gameState !== 'playing' || this.currentPlayer !== 2) {
                        aiPlayer.aiActionInProgress = false;
                        return;
                    }
                    
                    // 根据难度调整飞行精度
                    const config = this.getAIConfig();
                    const basePower = 0.7;
                    const powerRange = 0.3;
                    const accuracy = config.flightAccuracy;
                    const power = basePower + (Math.random() - 0.5) * powerRange * (2 - accuracy);
                    const radians = (aiPlayer.angle * Math.PI) / 180;
                    
                    // 执行飞行
                    aiPlayer.isFlying = true;
                    aiPlayer.hasFlownThisTurn = true;
                    aiPlayer.onGround = false;
                    aiPlayer.standingOnObstacle = false;
                    aiPlayer.currentSupportingObstacle = null;
                    
                    const baseSpeed = 15.4;
                    aiPlayer.flyVelocityX = Math.cos(radians) * power * baseSpeed;
                    aiPlayer.flyVelocityY = -Math.sin(radians) * power * baseSpeed;
                    
                    this.createFlyStartEffect(aiPlayer.x, aiPlayer.y);
                    aiPlayer.aiActionInProgress = false;
                    
                    // 飞行结束后，AI会在着陆时自动切换到移动模式，然后在下个回合可以行动
                }, 800 + Math.random() * 700);
            }
            
            findBetterPosition(aiPlayer, humanPlayer) {
                // 高级AI使用智能位置分析
                if (this.aiDifficulty === 'hard') {
                    return this.findOptimalPosition(aiPlayer, humanPlayer);
                }
                
                // 寻找更好的攻击位置
                const currentDistance = Math.abs(aiPlayer.x - humanPlayer.x);
                
                // 检查当前位置是否在弹坑中
                const currentHeight = this.getTerrainHeight(aiPlayer.x);
                const originalHeight = this.getOriginalTerrainHeight ? this.getOriginalTerrainHeight(aiPlayer.x) : currentHeight;
                const inCrater = currentHeight - originalHeight > 30; // 如果当前高度比原始高度高30像素以上，说明在弹坑中
                
                // 如果在弹坑中，优先寻找安全位置
                if (inCrater) {
                    for (let testX = aiPlayer.x - 100; testX <= aiPlayer.x + 100; testX += 20) {
                        if (testX < 50 || testX > this.canvas.width - 50) continue;
                        
                        const testHeight = this.getTerrainHeight(testX);
                        const testOriginalHeight = this.getOriginalTerrainHeight ? this.getOriginalTerrainHeight(testX) : testHeight;
                        const testInCrater = testHeight - testOriginalHeight > 30;
                        
                        if (!testInCrater) {
                            return testX; // 找到安全位置
                        }
                    }
                }
                
                // 如果距离太近，尝试拉开距离
                if (currentDistance < 200) {
                    return aiPlayer.x < humanPlayer.x ? 
                        Math.max(50, aiPlayer.x - 100) : 
                        Math.min(this.canvas.width - 50, aiPlayer.x + 100);
                }
                
                // 如果距离太远，尝试靠近
                if (currentDistance > 500) {
                    return aiPlayer.x < humanPlayer.x ? 
                        Math.min(humanPlayer.x - 150, aiPlayer.x + 100) :
                        Math.max(humanPlayer.x + 150, aiPlayer.x - 100);
                }
                
                // 距离适中，寻找高度优势
                const terrainHeight = this.getTerrainHeight(aiPlayer.x);
                const humanTerrainHeight = this.getTerrainHeight(humanPlayer.x);
                
                if (terrainHeight > humanTerrainHeight + 50) {
                    // 当前位置较高，保持位置或稍微调整
                    return aiPlayer.x + (Math.random() - 0.5) * 100;
                }
                
                // 寻找更高的位置
                return humanPlayer.x + (Math.random() - 0.5) * 200;
            }
            
            findOptimalPosition(aiPlayer, humanPlayer) {
                // 高级AI的智能位置选择
                const candidates = [];
                
                // 分析多个候选位置
                for (let x = 100; x < this.canvas.width - 100; x += 80) {
                    const score = this.evaluatePosition(x, aiPlayer, humanPlayer);
                    candidates.push({ x, score });
                }
                
                // 按分数排序，选择最佳位置
                candidates.sort((a, b) => b.score - a.score);
                
                // 从前3个最佳位置中随机选择（增加不可预测性）
                const topCandidates = candidates.slice(0, 3);
                const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                return selected.x;
            }
            
            evaluatePosition(x, aiPlayer, humanPlayer) {
                let score = 0;
                
                // 1. 安全性评估（避免弹坑）
                const terrainHeight = this.getTerrainHeight(x);
                const originalHeight = this.getOriginalTerrainHeight(x);
                const craterDepth = terrainHeight - originalHeight; // 修正：当前高度 - 原始高度 = 弹坑深度
                
                if (craterDepth > 80) score -= 100; // 深坑严重扣分
                else if (craterDepth > 40) score -= 50; // 浅坑中等扣分
                else if (craterDepth < 10) score += 20; // 平地加分
                
                // 2. 高度优势
                const humanHeight = this.getTerrainHeight(humanPlayer.x);
                const heightAdvantage = humanHeight - terrainHeight;
                score += heightAdvantage * 0.5;
                
                // 3. 距离优势（300-500像素为最佳射击距离）
                const distance = Math.abs(x - humanPlayer.x);
                if (distance >= 300 && distance <= 500) {
                    score += 30;
                } else if (distance < 200) {
                    score -= 20; // 太近危险
                } else if (distance > 600) {
                    score -= 10; // 太远不准
                }
                
                // 4. 射击角度优势
                const dx = humanPlayer.x - x;
                const dy = humanPlayer.y - terrainHeight;
                const angle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                if (angle >= 30 && angle <= 150) {
                    score += 15; // 好的射击角度
                }
                
                // 5. 地形遮挡分析
                const hasObstacles = this.checkTerrainObstacles(x, humanPlayer.x);
                if (!hasObstacles) {
                    score += 25; // 无遮挡加分
                } else {
                    score -= 15; // 有遮挡扣分
                }
                
                // 6. 逃生路线（周围是否有好的移动空间）
                const escapeRoutes = this.countEscapeRoutes(x);
                score += escapeRoutes * 5;
                
                return score;
            }
            
            checkTerrainObstacles(startX, endX) {
                // 检查两点之间是否有地形障碍
                const steps = Math.abs(endX - startX) / 20;
                const stepSize = (endX - startX) / steps;
                
                let maxHeight = 0;
                for (let i = 1; i < steps; i++) {
                    const checkX = startX + stepSize * i;
                    const height = this.getTerrainHeight(checkX);
                    maxHeight = Math.max(maxHeight, height);
                }
                
                const startHeight = this.getTerrainHeight(startX);
                const endHeight = this.getTerrainHeight(endX);
                const minHeight = Math.min(startHeight, endHeight);
                
                // 如果中间有比起点和终点都高的地形，则有障碍
                return maxHeight > minHeight + 50;
            }
            
            countEscapeRoutes(x) {
                // 计算逃生路线数量
                let routes = 0;
                
                // 检查左右两个方向
                for (let direction of [-1, 1]) {
                    let canEscape = true;
                    for (let distance = 50; distance <= 150; distance += 50) {
                        const checkX = x + direction * distance;
                        if (checkX < 50 || checkX > this.canvas.width - 50) {
                            canEscape = false;
                            break;
                        }
                        
                                                    const checkHeight = this.getTerrainHeight(checkX);
                            const checkOriginal = this.getOriginalTerrainHeight(checkX);
                            const checkCrater = checkHeight - checkOriginal;
                        
                        if (checkCrater > 60) {
                            canEscape = false;
                            break;
                        }
                    }
                    
                    if (canEscape) routes++;
                }
                
                return routes;
            }
            
            chooseFlyTarget(aiPlayer, humanPlayer) {
                // 高级AI使用智能飞行目标选择
                if (this.aiDifficulty === 'hard') {
                    return this.chooseOptimalFlyTarget(aiPlayer, humanPlayer);
                }
                
                // 选择飞行目标：优先选择高地或有利位置
                const obstacles = this.obstacles.filter(obs => obs.canLandOn);
                
                if (obstacles.length > 0 && Math.random() < 0.6) {
                    // 60%概率选择飞到障碍物上
                    const targetObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                    return { x: targetObstacle.x, y: targetObstacle.y - 50 };
                }
                
                // 否则选择地面的有利位置
                const targetX = humanPlayer.x + (Math.random() - 0.5) * 300;
                const clampedX = Math.max(100, Math.min(this.canvas.width - 100, targetX));
                const targetY = this.getTerrainHeight(clampedX) - 50;
                
                return { x: clampedX, y: targetY };
            }
            
            chooseOptimalFlyTarget(aiPlayer, humanPlayer) {
                // 高级AI的智能飞行目标选择
                const candidates = [];
                
                // 1. 评估障碍物平台
                const obstacles = this.obstacles.filter(obs => obs.canLandOn);
                for (let obstacle of obstacles) {
                    const score = this.evaluateFlyTarget(obstacle.x, obstacle.y - 50, aiPlayer, humanPlayer, true);
                    candidates.push({ 
                        x: obstacle.x, 
                        y: obstacle.y - 50, 
                        score, 
                        type: 'obstacle' 
                    });
                }
                
                // 2. 评估地面位置
                for (let x = 150; x < this.canvas.width - 150; x += 100) {
                    const y = this.getTerrainHeight(x) - 50;
                    const score = this.evaluateFlyTarget(x, y, aiPlayer, humanPlayer, false);
                    candidates.push({ 
                        x, 
                        y, 
                        score, 
                        type: 'ground' 
                    });
                }
                
                // 按分数排序
                candidates.sort((a, b) => b.score - a.score);
                
                // 选择最佳目标（带一点随机性）
                const topCandidates = candidates.slice(0, Math.min(3, candidates.length));
                const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                return { x: selected.x, y: selected.y };
            }
            
            evaluateFlyTarget(x, y, aiPlayer, humanPlayer, isObstacle) {
                let score = 0;
                
                // 1. 高度优势（越高越好，但不要太高）
                const heightAdvantage = humanPlayer.y - y;
                if (heightAdvantage > 0 && heightAdvantage < 200) {
                    score += heightAdvantage * 0.8;
                } else if (heightAdvantage >= 200) {
                    score += 100; // 大高度优势
                } else {
                    score -= Math.abs(heightAdvantage) * 0.3; // 高度劣势扣分
                }
                
                // 2. 距离优势（最佳射击距离）
                const distance = Math.sqrt((x - humanPlayer.x) ** 2 + (y - humanPlayer.y) ** 2);
                if (distance >= 250 && distance <= 450) {
                    score += 40; // 最佳射击距离
                } else if (distance < 200) {
                    score -= 30; // 太近危险
                } else if (distance > 600) {
                    score -= 20; // 太远难瞄准
                }
                
                // 3. 安全性（远离弹坑）
                if (!isObstacle) {
                    const terrainHeight = this.getTerrainHeight(x);
                    const originalHeight = this.getOriginalTerrainHeight(x);
                    const craterDepth = terrainHeight - originalHeight; // 修正：当前高度 - 原始高度 = 弹坑深度
                    
                    if (craterDepth > 60) {
                        score -= 80; // 弹坑位置严重扣分
                    } else if (craterDepth < 20) {
                        score += 30; // 平地加分
                    }
                }
                
                // 4. 射击角度优势
                const dx = humanPlayer.x - x;
                const dy = humanPlayer.y - y;
                const angle = Math.atan2(-dy, dx) * 180 / Math.PI;
                
                if (angle >= 20 && angle <= 160) {
                    score += 25; // 好的射击角度
                }
                
                // 5. 障碍物平台额外优势
                if (isObstacle) {
                    score += 35; // 障碍物平台天然优势
                    
                    // 检查障碍物是否被破坏
                    const obstacle = this.obstacles.find(obs => 
                        Math.abs(obs.x - x) < 10 && Math.abs(obs.y - (y + 50)) < 10
                    );
                    if (obstacle && obstacle.craters.length > 0) {
                        score -= obstacle.craters.length * 15; // 被破坏的障碍物扣分
                    }
                }
                
                // 6. 战术位置（侧翼攻击）
                const playerDirection = humanPlayer.x < this.canvas.width / 2 ? 1 : -1;
                const flankingPosition = (x - humanPlayer.x) * playerDirection > 0;
                if (flankingPosition) {
                    score += 20; // 侧翼位置加分
                }
                
                // 7. 逃生能力
                const escapeScore = this.evaluateEscapeOptions(x, y, isObstacle);
                score += escapeScore;
                
                return score;
            }
            
            evaluateEscapeOptions(x, y, isObstacle) {
                // 评估从该位置的逃生选项
                let escapeScore = 0;
                
                if (isObstacle) {
                    // 障碍物上可以继续飞行
                    escapeScore += 30;
                } else {
                    // 地面位置检查周围的移动空间
                    for (let direction of [-1, 1]) {
                        let canMove = true;
                        for (let distance = 50; distance <= 100; distance += 25) {
                            const checkX = x + direction * distance;
                            if (checkX < 50 || checkX > this.canvas.width - 50) {
                                canMove = false;
                                break;
                            }
                            
                                                    const checkHeight = this.getTerrainHeight(checkX);
                        const checkOriginal = this.getOriginalTerrainHeight(checkX);
                        if (checkHeight - checkOriginal > 50) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        if (canMove) escapeScore += 10;
                    }
                }
                
                return escapeScore;
            }
            
            cleanup() {
                // 清理游戏状态
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = [];
                this.burnEffects = [];
                this.craters = [];
                this.obstacles = [];
                
                // 清除定时器
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                if (this.chargeInterval) {
                    clearInterval(this.chargeInterval);
                    this.chargeInterval = null;
                }
                if (this.flyChargeInterval) {
                    clearInterval(this.flyChargeInterval);
                    this.flyChargeInterval = null;
                }
                
                // 重置玩家状态
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    player.hp = player.maxHP;
                    player.x = id == 1 ? 100 : 900;
                    player.y = 500;
                    delete player.burning;
                    delete player.aiActionInProgress;
                    player.isFlying = false;
                    player.flyMode = false;
                    player.flyPower = 0;
                    player.flyVelocityX = 0;
                    player.flyVelocityY = 0;
                    player.onGround = true;
                    player.hasFlownThisTurn = false;
                    player.isChargingFly = false;
                    player.standingOnObstacle = false;
                    player.currentSupportingObstacle = null;
                    player.skipPhysicsThisFrame = false;
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    // 添加轨迹
                    proj.trail.push({x: proj.x, y: proj.y});
                    if (proj.trail.length > 20) {
                        proj.trail.shift();
                    }
                    
                    // 更新位置
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.vy += 0.3; // 重力
                    
                    // 增加弹药的飞行时间计数器
                    if (!proj.flightTime) proj.flightTime = 0;
                    proj.flightTime++;
                    
                    // 检查特殊武器的空中爆炸条件
                    let shouldExplodeInAir = false;
                    
                    // 集束炸弹在飞行一定时间后空中爆炸
                    if (proj.weapon.type === 'cluster' && proj.flightTime > 60) {
                        shouldExplodeInAir = true;
                    }
                    
                    // 核弹在达到最高点时空中爆炸（增加威力范围）
                    if (proj.weapon.name === '核弹' && proj.vy > 0 && proj.flightTime > 30) {
                        shouldExplodeInAir = true;
                    }
                    
                    // 如果需要空中爆炸
                    if (shouldExplodeInAir) {
                        this.explode(proj.x, proj.y, proj.weapon, proj.player);
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // 检查地形碰撞
                    if (proj.y >= this.getTerrainHeight(proj.x) || 
                        proj.x < 0 || proj.x > this.canvas.width || proj.y > this.canvas.height) {
                        this.explode(proj.x, proj.y, proj.weapon, proj.player);
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // 检查障碍物碰撞
                    let hitObstacle = false;
                    for (let j = this.obstacles.length - 1; j >= 0; j--) {
                        const obstacle = this.obstacles[j];
                        if (proj.x >= obstacle.x - obstacle.width/2 && proj.x <= obstacle.x + obstacle.width/2 &&
                            proj.y >= obstacle.y - obstacle.height/2 && proj.y <= obstacle.y + obstacle.height/2) {
                            
                            // 在障碍物上创建弹坑，而不是摧毁整个障碍物
                            this.createObstacleCrater(obstacle, proj.x, proj.y, proj.weapon);
                            
                            // 弹药在障碍物位置爆炸
                            this.explode(proj.x, proj.y, proj.weapon, proj.player);
                            this.projectiles.splice(i, 1);
                            hitObstacle = true;
                            break;
                        }
                    }
                    
                    if (hitObstacle) continue;
                }
            }
            
            explode(x, y, weapon, playerNum, splitLevel = 0) {
                // 创建爆炸效果
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: weapon.radius,
                    color: weapon.color,
                    life: 30
                });
                
                // 创建粒子效果
                const particleCount = weapon.type === 'fire' ? 30 : 20;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: weapon.color,
                        life: weapon.type === 'fire' ? 80 : 60,
                        maxLife: weapon.type === 'fire' ? 80 : 60
                    });
                }
                
                // 检查伤害
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    const distance = Math.sqrt((player.x - x) ** 2 + (player.y - y) ** 2);
                    
                    if (distance <= weapon.radius) {
                        const damage = Math.floor(weapon.damage * (1 - distance / weapon.radius));
                        player.hp = Math.max(0, player.hp - damage);
                        
                        // 显示伤害数字
                        this.showDamage(player.x, player.y - 30, damage);
                        
                        // 被击中后立即更新物理状态，确保玩家会掉入弹坑
                        player.onGround = false; // 强制重新检查地面状态
                        player.standingOnObstacle = false; // 清除障碍物站立状态
                        player.currentSupportingObstacle = null;
                        
                        // 燃烧弹特殊效果：添加燃烧状态
                        if (weapon.type === 'fire') {
                            player.burning = {
                                duration: weapon.burnDuration * 60, // 转换为帧数
                                damage: weapon.burnDamage,
                                interval: 60 // 每秒伤害一次
                            };
                        }
                        
                        if (player.hp <= 0) {
                            this.gameOver(id == 1 ? 2 : 1);
                        }
                    }
                });
                
                // 特殊武器效果
                if (weapon.type === 'cluster' && splitLevel < weapon.splitCount) {
                    setTimeout(() => {
                        const subBombs = splitLevel === 0 ? 3 : 2; // 第一次分裂3个，后续分裂2个
                        for (let i = 0; i < subBombs; i++) {
                            const angle = (i * (360 / subBombs)) * Math.PI / 180;
                            const distance = 40 + splitLevel * 10;
                            const subX = x + Math.cos(angle) * distance;
                            const subY = y + Math.sin(angle) * distance;
                            this.explode(subX, subY, {
                                ...weapon,
                                damage: weapon.damage * (0.7 - splitLevel * 0.1),
                                radius: weapon.radius * (0.8 - splitLevel * 0.1)
                            }, playerNum, splitLevel + 1);
                        }
                    }, 300);
                }
                
                // 燃烧弹创建火焰区域
                if (weapon.type === 'fire') {
                    this.fireZones.push({
                        x: x,
                        y: y,
                        radius: weapon.radius * 0.8,
                        damage: weapon.burnDamage,
                        life: weapon.burnDuration * 60,
                        maxLife: weapon.burnDuration * 60
                    });
                }
                
                // 创建弹坑
                this.createCrater(x, y, weapon);
                
                this.updateUI();
                // 不在这里切换回合，由waitForProjectileEnd处理
            }
            
            showDamage(x, y, damage) {
                const damageText = document.createElement('div');
                damageText.textContent = `-${damage}`;
                damageText.style.position = 'absolute';
                damageText.style.left = x + 'px';
                damageText.style.top = y + 'px';
                damageText.style.color = '#FF0000';
                damageText.style.fontWeight = 'bold';
                damageText.style.fontSize = '20px';
                damageText.style.pointerEvents = 'none';
                damageText.style.zIndex = '1000';
                damageText.classList.add('explosion');
                
                document.body.appendChild(damageText);
                
                setTimeout(() => {
                    document.body.removeChild(damageText);
                }, 500);
            }
            
            updateExplosions() {
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    const explosion = this.explosions[i];
                    explosion.radius = Math.min(explosion.radius + 2, explosion.maxRadius);
                    explosion.life--;
                    
                    if (explosion.life <= 0) {
                        this.explosions.splice(i, 1);
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updateFireZones() {
                for (let i = this.fireZones.length - 1; i >= 0; i--) {
                    const zone = this.fireZones[i];
                    zone.life--;
                    
                    // 每秒检查一次火焰伤害
                    if (zone.life % 60 === 0) {
                        Object.keys(this.players).forEach(id => {
                            const player = this.players[id];
                            const distance = Math.sqrt((player.x - zone.x) ** 2 + (player.y - zone.y) ** 2);
                            
                            if (distance <= zone.radius) {
                                const damage = zone.damage;
                                player.hp = Math.max(0, player.hp - damage);
                                this.showDamage(player.x, player.y - 30, damage);
                                
                                if (player.hp <= 0) {
                                    this.gameOver(id == 1 ? 2 : 1);
                                }
                            }
                        });
                    }
                    
                    if (zone.life <= 0) {
                        this.fireZones.splice(i, 1);
                    }
                }
            }
            
            updateBurnEffects() {
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    if (player.burning) {
                        player.burning.duration--;
                        
                        // 每秒造成燃烧伤害
                        if (player.burning.duration % player.burning.interval === 0) {
                            const damage = player.burning.damage;
                            player.hp = Math.max(0, player.hp - damage);
                            this.showDamage(player.x, player.y - 40, damage);
                            
                            // 创建燃烧粒子效果
                            for (let i = 0; i < 3; i++) {
                                this.particles.push({
                                    x: player.x + (Math.random() - 0.5) * 20,
                                    y: player.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -Math.random() * 3,
                                    color: '#FF6347',
                                    life: 30,
                                    maxLife: 30
                                });
                            }
                            
                            if (player.hp <= 0) {
                                this.gameOver(id == 1 ? 2 : 1);
                            }
                        }
                        
                        if (player.burning.duration <= 0) {
                            delete player.burning;
                        }
                    }
                });
            }
            
            startTurn() {
                // 确保清除之前的定时器
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                
                this.isTurnActive = true;
                this.turnTimeLeft = 20;
                
                // 重置当前玩家的飞行状态
                const player = this.players[this.currentPlayer];
                player.hasFlownThisTurn = false;
                player.isChargingFly = false;
                
                this.showTurnNotification();
                this.updateUI();
                
                // 开始倒计时
                this.turnTimer = setInterval(() => {
                    // 检查游戏状态，如果游戏结束则清除定时器
                    if (this.gameState !== 'playing') {
                        clearInterval(this.turnTimer);
                        this.turnTimer = null;
                        return;
                    }
                    
                    this.turnTimeLeft--;
                    this.updateUI();
                    
                    if (this.turnTimeLeft <= 0) {
                        this.endTurn();
                    }
                }, 1000);
            }
            
            endTurn() {
                this.isTurnActive = false;
                
                // 清除回合定时器
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
                
                // 如果正在充能，停止充能
                if (this.isCharging) {
                    this.isCharging = false;
                    if (this.chargeInterval) {
                        clearInterval(this.chargeInterval);
                        this.chargeInterval = null;
                    }
                    document.getElementById('powerMeter').style.display = 'none';
                }
                
                // 如果正在飞行充能，停止飞行充能
                const player = this.players[this.currentPlayer];
                if (player.isChargingFly) {
                    player.isChargingFly = false;
                    player.flyPower = 0;
                    if (this.flyChargeInterval) {
                        clearInterval(this.flyChargeInterval);
                        this.flyChargeInterval = null;
                    }
                    document.getElementById('flyMeter').style.display = 'none';
                }
                
                // 等待一秒后切换到下一个玩家
                setTimeout(() => {
                    // 检查游戏状态，确保游戏仍在进行
                    if (this.gameState === 'playing') {
                        this.nextTurn();
                    }
                }, 1000);
            }
            
            nextTurn() {
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                this.startTurn();
            }
            
            showTurnNotification() {
                const notification = document.getElementById('turnNotification');
                const text = document.getElementById('turnNotificationText');
                const playerColor = this.players[this.currentPlayer].color;
                
                let notificationText = '';
                if (this.gameMode === 'single') {
                    notificationText = this.currentPlayer === 1 ? '你的回合开始!' : 'AI回合开始!';
                } else {
                    notificationText = `玩家${this.currentPlayer}的回合开始!`;
                }
                
                text.textContent = notificationText;
                text.style.color = playerColor;
                notification.style.display = 'block';
                
                // 2秒后隐藏提示
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }
            
            waitForProjectileEnd() {
                const checkProjectiles = () => {
                    // 如果游戏不在进行中，停止检查
                    if (this.gameState !== 'playing') {
                        return;
                    }
                    
                    if (this.projectiles.length === 0 && this.explosions.length === 0) {
                        setTimeout(() => {
                            // 再次检查游戏状态，确保没有在重新开始过程中
                            if (this.gameState === 'playing') {
                                this.nextTurn();
                            }
                        }, 1000);
                    } else {
                        setTimeout(checkProjectiles, 100);
                    }
                };
                
                setTimeout(checkProjectiles, 500);
            }
            
            toggleFlyMode() {
                if (!this.isTurnActive) return;
                
                const player = this.players[this.currentPlayer];
                const oldFlyMode = player.flyMode;
                player.flyMode = !player.flyMode;
                
                // 显示模式切换提示
                if (player.flyMode) {
                    this.showModeChangeNotification(player.x, player.y, '切换到飞行模式');
                } else {
                    this.showModeChangeNotification(player.x, player.y, '切换到移动模式');
                }
                
                if (!player.flyMode) {
                    // 退出飞行模式时，停止所有飞行相关状态
                    if (player.isChargingFly) {
                        player.isChargingFly = false;
                        clearInterval(this.flyChargeInterval);
                        document.getElementById('flyMeter').style.display = 'none';
                    }
                    if (player.isFlying) {
                        player.isFlying = false;
                        player.flyVelocityX = 0;
                        player.flyVelocityY = 0;
                    }
                    player.flyPower = 0;
                }
                
                this.updateUI();
            }
            
            startFlyCharging() {
                if (this.gameState !== 'playing' || !this.isTurnActive) return;
                
                const player = this.players[this.currentPlayer];
                if (!player.flyMode || player.isFlying || player.hasFlownThisTurn || player.isChargingFly) {
                    // 调试信息：显示无法飞行的原因
                    if (!player.flyMode) {
                        this.showModeChangeNotification(player.x, player.y, '请先切换到飞行模式');
                    } else if (player.hasFlownThisTurn) {
                        this.showModeChangeNotification(player.x, player.y, '本回合已飞行过');
                    } else if (player.isFlying) {
                        this.showModeChangeNotification(player.x, player.y, '正在飞行中');
                    } else if (player.isChargingFly) {
                        this.showModeChangeNotification(player.x, player.y, '正在蓄力中');
                    }
                    return;
                }
                
                player.isChargingFly = true;
                player.flyPower = 0;
                document.getElementById('flyMeter').style.display = 'flex';
                
                this.flyChargeInterval = setInterval(() => {
                    player.flyPower = Math.min(player.flyPower + 1.5, 100);
                    const flyFill = document.getElementById('flyFill');
                    if (flyFill) {
                        flyFill.style.width = player.flyPower + '%';
                    }
                }, 50);
            }
            
            fly() {
                const player = this.players[this.currentPlayer];
                if (!player.flyMode || player.flyPower <= 0 || !player.isChargingFly) return;
                
                clearInterval(this.flyChargeInterval);
                document.getElementById('flyMeter').style.display = 'none';
                
                // 计算飞行力度和方向
                const power = player.flyPower / 100;
                const radians = (player.angle * Math.PI) / 180;
                
                // 检查是否在障碍物上，需要额外推力
                const wasOnObstacle = player.standingOnObstacle;
                
                // 设置飞行状态
                player.isFlying = true;
                player.isChargingFly = false;
                player.hasFlownThisTurn = true;
                player.onGround = false;
                player.standingOnObstacle = false; // 清除障碍物站立状态，确保能够起飞
                player.currentSupportingObstacle = null; // 清除支撑障碍物引用
                
                // 根据蓄力程度设置初始速度 (降低30%)
                const baseSpeed = 15.4; // 从22降低30%到15.4
                player.flyVelocityX = Math.cos(radians) * power * baseSpeed;
                player.flyVelocityY = -Math.sin(radians) * power * baseSpeed;
                
                // 如果在障碍物上，确保有足够的垂直速度来脱离
                if (wasOnObstacle && Math.abs(player.flyVelocityY) < 3) {
                    player.flyVelocityY = player.flyVelocityY >= 0 ? -3 : player.flyVelocityY - 3;
                }
                player.flyPower = 0;
                
                // 给一个向上推力，确保能够脱离障碍物表面
                if (wasOnObstacle) {
                    player.y -= 10; // 向上移动10像素，确保完全脱离障碍物表面
                    // 如果角度向上，额外增加向上推力
                    if (player.angle > 90) {
                        player.y -= 5;
                    }
                    // 给飞行一个额外的向上初始速度
                    player.flyVelocityY -= 2;
                }
                
                // 创建飞行起始效果
                this.createFlyStartEffect(player.x, player.y);
                
                // 显示飞行开始提示
                const startMessage = wasOnObstacle ? '🚀 从平台起飞！' : '🚀 开始飞行！';
                this.showModeChangeNotification(player.x, player.y, startMessage);
                
                // 强制确保飞行状态立即生效，跳过一次物理更新
                player.skipPhysicsThisFrame = true;
                
                // 更新UI显示飞行状态
                this.updateUI();
            }
            
            updatePlayerPhysics(player) {
                // 如果标记跳过物理更新，清除标记并返回
                if (player.skipPhysicsThisFrame) {
                    player.skipPhysicsThisFrame = false;
                    return;
                }
                
                if (player.isFlying) {
                    // 飞行物理 - 抛物线运动
                    player.x += player.flyVelocityX;
                    player.y += player.flyVelocityY;
                    
                    // 重力影响
                    player.flyVelocityY += 0.28; // 进一步降低重力加速度，让飞行距离更远
                    
                    // 空气阻力（水平方向）
                    player.flyVelocityX *= 0.998; // 进一步减少空气阻力，让飞行距离更远
                    
                    // 边界检查
                    player.x = Math.max(20, Math.min(this.canvas.width - 20, player.x));
                    
                    // 检查是否撞到地面或障碍物
                    const groundHeight = this.getTerrainHeight(player.x);
                    let landedOnObstacle = false;
                    
                    // 检查障碍物刚体着陆
                    for (let obstacle of this.obstacles) {
                        if (obstacle.isSolid && obstacle.canLandOn) {
                            const obstacleLeft = obstacle.x - obstacle.width/2;
                            const obstacleRight = obstacle.x + obstacle.width/2;
                            const obstacleTop = obstacle.y - obstacle.height/2;
                            
                            // 检查玩家是否在障碍物范围内并接近顶部
                            if (player.x >= obstacleLeft - 15 && 
                                player.x <= obstacleRight + 15 &&
                                player.y >= obstacleTop - 40 && 
                                player.y <= obstacleTop + 25) {
                                
                                // 检查着陆位置是否被弹坑破坏
                                let canLand = true;
                                const relativeX = player.x - obstacle.x;
                                
                                for (let crater of obstacle.craters) {
                                    const distance = Math.sqrt(
                                        Math.pow(relativeX - crater.x, 2) + 
                                        Math.pow(0 - crater.y, 2)
                                    );
                                    if (distance <= crater.radius + 12) {
                                        canLand = false;
                                        break;
                                    }
                                }
                                
                                if (canLand) {
                                    // 成功着陆到障碍物刚体
                                    player.y = obstacleTop - 20;
                                    player.isFlying = false;
                                    player.flyVelocityX = 0;
                                    player.flyVelocityY = 0;
                                    player.onGround = true;
                                    // 着陆到障碍物后自动切换到攻击和移动模式
                                    player.flyMode = false;
                                    player.standingOnObstacle = true;
                                    
                                    this.createObstacleLandingEffect(player.x, player.y);
                                    this.showModeChangeNotification(player.x, player.y, '着陆在平台上，切换到移动模式');
                                    this.updateUI();
                                    landedOnObstacle = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // 如果没有着陆在障碍物上，检查地面着陆
                    if (!landedOnObstacle) {
                        // 检查是否应该着陆到地面
                        if (player.y >= groundHeight - 20) {
                            player.y = groundHeight - 20;
                            player.isFlying = false;
                            player.flyVelocityX = 0;
                            player.flyVelocityY = 0;
                            player.onGround = true;
                            
                            // 飞行结束后自动切换回普通模式
                            player.flyMode = false;
                            
                            // 着陆粒子效果
                            this.createLandingEffect(player.x, player.y);
                            
                            // 显示模式切换提示
                            this.showModeChangeNotification(player.x, player.y, '切换到移动模式');
                            
                            // 更新UI显示模式变化
                            this.updateUI();
                        }
                    }
                    
                    // 检查是否撞到顶部
                    if (player.y <= 20) {
                        player.y = 20;
                        player.flyVelocityY = Math.max(0, player.flyVelocityY); // 只允许向下
                    }
                    
                    // 如果飞行速度太小，视为飞行结束
                    if (Math.abs(player.flyVelocityX) < 0.5 && Math.abs(player.flyVelocityY) < 0.5) {
                        player.isFlying = false;
                        player.flyVelocityX = 0;
                        player.flyVelocityY = 0;
                        
                        // 飞行结束后统一切换到移动模式
                        player.flyMode = false;
                        if (player.standingOnObstacle) {
                            this.showModeChangeNotification(player.x, player.y, '飞行结束，切换到移动模式');
                        } else {
                            this.showModeChangeNotification(player.x, player.y, '切换到移动模式');
                        }
                        this.updateUI();
                    }
                } else {
                    // 地面物理 - 刚体碰撞系统
                    // 确保只有在非飞行状态下才执行地面物理
                    if (player.isFlying) return;
                    
                    const groundHeight = this.getTerrainHeight(player.x);
                    let supportingObstacle = null;
                    let supportHeight = groundHeight;
                    
                    // 检查所有障碍物的刚体碰撞
                    for (let obstacle of this.obstacles) {
                        if (obstacle.isSolid) {
                            const obstacleLeft = obstacle.x - obstacle.width/2;
                            const obstacleRight = obstacle.x + obstacle.width/2;
                            const obstacleTop = obstacle.y - obstacle.height/2;
                            
                            // 检查玩家是否在障碍物的水平范围内（增加容错范围）
                            if (player.x >= obstacleLeft - 8 && player.x <= obstacleRight + 8) {
                                // 检查玩家是否应该站在这个障碍物上
                                if (player.y >= obstacleTop - 30 && player.y <= obstacleTop + 15) {
                                    
                                    // 检查这个位置是否被弹坑破坏
                                    let canStand = true;
                                    const relativeX = player.x - obstacle.x;
                                    
                                    for (let crater of obstacle.craters) {
                                        const distance = Math.sqrt(
                                            Math.pow(relativeX - crater.x, 2) + 
                                            Math.pow(0 - crater.y, 2)
                                        );
                                        if (distance <= crater.radius + 8) {
                                            canStand = false;
                                            break;
                                        }
                                    }
                                    
                                    // 如果可以站立且这个障碍物比当前支撑面更高（即更靠近玩家）
                                    if (canStand && obstacleTop < supportHeight) {
                                        supportHeight = obstacleTop;
                                        supportingObstacle = obstacle;
                                    }
                                }
                            }
                        }
                    }
                    
                    // 应用物理
                    const targetY = supportHeight - 20;
                    
                    if (player.y < targetY - 2) {
                        // 重力下落到支撑面
                        player.y = Math.min(player.y + 6, targetY);
                        player.onGround = false;
                    } else if (player.y > targetY + 2) {
                        // 如果玩家高于支撑面太多，开始下落
                        player.y = Math.max(player.y - 3, targetY);
                        player.onGround = (player.y <= targetY + 1);
                    } else {
                        // 站立在支撑面上（允许小范围波动）
                        player.y = targetY;
                        player.onGround = true;
                    }
                    
                    // 更新站立状态
                    if (supportingObstacle && player.onGround) {
                        player.standingOnObstacle = true;
                        player.currentSupportingObstacle = supportingObstacle; // 记录当前支撑的障碍物
                    } else {
                        player.standingOnObstacle = false;
                        player.currentSupportingObstacle = null;
                    }
                }
            }
            
            createFlyStartEffect(x, y) {
                // 创建飞行起始粒子效果
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 15,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 6,
                        vy: Math.random() * 4 + 2, // 向下的粒子表示起飞
                        color: '#00BFFF',
                        life: 30,
                        maxLife: 30
                    });
                }
                
                // 添加一些白色粒子表示推进力
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 12,
                        y: y + 5 + (Math.random() - 0.5) * 8,
                        vx: (Math.random() - 0.5) * 3,
                        vy: Math.random() * 6 + 1,
                        color: '#FFFFFF',
                        life: 20,
                        maxLife: 20
                    });
                }
            }
            
            createObstacleLandingEffect(x, y) {
                // 创建障碍物着陆粒子效果 - 金色主题
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 30,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -Math.random() * 8,
                        color: '#FFD700', // 金色
                        life: 45,
                        maxLife: 45
                    });
                }
                
                // 添加一些橙色粒子表示平台接触
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 25,
                        y: y - 5 + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -Math.random() * 5,
                        color: '#FFA500', // 橙色
                        life: 30,
                        maxLife: 30
                    });
                }
                
                // 添加一些白色闪光效果
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3,
                        color: '#FFFFFF',
                        life: 25,
                        maxLife: 25,
                        size: 3 // 更大的粒子
                    });
                }
            }
            
            createLandingEffect(x, y) {
                // 创建着陆粒子效果
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 25,
                        y: y + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6,
                        color: '#8B4513',
                        life: 40,
                        maxLife: 40
                    });
                }
                
                // 添加一些蓝色粒子表示飞行结束
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y - 10 + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3,
                        color: '#87CEEB',
                        life: 35,
                        maxLife: 35
                    });
                }
            }
            
            checkObstacleCollision(player) {
                // 检查玩家与障碍物的刚体碰撞
                for (let obstacle of this.obstacles) {
                    if (obstacle.isSolid) {
                        const obstacleLeft = obstacle.x - obstacle.width/2;
                        const obstacleRight = obstacle.x + obstacle.width/2;
                        const obstacleTop = obstacle.y - obstacle.height/2;
                        const obstacleBottom = obstacle.y + obstacle.height/2;
                        
                        const playerLeft = player.x - 10;
                        const playerRight = player.x + 10;
                        const playerTop = player.y - 10;
                        const playerBottom = player.y + 10;
                        
                        // 检查AABB碰撞
                        if (playerRight > obstacleLeft && 
                            playerLeft < obstacleRight && 
                            playerBottom > obstacleTop && 
                            playerTop < obstacleBottom) {
                            
                            // 检查这个位置是否被弹坑破坏
                            let isDestroyed = false;
                            const relativeX = player.x - obstacle.x;
                            const relativeY = player.y - obstacle.y;
                            
                            for (let crater of obstacle.craters) {
                                const distance = Math.sqrt(
                                    Math.pow(relativeX - crater.x, 2) + 
                                    Math.pow(relativeY - crater.y, 2)
                                );
                                if (distance <= crater.radius) {
                                    isDestroyed = true;
                                    break;
                                }
                            }
                            
                            // 如果没有被破坏，则发生碰撞
                            if (!isDestroyed) {
                                return obstacle;
                            }
                        }
                    }
                }
                return null;
            }
            
            createObstacleCrater(obstacle, hitX, hitY, weapon) {
                // 计算弹坑在障碍物上的相对位置
                const relativeX = hitX - obstacle.x;
                const relativeY = hitY - obstacle.y;
                
                // 根据武器类型确定弹坑大小（调整为更合理的消耗比例）
                let craterRadius = 18; // 普通炸弹
                if (weapon.name === '超级炸弹') craterRadius = 28;
                else if (weapon.name === '穿甲弹') craterRadius = 15;
                else if (weapon.name === '集束炸弹') craterRadius = 12; // 集束弹单个弹坑较小
                else if (weapon.name === '连射炸弹') craterRadius = 10; // 连射弹坑较小
                else if (weapon.name === '燃烧弹') craterRadius = 20;
                else if (weapon.name === '散射弹') craterRadius = 8; // 散射弹坑很小
                else if (weapon.name === '核弹') craterRadius = 35; // 核弹弹坑最大
                
                // 检查是否与现有弹坑重叠，如果重叠则扩大现有弹坑
                let merged = false;
                for (let existingCrater of obstacle.craters) {
                    const distance = Math.sqrt(
                        Math.pow(existingCrater.x - relativeX, 2) + 
                        Math.pow(existingCrater.y - relativeY, 2)
                    );
                    
                    // 如果距离小于两个弹坑半径之和的80%，则合并
                    if (distance < (existingCrater.radius + craterRadius) * 0.8) {
                        // 扩大现有弹坑
                        existingCrater.radius = Math.max(existingCrater.radius, 
                            existingCrater.radius + craterRadius * 0.3);
                        merged = true;
                        break;
                    }
                }
                
                // 如果没有合并，则添加新弹坑
                if (!merged) {
                    obstacle.craters.push({
                        x: relativeX,
                        y: relativeY,
                        radius: craterRadius,
                        weapon: weapon
                    });
                }
                
                // 创建爆炸粒子效果
                const debrisCount = 8;
                const baseColor = obstacle.type === 'platform' ? '#8B7355' : '#E0E0E0';
                
                for (let i = 0; i < debrisCount; i++) {
                    this.particles.push({
                        x: hitX + (Math.random() - 0.5) * craterRadius,
                        y: hitY + (Math.random() - 0.5) * craterRadius,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6 - 1,
                        color: baseColor,
                        life: 40 + Math.random() * 30,
                        maxLife: 40 + Math.random() * 30
                    });
                }
            }
            
            showModeChangeNotification(x, y, text) {
                // 创建模式切换提示
                const notification = document.createElement('div');
                notification.textContent = text;
                notification.style.position = 'absolute';
                notification.style.left = (x - 50) + 'px';
                notification.style.top = (y - 40) + 'px';
                notification.style.color = '#87CEEB';
                notification.style.fontWeight = 'bold';
                notification.style.fontSize = '14px';
                notification.style.pointerEvents = 'none';
                notification.style.zIndex = '1000';
                notification.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
                notification.style.animation = 'fadeUpOut 2s ease-out forwards';
                
                // 添加CSS动画
                if (!document.getElementById('modeChangeStyle')) {
                    const style = document.createElement('style');
                    style.id = 'modeChangeStyle';
                    style.textContent = `
                        @keyframes fadeUpOut {
                            0% {
                                opacity: 1;
                                transform: translateY(0);
                            }
                            100% {
                                opacity: 0;
                                transform: translateY(-30px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(notification);
                
                // 2秒后移除提示
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 2000);
            }
            
            createCrater(x, y, weapon) {
                // 所有爆炸都可以影响地形，根据距离地面的高度调整威力
                const groundHeight = this.getTerrainHeight(x);
                const distanceToGround = Math.abs(y - groundHeight);
                
                // 计算爆炸对地形的影响力，距离越近影响越大
                const maxEffectiveDistance = weapon.radius * 2; // 最大有效距离
                let effectMultiplier = 1.0;
                
                if (distanceToGround > maxEffectiveDistance) {
                    // 距离太远，没有影响
                    return;
                } else if (distanceToGround > weapon.radius) {
                    // 距离较远，影响力衰减
                    effectMultiplier = 1.0 - (distanceToGround - weapon.radius) / weapon.radius;
                }
                // 距离很近或在地面以下，保持最大影响力
                
                const craterRadius = weapon.radius * 1.0 * effectMultiplier; // 弹坑半径根据距离调整
                const craterDepth = weapon.damage * 2.2 * effectMultiplier; // 增加弹坑深度倍数，确保底部地形也能形成明显弹坑
                
                // console.log(`创建弹坑 - 爆炸位置: (${Math.round(x)}, ${Math.round(y)}), 地面高度: ${Math.round(groundHeight)}, 距离: ${Math.round(distanceToGround)}, 影响倍数: ${effectMultiplier.toFixed(2)}`);
                
                // 直接修改地形数据，传递爆炸位置用于计算冲击波影响
                this.modifyTerrain(x, craterRadius, craterDepth, y);
                
                // 获取挖掘后的新地形高度
                const newGroundHeight = this.getTerrainHeight(x);
                
                // console.log(`弹坑创建后 - 新高度: ${Math.round(newGroundHeight)}, 高度变化: ${Math.round(newGroundHeight - groundHeight)}`);
                
                // 记录弹坑信息用于视觉效果（使用爆炸位置和地面高度中较低的位置）
                this.craters.push({
                    x: x,
                    y: Math.max(y, newGroundHeight), // 使用爆炸位置和新地面高度中较低的位置
                    radius: craterRadius,
                    depth: craterDepth,
                    age: 0 // 弹坑年龄，用于视觉效果
                });
            }
            
            modifyTerrain(centerX, radius, depth, explosionY = null) {
                // 修改地形数据，创建真实的弹坑
                const startIndex = Math.max(0, Math.floor((centerX - radius) / 10));
                const endIndex = Math.min(this.terrain.length - 1, Math.floor((centerX + radius) / 10));
                
                // 记录修改前的中心点高度（用于调试）
                const centerIndex = Math.floor(centerX / 10);
                const beforeHeight = this.terrain[centerIndex]?.height;
                
                // 增强的弹坑挖掘算法
                for (let i = startIndex; i <= endIndex; i++) {
                    const terrainPoint = this.terrain[i];
                    const distance = Math.abs(terrainPoint.x - centerX);
                    
                    if (distance <= radius) {
                        // 计算地形破坏深度，考虑爆炸位置
                        let actualDepth = depth;
                        
                        if (explosionY !== null) {
                            // 如果爆炸在地形上方，根据高度差调整破坏深度
                            const heightDiff = explosionY - terrainPoint.height;
                            if (heightDiff < 0) {
                                // 爆炸在地形上方，冲击波向下传播
                                const airDistance = Math.abs(heightDiff);
                                const penetrationFactor = Math.max(0.2, 1.0 - airDistance / (radius * 2));
                                actualDepth *= penetrationFactor;
                            }
                        }
                        
                        // 使用更陡峭的抛物线函数，创建更明显的弹坑
                        const normalizedDistance = distance / radius;
                        
                        // 三种深度函数供选择
                        let depthFactor;
                        if (normalizedDistance < 0.3) {
                            // 弹坑中心：保持最大深度
                            depthFactor = 1.0;
                        } else if (normalizedDistance < 0.7) {
                            // 弹坑中间：陡峭下降
                            const t = (normalizedDistance - 0.3) / 0.4;
                            depthFactor = 1.0 - (t * t * t); // 立方衰减，保持深度
                        } else {
                            // 弹坑边缘：快速衰减到0
                            const t = (normalizedDistance - 0.7) / 0.3;
                            depthFactor = (1 - t) * (1 - t) * 0.3; // 边缘快速衰减
                        }
                        
                        const finalDepth = actualDepth * depthFactor;
                        const originalHeight = terrainPoint.height;
                        
                        // 修改地形高度（向下挖掘）- 在Canvas坐标系中，向下挖掘应该增加Y坐标
                        terrainPoint.height += finalDepth;
                        
                        // 移除深度限制，允许地形被完全销毁
                        // 玩家可以掉出游戏界面，这时会触发深坑失败判定
                        
                        // 记录弹坑标记，用于智能平滑
                        if (finalDepth > 2) { // 降低阈值，让轻微的挖掘也能被记录
                            terrainPoint.hasCrater = true;
                            terrainPoint.craterDepth = (terrainPoint.craterDepth || 0) + finalDepth;
                        }
                    }
                }
                
                // 智能平滑，保护弹坑形状
                this.smartSmoothTerrain(startIndex, endIndex, centerX, radius);
                
                // 可选：调试信息
                if (false) { // 设为true启用调试
                    const finalHeight = this.terrain[centerIndex]?.height;
                    const digDepth = finalHeight - beforeHeight;
                    console.log(`弹坑创建完成 - 位置: (${Math.round(centerX)}, ${Math.round(beforeHeight)} -> ${Math.round(finalHeight)}), 挖掘深度: ${Math.round(digDepth)}像素`);
                    
                    // 特别标记深度挖掘情况
                    if (finalHeight > this.canvas.height) {
                        console.log(`🔍 地形已被挖掘到界面底部以下 - 最终高度: ${Math.round(finalHeight)}, 界面高度: ${this.canvas.height}`);
                    }
                }
            }
            
            smartSmoothTerrain(startIndex, endIndex, centerX, radius) {
                // 专门为弹坑设计的智能平滑算法：保护弹坑形状，只平滑边缘
                
                // 只对弹坑外围边缘进行轻微平滑，完全保护弹坑内部
                const edgeRange = Math.max(1, Math.ceil(radius / 30)); // 最小1个点，根据半径调整
                const actualStart = Math.max(0, startIndex - edgeRange);
                const actualEnd = Math.min(this.terrain.length - 1, endIndex + edgeRange);
                
                for (let i = actualStart; i < actualEnd; i++) {
                    // 只处理弹坑边界外的点
                    if (i < startIndex || i > endIndex) {
                        const prev = this.terrain[Math.max(0, i - 1)].height;
                        const current = this.terrain[i].height;
                        const next = this.terrain[Math.min(this.terrain.length - 1, i + 1)].height;
                        
                        // 计算距离弹坑中心的距离
                        const distanceFromCenter = Math.abs(this.terrain[i].x - centerX);
                        
                        // 只对距离弹坑边缘较远的点进行轻微平滑
                        if (distanceFromCenter > radius * 0.9) {
                            // 距离越远，平滑强度越大
                            const distanceFactor = Math.min(1, (distanceFromCenter - radius) / (radius * 0.5));
                            const smoothFactor = 0.15 + distanceFactor * 0.15; // 15-30%的平滑强度
                            
                            const smoothed = (prev + current * 3 + next) / 5;
                            this.terrain[i].height = current * (1 - smoothFactor) + smoothed * smoothFactor;
                        }
                    }
                    // 弹坑内部和近边缘区域完全不平滑，保持原始形状
                }
            }
            
            smoothTerrain(startIndex, endIndex) {
                // 传统平滑算法（现在主要用smartSmoothTerrain）
                const smoothRange = 1;
                const actualStart = Math.max(0, startIndex - smoothRange);
                const actualEnd = Math.min(this.terrain.length - 1, endIndex + smoothRange);
                
                for (let i = actualStart + 1; i < actualEnd; i++) {
                    const prev = this.terrain[i - 1].height;
                    const current = this.terrain[i].height;
                    const next = this.terrain[i + 1].height;
                    
                    // 轻微平滑
                    this.terrain[i].height = (prev + current * 3 + next) / 5;
                }
            }
            
            getOriginalTerrainHeight(x) {
                // 获取原始地形高度（不考虑弹坑影响）
                const index = Math.floor(x / 10);
                if (index >= 0 && index < this.terrain.length) {
                    return this.terrain[index].originalHeight || this.terrain[index].height;
                }
                return 500;
            }
            
            checkPlayerBounds() {
                if (this.gameState !== 'playing') return;
                
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    
                    // 检查玩家是否掉出游戏界面底部（掉入深坑）
                    // 使用更宽松的检测范围，确保玩家真正掉出界面
                    if (player.y > this.canvas.height + 20) {
                        // 玩家掉出界面底部，判定为掉入深坑失败
                        if (this.gameState === 'playing') {
                            this.gameState = 'gameOver';
                            const winner = id == 1 ? 2 : 1;
                            console.log(`玩家${id}掉出游戏界面 - 位置: (${Math.round(player.x)}, ${Math.round(player.y)}), 界面高度: ${this.canvas.height}`);
                            this.showFallOutMessage(id, true);
                            setTimeout(() => {
                                this.gameOver(winner);
                            }, 1500);
                        }
                        return;
                    }
                });
            }
            
            analyzePlayerCraterSituation(player) {
                // 重新设计的精确深坑分析
                const currentHeight = this.getTerrainHeight(player.x);
                const originalHeight = this.getOriginalTerrainHeight(player.x);
                
                // 计算弹坑深度：当前地形高度 - 原始地形高度
                const actualDepth = currentHeight - originalHeight;
                
                // 玩家脚底位置（玩家中心Y + 10，因为玩家高度20）
                const playerBottomY = player.y + 10;
                
                // 检查玩家是否在弹坑中（弹坑深度超过40像素且玩家在坑内）
                const inCrater = actualDepth > 40 && playerBottomY > originalHeight;
                
                // 检查玩家与坑底的距离
                const distanceToBottom = Math.abs(playerBottomY - currentHeight);
                const nearBottom = distanceToBottom < 30; // 距离坑底30像素内
                
                // 检查是否是深坑（深度超过80像素）
                const isDeepCrater = actualDepth > 80;
                
                // 检查玩家是否在坑中且无法轻易逃脱
                const trapped = inCrater && this.isPlayerTrappedInCrater(player, actualDepth);
                
                // 检查玩家是否正在下落到深坑中
                const fallingIntoDeepCrater = !player.onGround && 
                                            playerBottomY > originalHeight - 10 && 
                                            playerBottomY < currentHeight + 20 &&
                                            isDeepCrater;
                
                // 综合判断是否应该触发深坑游戏结束
                const shouldTriggerGameOver = (isDeepCrater && (nearBottom || trapped)) || fallingIntoDeepCrater;
                
                return {
                    inCrater,
                    nearBottom,
                    actualDepth,
                    isDeepCrater,
                    trapped,
                    fallingIntoDeepCrater,
                    shouldTriggerGameOver,
                    playerBottomY,
                    currentHeight,
                    originalHeight
                };
            }
            
            isPlayerTrappedInCrater(player, craterDepth) {
                // 检查玩家是否被困在深坑中，无法轻易逃脱
                if (craterDepth < 60) return false; // 浅坑不算被困
                
                const escapeDistance = 100; // 逃脱检查距离
                const maxClimbHeight = 40; // 玩家能爬的最大高度差
                
                // 检查左右两个方向是否有逃脱路径
                for (let direction of [-1, 1]) {
                    let canEscape = false;
                    
                    // 逐步检查逃脱路径
                    for (let step = 20; step <= escapeDistance; step += 20) {
                        const checkX = player.x + direction * step;
                        
                        // 边界检查
                        if (checkX < 50 || checkX > this.canvas.width - 50) break;
                        
                        const checkCurrentHeight = this.getTerrainHeight(checkX);
                        const checkOriginalHeight = this.getOriginalTerrainHeight(checkX);
                        const checkCraterDepth = checkCurrentHeight - checkOriginalHeight;
                        
                        // 如果找到明显更浅的位置
                        if (checkCraterDepth < craterDepth - 30) {
                            // 检查从当前位置到这个位置的坡度是否可爬
                            const playerCurrentHeight = this.getTerrainHeight(player.x);
                            const heightDiff = checkCurrentHeight - playerCurrentHeight;
                            
                            // 如果高度差在可爬范围内，找到逃脱路径
                            if (Math.abs(heightDiff) <= maxClimbHeight) {
                                canEscape = true;
                                break;
                            }
                        }
                    }
                    
                    if (canEscape) return false; // 找到逃脱路径，不算被困
                }
                
                return true; // 两个方向都无法逃脱，算被困
            }
            
            isPlayerTrapped(player, currentHeight, originalHeight) {
                // 检查玩家是否被困在弹坑中（周围地形都比较高）
                const actualDepth = currentHeight - originalHeight;
                
                // 只有在真正的弹坑中才检查是否被困
                if (actualDepth < 40) return false;
                
                const checkRadius = 120; // 检查半径
                const escapeThreshold = Math.min(actualDepth * 0.7, 50); // 动态逃脱阈值
                
                let canEscape = false;
                
                // 检查左右方向是否有逃脱路径
                for (let direction of [-1, 1]) {
                    for (let distance = 40; distance <= checkRadius; distance += 25) {
                        const checkX = player.x + direction * distance;
                        if (checkX < 50 || checkX > this.canvas.width - 50) continue;
                        
                        const checkHeight = this.getTerrainHeight(checkX);
                        const checkOriginal = this.getOriginalTerrainHeight(checkX);
                        const checkDepth = checkHeight - checkOriginal;
                        
                        // 如果找到深度明显更浅的位置（逃脱路径）
                        if (checkDepth < actualDepth - escapeThreshold) {
                            canEscape = true;
                            break;
                        }
                    }
                    if (canEscape) break;
                }
                
                return !canEscape && actualDepth > 60;
            }
            
            checkEscapeability(player, currentHeight, originalHeight) {
                // 检查玩家是否无法从当前位置逃脱
                const actualDepth = currentHeight - originalHeight;
                
                // 如果弹坑不够深，不算无法逃脱
                if (actualDepth < 60) return false;
                
                const playerBottomY = player.y + 10; // 玩家底部位置
                const craterBottomY = currentHeight - 20; // 弹坑底部位置
                
                // 玩家必须在弹坑底部附近
                if (Math.abs(playerBottomY - craterBottomY) > 30) return false;
                
                // 检查玩家是否能够通过移动逃出弹坑
                const escapeDistance = 80; // 逃脱检查距离
                
                for (let direction of [-1, 1]) {
                    let canClimbOut = true;
                    
                    // 检查逃脱路径上的地形坡度
                    for (let step = 20; step <= escapeDistance; step += 20) {
                        const checkX = player.x + direction * step;
                        if (checkX < 50 || checkX > this.canvas.width - 50) {
                            canClimbOut = false;
                            break;
                        }
                        
                        const checkHeight = this.getTerrainHeight(checkX);
                        const heightDiff = checkHeight - currentHeight;
                        const maxClimbableHeight = step * 0.8; // 可攀爬的最大高度
                        
                        // 如果坡度太陡，无法攀爬
                        if (heightDiff > maxClimbableHeight) {
                            canClimbOut = false;
                            break;
                        }
                    }
                    
                    if (canClimbOut) return false; // 找到逃脱路径
                }
                
                return true; // 无法逃脱
            }
            
            showFallOutMessage(playerId, isDeepCrater = false) {
                const player = this.players[playerId];
                const message = isDeepCrater ? '掉入深坑!' : '掉出界面!';
                
                // 根据游戏模式显示不同的消息
                let displayText = '';
                if (this.gameMode === 'single') {
                    displayText = playerId == 1 ? `你 ${message}` : `AI ${message}`;
                } else {
                    displayText = `玩家${playerId} ${message}`;
                }
                
                // 创建掉落提示
                const notification = document.createElement('div');
                notification.textContent = displayText;
                notification.style.position = 'absolute';
                notification.style.left = '50%';
                notification.style.top = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.color = '#FF0000';
                notification.style.fontWeight = 'bold';
                notification.style.fontSize = '24px';
                notification.style.pointerEvents = 'none';
                notification.style.zIndex = '1000';
                notification.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                notification.style.background = 'rgba(0,0,0,0.7)';
                notification.style.padding = '20px 40px';
                notification.style.borderRadius = '10px';
                notification.style.animation = 'pulse 0.5s infinite';
                
                document.body.appendChild(notification);
                
                // 1.5秒后移除提示
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 1500);
            }
            
            gameOver(winner) {
                this.gameState = 'gameOver';
                document.getElementById('winnerText').textContent = `玩家${winner}获胜!`;
                document.getElementById('gameOver').style.display = 'flex';
            }
            
            restart() {
                // 重置游戏核心状态
                this.gameState = 'playing';
                this.currentPlayer = 1;
                this.isCharging = false;
                this.chargePower = 0;
                this.turnTimeLeft = 20;
                this.isTurnActive = false; // 先设为false，startTurn会设为true
                
                // 清理游戏对象
                this.projectiles = [];
                this.explosions = [];
                this.particles = [];
                this.fireZones = [];
                this.burnEffects = [];
                this.craters = [];
                this.obstacles = [];
                
                // 清除所有定时器
                clearInterval(this.turnTimer);
                clearInterval(this.chargeInterval);
                clearInterval(this.flyChargeInterval);
                this.turnTimer = null;
                this.chargeInterval = null;
                this.flyChargeInterval = null;
                
                // 重置玩家状态
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    player.hp = player.maxHP;
                    player.x = id == 1 ? 100 : 900;
                    player.y = 500;
                    
                    // 清除所有状态
                    delete player.burning;
                    player.isFlying = false;
                    player.flyMode = false;
                    player.flyPower = 0;
                    player.flyVelocityX = 0;
                    player.flyVelocityY = 0;
                    player.onGround = true;
                    player.hasFlownThisTurn = false;
                    player.isChargingFly = false;
                    player.standingOnObstacle = false;
                    player.currentSupportingObstacle = null;
                    player.skipPhysicsThisFrame = false;
                });
                
                // 重新生成地形和障碍物
                this.generateTerrain();
                
                // 隐藏所有UI元素
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('weaponSelector').style.display = 'none';
                document.getElementById('powerMeter').style.display = 'none';
                document.getElementById('flyMeter').style.display = 'none';
                document.getElementById('turnNotification').style.display = 'none';
                
                // 最后启动新回合
                setTimeout(() => {
                    this.startTurn();
                }, 100); // 给一个小延迟确保所有状态都已重置
            }
            
            updateUI() {
                const currentTurnElement = document.getElementById('currentTurn');
                const turnTimerElement = document.getElementById('turnTimer');
                const player = this.players[this.currentPlayer];
                
                let playerStatus = '';
                if (this.gameMode === 'single') {
                    if (this.currentPlayer === 1) {
                        playerStatus = '你的回合';
                    } else {
                        const difficultyNames = {
                            'easy': '初级AI',
                            'medium': '中级AI', 
                            'hard': '高级AI'
                        };
                        playerStatus = `${difficultyNames[this.aiDifficulty]}思考中...`;
                    }
                } else {
                    playerStatus = `玩家${this.currentPlayer}回合`;
                }
                
                if (player.flyMode) {
                    if (player.hasFlownThisTurn) {
                        playerStatus += ' (已飞行)';
                    } else {
                        playerStatus += ' (飞行模式)';
                    }
                }
                currentTurnElement.textContent = playerStatus;
                currentTurnElement.style.color = this.players[this.currentPlayer].color;
                
                // 更新倒计时
                if (this.isTurnActive) {
                    turnTimerElement.textContent = `剩余时间: ${this.turnTimeLeft}秒`;
                    if (this.turnTimeLeft <= 5) {
                        turnTimerElement.style.color = '#FF0000';
                        turnTimerElement.style.animation = 'pulse 0.5s infinite';
                    } else {
                        turnTimerElement.style.color = '#FFD700';
                        turnTimerElement.style.animation = 'none';
                    }
                } else {
                    turnTimerElement.textContent = '等待中...';
                    turnTimerElement.style.color = '#888';
                    turnTimerElement.style.animation = 'none';
                }
                
                document.getElementById('currentWeapon').textContent = 
                    this.weapons[this.players[this.currentPlayer].selectedWeapon].name;
                
                // 更新血量
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    const percentage = (player.hp / player.maxHP) * 100;
                    document.getElementById(`player${id}HP`).textContent = player.hp;
                    document.getElementById(`player${id}HPBar`).style.width = percentage + '%';
                });
            }
            
            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 调试信息：检查是否有数据要绘制
                if (!this.terrain) {
                    console.warn('地形数据不存在');
                    return;
                }
                
                if (!this.players) {
                    console.warn('玩家数据不存在');
                    return;
                }
                
                // 绘制地形
                this.drawTerrain();
                
                // 绘制火焰区域
                this.drawFireZones();
                
                // 绘制障碍物
                this.drawObstacles();
                
                // 绘制玩家
                this.drawPlayers();
                
                // 绘制弹道
                this.drawProjectiles();
                
                // 绘制爆炸
                this.drawExplosions();
                
                // 绘制粒子
                this.drawParticles();
                
                // 绘制物理状态信息
                this.drawPhysicsStatus();
            }
            
            drawTerrain() {
                // 调试信息
                if (!this.terrain || this.terrain.length === 0) {
                    console.warn('drawTerrain: 地形数据为空');
                    return;
                }
                
                // 绘制基础地形（土壤），使用当前主题颜色
                const groundColor = this.currentTheme ? this.currentTheme.ground : '#8B4513';
                this.ctx.fillStyle = groundColor;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height);
                
                // 绘制真实地形轮廓
                this.terrain.forEach(point => {
                    this.ctx.lineTo(point.x, point.height);
                });
                
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // 绘制地表，颜色根据主题调整
                let surfaceColor = '#228B22'; // 默认绿色
                if (this.currentTheme) {
                    switch(this.currentTheme.name) {
                        case 'desert':
                            surfaceColor = '#F4A460'; // 沙色
                            break;
                        case 'arctic':
                            surfaceColor = '#FFFFFF'; // 白色
                            break;
                        case 'night':
                            surfaceColor = '#2F4F4F'; // 深灰色
                            break;
                        case 'alien':
                            surfaceColor = '#9370DB'; // 紫色
                            break;
                        case 'forest':
                            surfaceColor = '#228B22'; // 深绿色
                            break;
                        default:
                            surfaceColor = '#228B22'; // 默认绿色
                    }
                }
                
                this.ctx.fillStyle = surfaceColor;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height);
                
                this.terrain.forEach(point => {
                    this.ctx.lineTo(point.x, point.height);
                });
                
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // 绘制弹坑视觉效果
                this.drawCraterEffects();
            }
            
            drawPlayers() {
                if (!this.players) {
                    console.warn('drawPlayers: 玩家数据不存在');
                    return;
                }
                
                Object.keys(this.players).forEach(id => {
                    const player = this.players[id];
                    
                    if (!player) {
                        console.warn(`drawPlayers: 玩家${id}数据不存在`);
                        return;
                    }
                    
                    // 绘制玩家
                    this.ctx.fillStyle = player.color;
                    this.ctx.fillRect(player.x - 10, player.y - 10, 20, 20);
                    
                    // 如果玩家站在障碍物上，绘制特殊指示
                    if (player.standingOnObstacle) {
                        this.ctx.strokeStyle = '#FFD700';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(player.x, player.y, 16, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // 绘制小的平台指示
                        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        this.ctx.fillRect(player.x - 12, player.y + 12, 24, 3);
                    }
                    
                    // 如果玩家在飞行，绘制飞行效果
                    if (player.isFlying) {
                        this.ctx.fillStyle = 'rgba(135, 206, 235, 0.5)';
                        this.ctx.fillRect(player.x - 15, player.y - 15, 30, 30);
                        
                        // 绘制飞行轨迹
                        this.ctx.strokeStyle = 'rgba(135, 206, 235, 0.8)';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    // 如果玩家在燃烧，绘制火焰效果
                    if (player.burning) {
                        this.ctx.fillStyle = '#FF6347';
                        this.ctx.globalAlpha = 0.7;
                        this.ctx.fillRect(player.x - 12, player.y - 12, 24, 24);
                        this.ctx.globalAlpha = 1;
                    }
                    
                    // 绘制炮管方向
                    if (id == this.currentPlayer && this.isTurnActive) {
                        const radians = (player.angle * Math.PI) / 180;
                        const endX = player.x + Math.cos(radians) * 30;
                        const endY = player.y - Math.sin(radians) * 30;
                        
                        // 根据模式改变炮管颜色
                        this.ctx.strokeStyle = player.flyMode ? '#87CEEB' : player.color;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                        
                        // 绘制角度范围指示器（半透明扇形）
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.arc(player.x, player.y, 40, 0, Math.PI, false);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // 绘制0°和180°边界线
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 1;
                        this.ctx.setLineDash([5, 5]);
                        
                        // 0°线（向右）
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(player.x + 35, player.y);
                        this.ctx.stroke();
                        
                        // 180°线（向左）
                        this.ctx.beginPath();
                        this.ctx.moveTo(player.x, player.y);
                        this.ctx.lineTo(player.x - 35, player.y);
                        this.ctx.stroke();
                        
                        this.ctx.setLineDash([]); // 重置虚线
                        
                        // 绘制角度标记
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'center';
                        
                        // 0°标记
                        this.ctx.fillText('0°', player.x + 45, player.y + 3);
                        // 90°标记
                        this.ctx.fillText('90°', player.x, player.y - 45);
                        // 180°标记
                        this.ctx.fillText('180°', player.x - 45, player.y + 3);
                    }
                    
                    // 绘制玩家编号
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(id, player.x, player.y + 5);
                    
                    // 如果是飞行模式，在玩家上方显示提示
                    if (player.flyMode && id == this.currentPlayer) {
                        this.ctx.fillStyle = player.hasFlownThisTurn ? '#888888' : '#87CEEB';
                        this.ctx.font = 'bold 12px Arial';
                        const text = player.hasFlownThisTurn ? '已飞行' : '飞行';
                        this.ctx.fillText(text, player.x, player.y - 25);
                    }
                });
            }
            
            drawProjectiles() {
                this.projectiles.forEach(proj => {
                    // 绘制轨迹
                    if (proj.trail.length > 1) {
                        this.ctx.strokeStyle = proj.weapon.color;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(proj.trail[0].x, proj.trail[0].y);
                        
                        for (let i = 1; i < proj.trail.length; i++) {
                            this.ctx.lineTo(proj.trail[i].x, proj.trail[i].y);
                        }
                        this.ctx.stroke();
                    }
                    
                    // 绘制弹头
                    this.ctx.fillStyle = proj.weapon.color;
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawExplosions() {
                this.explosions.forEach(explosion => {
                    const alpha = explosion.life / 30;
                    this.ctx.fillStyle = explosion.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    this.ctx.beginPath();
                    this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    this.ctx.beginPath();
                    const size = particle.size || 2; // 使用粒子的大小属性，默认为2
                    this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawFireZones() {
                this.fireZones.forEach(zone => {
                    const alpha = zone.life / zone.maxLife;
                    
                    // 绘制火焰区域
                    this.ctx.fillStyle = `rgba(255, 99, 71, ${alpha * 0.3})`;
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // 绘制火焰边缘
                    this.ctx.strokeStyle = `rgba(255, 69, 0, ${alpha * 0.8})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // 绘制跳动的火焰效果
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * 45) * Math.PI / 180;
                        const flameLength = 10 + Math.random() * 15;
                        const startX = zone.x + Math.cos(angle) * (zone.radius - 5);
                        const startY = zone.y + Math.sin(angle) * (zone.radius - 5);
                        const endX = startX + Math.cos(angle) * flameLength;
                        const endY = startY + Math.sin(angle) * flameLength;
                        
                        this.ctx.strokeStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha * 0.6})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                    }
                });
            }
            
            drawCraterEffects() {
                this.craters.forEach(crater => {
                    crater.age++; // 增加弹坑年龄
                    
                    // 计算透明度（新弹坑更明显）
                    const maxAge = 300; // 5秒后完全淡化
                    const alpha = Math.max(0, 1 - crater.age / maxAge);
                    
                    if (alpha > 0) {
                        // 绘制弹坑阴影
                        this.ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                        this.ctx.beginPath();
                        this.ctx.ellipse(crater.x, crater.y + 15, crater.radius * 1.0, crater.radius * 0.3, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 绘制弹坑边缘土色高光
                        this.ctx.strokeStyle = `rgba(139, 69, 19, ${alpha * 0.9})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.95, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // 绘制弹坑内部深色区域
                        this.ctx.fillStyle = `rgba(101, 67, 33, ${alpha * 0.6})`;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.7, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 绘制弹坑最深处
                        this.ctx.fillStyle = `rgba(80, 50, 20, ${alpha * 0.7})`;
                        this.ctx.beginPath();
                        this.ctx.arc(crater.x, crater.y, crater.radius * 0.4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 新弹坑有烟雾效果
                        if (crater.age < 60) {
                            this.drawCraterSmoke(crater, alpha);
                        }
                    }
                });
                
                // 清理老化的弹坑视觉效果
                this.craters = this.craters.filter(crater => crater.age < 300);
            }
            
            drawCraterSmoke(crater, alpha) {
                // 绘制弹坑烟雾效果
                const smokeParticles = 5;
                for (let i = 0; i < smokeParticles; i++) {
                    const angle = (crater.age * 0.1 + i * (Math.PI * 2 / smokeParticles)) % (Math.PI * 2);
                    const distance = crater.radius * 0.3 + Math.sin(crater.age * 0.05 + i) * 10;
                    const x = crater.x + Math.cos(angle) * distance;
                    const y = crater.y - crater.age * 0.5 + Math.sin(crater.age * 0.1 + i) * 5;
                    
                    const smokeAlpha = alpha * (1 - crater.age / 60) * 0.3;
                    this.ctx.fillStyle = `rgba(100, 100, 100, ${smokeAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3 + Math.sin(crater.age * 0.1 + i) * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawObstacles() {
                // 倒序遍历以安全删除元素
                for (let obstacleIndex = this.obstacles.length - 1; obstacleIndex >= 0; obstacleIndex--) {
                    const obstacle = this.obstacles[obstacleIndex];
                    
                    // 检查障碍物是否应该被移除（被消耗完毕）
                    if (this.checkObstacleDestruction(obstacle, obstacleIndex)) {
                        continue; // 如果被移除，跳过绘制
                    }
                    
                    // 检查是否是当前玩家的支撑障碍物
                    const currentPlayer = this.players[this.currentPlayer];
                    const isSupporting = (currentPlayer.currentSupportingObstacle === obstacle);
                    
                    // 使用剪切路径来创建变形效果
                    this.ctx.save();
                    
                    // 绘制不同类型的障碍物
                    this.drawObstacleByType(obstacle, isSupporting);
                    
                    this.ctx.restore();
                }
            }
            
            drawObstacleByType(obstacle, isSupporting) {
                // 根据障碍物类型和主题绘制不同的外观
                
                // 创建基本形状路径并处理弹坑
                this.ctx.beginPath();
                
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                    case 'moon_rock':
                        this.ctx.rect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                        break;
                        
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        break;
                        
                    case 'crystal':
                        // 水晶形状 - 六边形
                        const sides = 6;
                        const radius = obstacle.width / 2;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const x = obstacle.x + radius * Math.cos(angle);
                            const y = obstacle.y + radius * Math.sin(angle);
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        break;
                        
                    case 'tree_platform':
                    case 'mushroom':
                        // 圆形平台
                        this.ctx.arc(obstacle.x, obstacle.y, obstacle.width/2, 0, Math.PI * 2);
                        break;
                        
                    default:
                        this.ctx.rect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                }
                
                // 从基本形状中减去弹坑
                obstacle.craters.forEach(crater => {
                    const worldX = obstacle.x + crater.x;
                    const worldY = obstacle.y + crater.y;
                    
                    if (worldX >= obstacle.x - obstacle.width/2 && worldX <= obstacle.x + obstacle.width/2 &&
                        worldY >= obstacle.y - obstacle.height/2 && worldY <= obstacle.y + obstacle.height/2) {
                        this.ctx.arc(worldX, worldY, crater.radius, 0, Math.PI * 2, true);
                    }
                });
                
                this.ctx.clip();
                
                // 根据类型和主题选择颜色
                const colors = this.getObstacleColors(obstacle.type, obstacle.theme);
                
                // 绘制主体
                this.ctx.fillStyle = colors.main;
                this.drawObstacleShape(obstacle);
                
                // 绘制顶部高亮
                if (isSupporting) {
                    this.ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                } else {
                    this.ctx.fillStyle = colors.highlight;
                }
                this.drawObstacleHighlight(obstacle);
                
                // 绘制纹理和装饰
                this.drawObstacleTexture(obstacle, colors);
            }
            
            getObstacleColors(type, theme) {
                const colorSchemes = {
                    platform: { main: '#8B7355', highlight: 'rgba(139, 115, 85, 0.8)', texture: 'rgba(101, 67, 33, 0.4)' },
                    cloud: { main: 'rgba(255, 255, 255, 0.9)', highlight: 'rgba(255, 255, 255, 1)', texture: 'rgba(200, 200, 200, 0.8)' },
                    iceberg: { main: '#E0FFFF', highlight: '#F0F8FF', texture: 'rgba(176, 224, 230, 0.6)' },
                    rock: { main: '#8B7355', highlight: '#A0522D', texture: 'rgba(139, 69, 19, 0.5)' },
                    crystal: { main: '#9370DB', highlight: '#BA55D3', texture: 'rgba(138, 43, 226, 0.3)' },
                    tree_platform: { main: '#8FBC8F', highlight: '#98FB98', texture: 'rgba(34, 139, 34, 0.4)' },
                    mushroom: { main: '#F4A460', highlight: '#DEB887', texture: 'rgba(210, 180, 140, 0.5)' },
                    moon_rock: { main: '#708090', highlight: '#778899', texture: 'rgba(105, 105, 105, 0.4)' },
                    cactus: { main: '#228B22', highlight: '#32CD32', texture: 'rgba(0, 100, 0, 0.3)' },
                    floating_rock: { main: '#4B0082', highlight: '#6A0DAD', texture: 'rgba(75, 0, 130, 0.3)' }
                };
                
                return colorSchemes[type] || colorSchemes.platform;
            }
            
            drawObstacleShape(obstacle) {
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                    case 'moon_rock':
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                        break;
                        
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'crystal':
                        this.ctx.beginPath();
                        const sides = 6;
                        const radius = obstacle.width / 2;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const x = obstacle.x + radius * Math.cos(angle);
                            const y = obstacle.y + radius * Math.sin(angle);
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                        
                    case 'tree_platform':
                    case 'mushroom':
                        this.ctx.beginPath();
                        this.ctx.arc(obstacle.x, obstacle.y, obstacle.width/2, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    default:
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            obstacle.height
                        );
                }
            }
            
            drawObstacleHighlight(obstacle) {
                switch(obstacle.type) {
                    case 'cloud':
                    case 'iceberg':
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y - obstacle.height/3, obstacle.width/2.2, obstacle.height/6, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    default:
                        this.ctx.fillRect(
                            obstacle.x - obstacle.width/2, 
                            obstacle.y - obstacle.height/2, 
                            obstacle.width, 
                            4
                        );
                }
            }
            
            drawObstacleTexture(obstacle, colors) {
                this.ctx.fillStyle = colors.texture;
                
                switch(obstacle.type) {
                    case 'platform':
                    case 'rock':
                        // 石头纹理
                        const textureCount = Math.floor(obstacle.width / 30);
                        for (let i = 0; i < textureCount; i++) {
                            const tx = obstacle.x - obstacle.width/2 + (i + 0.5) * obstacle.width/textureCount;
                            const ty = obstacle.y - obstacle.height/2 + obstacle.height/2;
                            this.ctx.fillRect(tx - 2, ty - 2, 4, 4);
                        }
                        break;
                        
                    case 'crystal':
                        // 水晶光泽
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.fillRect(obstacle.x - 5, obstacle.y - obstacle.height/3, 10, obstacle.height/3);
                        break;
                        
                    case 'cloud':
                        // 云朵边缘
                        this.ctx.strokeStyle = colors.texture;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                        this.ctx.stroke();
                        break;
                        
                    case 'tree_platform':
                        // 树叶纹理
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * 120) * Math.PI / 180;
                            const leafX = obstacle.x + Math.cos(angle) * obstacle.width/4;
                            const leafY = obstacle.y + Math.sin(angle) * obstacle.height/4;
                            this.ctx.fillRect(leafX - 2, leafY - 2, 4, 4);
                        }
                        break;
                }
            }
            
            checkObstacleDestruction(obstacle, obstacleIndex) {
                // 计算障碍物的剩余面积（使用更精确的计算方法）
                const originalArea = obstacle.width * obstacle.height;
                
                // 使用采样方法计算实际被破坏的面积
                let destroyedPixels = 0;
                const sampleStep = 2; // 每2像素采样一次，平衡精度和性能
                
                for (let x = -obstacle.width/2; x < obstacle.width/2; x += sampleStep) {
                    for (let y = -obstacle.height/2; y < obstacle.height/2; y += sampleStep) {
                        // 检查这个点是否在任何弹坑内
                        let inCrater = false;
                        for (let crater of obstacle.craters) {
                            const distance = Math.sqrt(
                                Math.pow(x - crater.x, 2) + 
                                Math.pow(y - crater.y, 2)
                            );
                            if (distance <= crater.radius) {
                                inCrater = true;
                                break;
                            }
                        }
                        if (inCrater) {
                            destroyedPixels += sampleStep * sampleStep;
                        }
                    }
                }
                
                // 如果被破坏的面积超过80%，则移除障碍物
                const destructionRatio = destroyedPixels / originalArea;
                if (destructionRatio > 0.8) {
                    // 创建障碍物完全摧毁的粒子效果
                    this.createObstacleDestructionEffect(obstacle);
                    
                    // 从数组中移除障碍物
                    this.obstacles.splice(obstacleIndex, 1);
                    return true; // 返回true表示障碍物被移除
                }
                return false; // 返回false表示障碍物仍然存在
            }
            
            createObstacleDestructionEffect(obstacle) {
                // 创建大量破坏粒子
                const particleCount = obstacle.type === 'platform' ? 20 : 15;
                const baseColor = obstacle.type === 'platform' ? '#8B7355' : '#E0E0E0';
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: obstacle.x + (Math.random() - 0.5) * obstacle.width,
                        y: obstacle.y + (Math.random() - 0.5) * obstacle.height,
                        vx: (Math.random() - 0.5) * 15,
                        vy: -Math.random() * 10 - 3,
                        color: baseColor,
                        life: 80 + Math.random() * 50,
                        maxLife: 80 + Math.random() * 50,
                        size: 2 + Math.random() * 3
                    });
                }
                
                // 添加一些特殊的破坏效果
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: obstacle.x,
                        y: obstacle.y,
                        vx: Math.cos(i * Math.PI / 4) * 12,
                        vy: Math.sin(i * Math.PI / 4) * 12,
                        color: obstacle.type === 'platform' ? '#654321' : '#C0C0C0',
                        life: 60,
                        maxLife: 60,
                        size: 4
                    });
                }
            }
            
            drawPhysicsStatus() {
                // 绘制当前玩家的物理状态
                const currentPlayer = this.players[this.currentPlayer];
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                
                let statusText = '';
                let statusColor = '';
                
                if (currentPlayer.standingOnObstacle) {
                    statusText = '状态: 站在刚体平台上';
                    statusColor = '#FFD700';
                } else if (currentPlayer.onGround) {
                    statusText = '状态: 站在地面上';
                    statusColor = '#90EE90';
                } else if (currentPlayer.isFlying) {
                    statusText = '状态: 飞行中';
                    statusColor = '#87CEEB';
                } else {
                    statusText = '状态: 空中下落';
                    statusColor = '#FFA500';
                }
                
                // 绘制状态背景
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, this.canvas.height - 70, 250, 50);
                
                // 绘制状态文字
                this.ctx.fillStyle = statusColor;
                this.ctx.fillText(statusText, 15, this.canvas.height - 50);
                
                // 绘制角度信息
                this.ctx.fillStyle = '#87CEEB';
                this.ctx.fillText(`发射角度: ${Math.round(currentPlayer.angle)}° (范围: 0-180°)`, 15, this.canvas.height - 35);
                
                // 绘制障碍物数量信息
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`刚体平台数量: ${this.obstacles.length}`, 15, this.canvas.height - 20);
                
                // 绘制当前支撑障碍物信息
                if (currentPlayer.currentSupportingObstacle) {
                    const obstacle = currentPlayer.currentSupportingObstacle;
                    this.ctx.fillText(`支撑平台: ${obstacle.type} (${Math.round(obstacle.x)}, ${Math.round(obstacle.y)})`, 270, this.canvas.height - 50);
                }
            }
            
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 显示难度选择界面
        function showDifficultySelect() {
            document.getElementById('gameModeScreen').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'flex';
        }

        // 全局函数：启动游戏模式
        function startGameMode(mode, difficulty = 'medium') {
            console.log('startGameMode被调用，模式:', mode, '难度:', difficulty);
            console.log('检查window.game:', window.game);
            
            // 如果游戏实例不存在，尝试立即创建
            if (!window.game) {
                console.log('游戏实例不存在，尝试创建...');
                try {
                    window.game = new TNTBattleGame();
                    console.log('游戏实例创建成功');
                } catch (error) {
                    console.error('创建游戏实例失败:', error);
                    alert('游戏初始化失败: ' + error.message);
                    return;
                }
            }
            
            try {
                console.log('游戏实例存在，调用startGame');
                window.game.startGame(mode, difficulty);
            } catch (error) {
                console.error('启动游戏时出错:', error);
                alert('启动游戏时出错: ' + error.message);
            }
        }

        // 全局函数：重新开始游戏
        function restartGame() {
            try {
                if (window.game && window.game.restart) {
                    window.game.restart();
                } else {
                    console.error('游戏实例未初始化或restart方法不存在');
                    alert('游戏未正确初始化');
                }
            } catch (error) {
                console.error('重新开始游戏时出错:', error);
                alert('重新开始游戏时出错: ' + error.message);
            }
        }

        // 全局函数：返回模式选择
        function backToModeSelect() {
            try {
                if (window.game && window.game.backToModeSelect) {
                    window.game.backToModeSelect();
                } else {
                    console.error('游戏实例未初始化或backToModeSelect方法不存在');
                    alert('游戏未正确初始化');
                }
            } catch (error) {
                console.error('返回模式选择时出错:', error);
                alert('返回模式选择时出错: ' + error.message);
            }
        }

        // 启动游戏
        window.addEventListener('load', () => {
            console.log('页面加载完成，开始初始化游戏');
            try {
                console.log('创建TNTBattleGame实例...');
                window.game = new TNTBattleGame();
                console.log('游戏实例创建成功:', window.game);
                console.log('游戏初始化完成');
            } catch (error) {
                console.error('游戏初始化失败:', error);
                console.error('错误堆栈:', error.stack);
                alert('游戏初始化失败: ' + error.message);
            }
        });

        // 添加DOMContentLoaded事件监听，确保DOM完全加载
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM内容加载完成');
        });
    </script>
</body>
</html> 